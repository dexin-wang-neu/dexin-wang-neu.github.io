<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>spring | 威猛盖哥</title><meta name="keywords" content="spring"><meta name="author" content="盖哥横扫千军"><meta name="copyright" content="盖哥横扫千军"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.Spring AOP1.1使用AOP好处1.集中处理某一关注点&#x2F;横切逻辑2.可以很方便的添加&#x2F;删除关注点3.侵入性少，增强代码可读性及可维护性 1.2 AOP的术语1.Join point（连接点）Spring 官方文档的描述：  A point during the execution of a program, such as the execution of a me">
<meta property="og:type" content="article">
<meta property="og:title" content="spring">
<meta property="og:url" content="https://dexin-wang-neu.github.io/2022/05/17/spring/index.html">
<meta property="og:site_name" content="威猛盖哥">
<meta property="og:description" content="1.Spring AOP1.1使用AOP好处1.集中处理某一关注点&#x2F;横切逻辑2.可以很方便的添加&#x2F;删除关注点3.侵入性少，增强代码可读性及可维护性 1.2 AOP的术语1.Join point（连接点）Spring 官方文档的描述：  A point during the execution of a program, such as the execution of a me">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dexin-wang-neu.github.io/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png">
<meta property="article:published_time" content="2022-05-17T02:06:42.000Z">
<meta property="article:modified_time" content="2022-05-22T07:25:05.996Z">
<meta property="article:author" content="盖哥横扫千军">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dexin-wang-neu.github.io/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dexin-wang-neu.github.io/2022/05/17/spring/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'spring',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-22 15:25:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">威猛盖哥</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">spring</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-17T02:06:42.000Z" title="发表于 2022-05-17 10:06:42">2022-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-22T07:25:05.996Z" title="更新于 2022-05-22 15:25:05">2022-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/spring/">spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="spring"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-Spring-AOP"><a href="#1-Spring-AOP" class="headerlink" title="1.Spring AOP"></a>1.Spring AOP</h2><h3 id="1-1使用AOP好处"><a href="#1-1使用AOP好处" class="headerlink" title="1.1使用AOP好处"></a>1.1使用AOP好处</h3><p><strong>1.集中处理某一关注点&#x2F;横切逻辑</strong><br><strong>2.可以很方便的添加&#x2F;删除关注点</strong><br><strong>3.侵入性少，增强代码可读性及可维护性</strong></p>
<h3 id="1-2-AOP的术语"><a href="#1-2-AOP的术语" class="headerlink" title="1.2 AOP的术语"></a>1.2 AOP的术语</h3><p><strong>1.Join point（连接点）</strong><br>Spring 官方文档的描述：</p>
<blockquote>
<p>A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p>
</blockquote>
<p>程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法的执行。通俗的讲，连接点即表示类里面可以被增强的方法<br><strong>2.Pointcut（切入点）</strong></p>
<blockquote>
<p>Pointcut are expressions that is matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language</p>
</blockquote>
<p>切入点是与连接点匹配的表达式，用于确定是否需要执行通知。切入点使用与连接点匹配的不同类型的表达式，Spring框架使用AspectJ切入点表达式语言。我们可以将切入点理解为需要被拦截的Join point<br><strong>3.Advice（增强&#x2F;通知）</strong><br>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知和环绕通知(切面要完成的功能)<br><strong>4.Aspect（切面）</strong><br>Aspect切面表示Pointcut（切入点）和Advice（增强&#x2F;通知）的结合</p>
<h3 id="1-3-Spring-AOP用法"><a href="#1-3-Spring-AOP用法" class="headerlink" title="1.3 Spring AOP用法"></a>1.3 Spring AOP用法</h3><p><strong>资源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置登录用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUserHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        holder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验用户权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;authService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> CurrentUserHolder.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;admin&quot;</span>.equals(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户无此权限！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;productService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">deleteProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品id为&quot;</span> + id + <span class="string">&quot;的商品成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProductByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品名称为&quot;</span> + name + <span class="string">&quot;的商品成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;100&quot;</span>.equals(id.toString())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该商品不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对业务逻辑类进行增强的方法</strong></p>
<p><strong>1.使用within表达式匹配包类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配ProductServiceImpl类里面的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.aop.service.impl.ProductServiceImpl)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchType</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配com.aop.service包及其子包下所有类的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.aop.service..*)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchPackage</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.使用this、target、bean表达式匹配对象类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配AOP对象的目标对象为指定类型的方法，即ProductServiceImpl的aop代理对象的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;this(com.aop.service.impl.ProductServiceImpl)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchThis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配实现ProductService接口的目标对象</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;target(com.aop.service.ProductService)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTarget</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有以Service结尾的bean里面的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;bean(*Service)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchBean</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.使用args表达式匹配参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配第一个参数为Long类型的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;args(Long, ..) &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchArgs</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.使用@annotation、@within、@target、@args匹配注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配标注有AdminOnly注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.aop.annotation.AdminOnly)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchAnno</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标注有Beta的类底下的方法，要求annotation的Retention级别为CLASS</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@within(com.google.common.annotations.Beta)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchWithin</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标注有Repository的类底下的方法，要求annotation的Retention级别为RUNTIME</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@target(org.springframework.stereotype.Repository)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTarget</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配传入的参数类标注有Repository注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@args(org.springframework.stereotype.Repository)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchArgs</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.使用execution表达式</strong><br>execution表达式是我们在开发过程中最常用的，它的语法如下：</p>
<p><img src="/2022/05/17/spring/1240" alt="execution表达式"></p>
<p><strong>modifier-pattern</strong>：用于匹配public、private等访问修饰符<br><strong>ret-type-pattern</strong>：用于匹配返回值类型，不可省略<br><strong>declaring-type-pattern</strong>：用于匹配包类型<br><strong>modifier-pattern（param-pattern）</strong>：用于匹配类中的方法，不可省略<br><strong>throws-pattern</strong>：用于匹配抛出异常的方法</p>
<blockquote>
<p>切面Aspect代码</p>
<p>@Aspect：告诉Spring当前类是一个切面类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>    <span class="comment">//一定要写这个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下的方法名以delete开头、参数类型为Long的public方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.aop.service.impl.ProductServiceImpl.delete*(Long))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchCondition</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用matchCondition这个切入点进行增强</span></span><br><span class="line">    <span class="meta">@Before(&quot;matchCondition()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before 前置通知......&quot;</span>);</span><br><span class="line">        authService.checkAccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对切面类增强的方法进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置用户名</span></span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.selectProduct(<span class="number">100L</span>);</span><br><span class="line">        productService.deleteProductByName(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果，（只有deleteProductById方法拦截成功）：</span></span><br><span class="line">查询商品成功！</span><br><span class="line">删除商品名称为衣服的商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: 该用户无此权限！</span><br><span class="line"></span><br><span class="line">	at com.aop.service.impl.AuthServiceImpl.checkAccess(AuthServiceImpl.java:<span class="number">15</span>)</span><br><span class="line">	at com.aop.security.SecurityAspect.before(SecurityAspect.java:<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在多个表达式之间使用连接符匹配多个条件， 如使用||表示“或”，使用 &amp;&amp;表示“且”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下方法名以select或delete开头的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.select*(..)) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;execution(* com.aop.service.impl.ProductServiceImpl.delete*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchCondition</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用matchCondition这个切入点进行增强</span></span><br><span class="line"><span class="meta">@Before(&quot;matchCondition()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;before 前置通知......&quot;</span>);</span><br><span class="line">   authService.checkAccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.selectProduct(<span class="number">100L</span>);</span><br><span class="line">        productService.deleteProductByName(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果；全部拦截成功</span></span><br><span class="line">before 前置通知......</span><br><span class="line">查询商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line">删除商品名称为衣服的商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line">删除商品id为<span class="number">100</span>的商品成功！</span><br></pre></td></tr></table></figure>

<h3 id="1-4-Advice注解"><a href="#1-4-Advice注解" class="headerlink" title="1.4 Advice注解"></a>1.4 Advice注解</h3><p>Advice注解一共有五种，分别是：<br><strong>1.@Before前置通知</strong><br>前置通知在切入点运行前执行，不会影响切入点的逻辑<br><strong>2.@After后置通知</strong><br>后置通知在切入点正常运行结束后执行，如果切入点抛出异常，则在抛出异常前执行<br><strong>3.@AfterThrowing异常通知</strong><br>异常通知在切入点抛出异常前执行，如果切入点正常运行（未抛出异常），则不执行<br><strong>4.@AfterReturning返回通知</strong><br>返回通知在切入点正常运行结束后执行，如果切入点抛出异常，则不执行<br><strong>5.@Around环绕通知</strong><br>环绕通知是功能最强大的通知，可以在切入点执行前后自定义一些操作。环绕通知需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下面的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchAll</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;matchAll()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        authService.checkAccess();</span><br><span class="line">        System.out.println(<span class="string">&quot;befor 在切入点执行前运行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = joinPoint.proceed(joinPoint.getArgs());<span class="comment">//获取参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;after 在切入点执行后运行,result = &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after 在切入点执行后抛出exception运行&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">        productService.selectProduct(<span class="number">10L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">before 在切入点执行前运行</span><br><span class="line">删除商品id为<span class="number">100</span>的商品成功！</span><br><span class="line">after 在切入点执行后运行,result = <span class="number">100</span></span><br><span class="line"><span class="keyword">finally</span>......</span><br><span class="line">before 在切入点执行前运行</span><br><span class="line">查询商品失败！</span><br><span class="line">after 在切入点执行后抛出exception运行</span><br><span class="line">java.lang.RuntimeException: 该商品不存在！</span><br><span class="line">	at com.aop.service.impl.ProductServiceImpl.selectProduct(ProductServiceImpl.java:<span class="number">41</span>)</span><br><span class="line"><span class="keyword">finally</span>......</span><br></pre></td></tr></table></figure>

<p>在执行ProceedingJoinPoint对象的proceed方法前相当于Before前置通知；执行proceed方法相当于运行切入点（同时可以获取参数）；在方法执行之后相当于After后置通知，如果运行切入点抛出异常，则catch中的内容相当于AfterThrowing异常通知;finally中的内容无论切入点是否抛出异常，都将执行</p>
<h3 id="1-5-使用总结"><a href="#1-5-使用总结" class="headerlink" title="1.5 使用总结"></a>1.5 使用总结</h3><blockquote>
<p>AOP：【动态代理】<br>          指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</p>
<p>  1、导入aop模块；Spring AOP：(spring-aspects)<br>  2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<br>  3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；<br>          通知方法：<br>              前置通知(@Before)：logStart：在目标方法(div)运行之前运行<br>              后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<br>              返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<br>              异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<br>              环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）<br>  4、给切面类的目标方法标注何时何地运行（通知注解）；<br>  5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<br>  6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)<br>  7、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】<br>          在Spring中很多的 @EnableXXX;</p>
<p>  三步：<br>      1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）<br>      2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）<br>      3）、开启基于注解的aop模式；@EnableAspectJAutoProxy</p>
</blockquote>
<h3 id="1-7-案例"><a href="#1-7-案例" class="headerlink" title="1.7 案例"></a>1.7 案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">我定义了一个除法方法，作为一个切面：需要增强的业务方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.kun.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathCalculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathCalculator...div...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i/j;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span>： 告诉Spring当前类是一个切面类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspects</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽取公共的切入点表达式</span></span><br><span class="line">    <span class="comment">//1、本类引用</span></span><br><span class="line">    <span class="comment">//2、其他的切面引用</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.kun.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logStart</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;运行。。。@Before:参数列表是：&#123;&quot;</span>+Arrays.asList(args)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(&quot;com.kun.aop.LogAspects.pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logEnd</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;结束。。。@After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JoinPoint一定要出现在参数表的第一位</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;</span>+result+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;异常。。。异常信息：&#123;&quot;</span>+exception+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@EnableAspectJAutoProxy:注解开启切面代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">aop的配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kun.aop.LogAspects;</span><br><span class="line"><span class="keyword">import</span> com.kun.aop.MathCalculator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfigOfAOP</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//业务逻辑类加入容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MathCalculator <span class="title function_">calculator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MathCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切面类加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogAspects <span class="title function_">logAspects</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogAspects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8代理对象创建过程"><a href="#1-8代理对象创建过程" class="headerlink" title="1.8代理对象创建过程"></a>1.8代理对象创建过程</h3><h4 id="1-8-1-EnableAspectJAutoProxy"><a href="#1-8-1-EnableAspectJAutoProxy" class="headerlink" title="1.8.1@EnableAspectJAutoProxy"></a>1.8.1@EnableAspectJAutoProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">     * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它导入了一个<strong>AspectJAutoProxyRegistrar</strong>组件，进一步查看其代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.config.AopConfigUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.context.annotation.MetadataUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy&#125; annotation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">     * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">enableAJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">                attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它实现了<strong>ImportBeanDefinitionRegistrar</strong>接口，这个接口可以向IOC容器中注册bean。 由此可以推测aop利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion。</p>
</blockquote>
<p><img src="/2022/05/17/spring/1140836-20181031200151572-1248357045.png" alt="img"></p>
<blockquote>
<p><em>IOC容器中注入了一个internalAutoProxyCreator&#x3D;AnnotationAwareAspectJAutoProxyCreator的bean，</em>到此可以得出结论，@EnableAspectJAutoProxy给容器中注册一个AnnotationAwareAspectJAutoProxyCreator。</p>
</blockquote>
<h4 id="1-8-2-AnnotationAwareAspectJAutoProxyCreator创建过程"><a href="#1-8-2-AnnotationAwareAspectJAutoProxyCreator创建过程" class="headerlink" title="1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程"></a>1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程</h4><p><img src="/2022/05/17/spring/1140836-20181031201123887-743732675.png" alt="img"></p>
<blockquote>
<p>在此需要关注两点内容：</p>
<p>1）关注后置处理器SmartInstantiationAwareBeanPostProcessor（在bean初始化完成前后做事情）</p>
<p>2）关注自动装配BeanFactory。</p>
</blockquote>
<blockquote>
<p>通过代码查看，发现父类AbstractAutoProxyCreator中有后置处理器的内容；AbstactAdvisorAutoProxyCreator类中重写了其父类AbstractAutoProxyCreator中setBeanFactory()方法，在AnnotationAwareAspectJAutoProxyCreator类中initBeanFactory()方法完成了自动装配BeanFactory。</p>
</blockquote>
<p>1）、 @EnableAspectJAutoProxy 开启AOP功能<br> 2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator<br> 3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；<br> 4）、容器的创建流程：<br>        1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象<br>        2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean<br>            1）、创建业务逻辑组件和切面组件<br>            2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>            3）、组件创建完之后，判断组件是否需要增强<br>                     是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；<br> 5）、执行目标方法：<br>        1）、代理对象执行目标方法<br>        2）、CglibAopProxy.intercept()；<br>             1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）<br>             2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>             3）、效果：<br>                      正常执行：前置通知-》目标方法-》后置通知-》返回通知<br>                      出现异常：前置通知-》目标方法-》后置通知-》异常通知</p>
<h3 id="1-9-面试回答AOP"><a href="#1-9-面试回答AOP" class="headerlink" title="1.9 面试回答AOP"></a>1.9 面试回答AOP</h3><p>简单说说 AOP 的设计：</p>
<ol>
<li>每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li>
<li>每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP。</li>
<li>当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦截器”。内层拦截器的设计就是职责连的设计。</li>
</ol>
<p><strong>可以将 AOP 分成 2 个部分。</strong><br>第一：代理的创建；<br>第二：代理的调用。</p>
<ol>
<li>代理的创建（按步骤）：</li>
</ol>
<ul>
<li>首先，需要创建代理工厂，代理工厂需要 3 个重要的信息：拦截器数组，目标对象接口数组，目标对象。</li>
<li>创建代理工厂时，默认会在拦截器数组尾部再增加一个默认拦截器 —— 用于最终的调用目标方法。</li>
<li>当调用 getProxy 方法的时候，会根据接口数量大余 0 条件返回一个代理对象（JDK or Cglib）。</li>
<li>注意：创建代理对象时，同时会创建一个外层拦截器，这个拦截器就是 Spring 内核的拦截器。用于控制整个 AOP 的流程。</li>
</ul>
<ol start="2">
<li>代理的调用</li>
</ol>
<ul>
<li>当对代理对象进行调用时，就会触发外层拦截器。</li>
<li>外层拦截器根据代理配置信息，创建内层拦截器链。创建的过程中，会根据表达式判断当前拦截是否匹配这个拦截器。而这个拦截器链设计模式就是职责链模式。</li>
<li>当整个链条执行到最后时，就会触发创建代理时那个尾部的默认拦截器，从而调用目标方法。最后返回。</li>
</ul>
<p>题外话：Spring 的事务也就是个拦截器。</p>
<p><img src="/2022/05/17/spring/124011111" alt="img"></p>
<p><img src="/2022/05/17/spring/AOP%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B" alt="img"></p>
<h2 id="2-Spring-三级缓存"><a href="#2-Spring-三级缓存" class="headerlink" title="2. Spring 三级缓存"></a>2. Spring 三级缓存</h2><h3 id="2-1-Spring-Bean的循环依赖"><a href="#2-1-Spring-Bean的循环依赖" class="headerlink" title="2.1 Spring Bean的循环依赖"></a><strong>2.1 Spring Bean的循环依赖</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这其实就是Spring环境下典型的循环依赖场景</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类：</p>
<p><img src="/2022/05/17/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p>
<ol>
<li><p><strong>构造器注入循环依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p>
<p><img src="/2022/05/17/spring/image-20210912191502658.png" alt="image-20210912191502658"></p>
</li>
</ol>
<blockquote>
<p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘） </p>
<p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决~~~</p>
</blockquote>
<ol start="2">
<li><p><strong>field属性注入（setter方法注入）循环依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>结果：项目启动成功，能够正常work</strong></p>
</li>
<li><p><strong><code>prototype</code> field属性注入循环依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单例Bean内注入</span></span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private A a;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/17/spring/image-20210912191727007.png" alt="image-20210912191727007"></p>
</li>
</ol>
<blockquote>
<p>对于Spring循环依赖的情况总结如下：</p>
<ol>
<li>不能解决的情况： 1. 构造器注入循环依赖 2. <code>prototype</code> field属性注入循环依赖</li>
<li>能解决的情况： 1. field属性注入（setter方法注入）循环依赖</li>
</ol>
</blockquote>
<p><strong>Spring创建Bean的流程</strong></p>
<p><img src="/2022/05/17/spring/20210912.png" alt="20210912"></p>
<p>对Bean的创建最为核心三个方法解释如下：</p>
<ul>
<li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li>
<li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li>
<li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li>
</ul>
<p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p>
<p><strong>Spring容器的<code>&#39;三级缓存&#39;</code></strong></p>
<p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p>
<p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line">	<span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line">	<span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line">	<span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line">	<span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p>
<ol>
<li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li>
<li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li>
<li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li>
</ol>
<p><strong>获取单例Bean的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">				singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isActuallyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li>
<li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li>
<li>如果还是获取不到，且允许singletonFactories（allowEarlyReference&#x3D;true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从</strong><code>**singletonFactories**</code><strong>中移除，并且放进</strong><code>**earlySingletonObjects**</code><strong>。其实也就是从三级缓存</strong><code>**移动（是剪切、不是复制哦~）**</code><strong>到了二级缓存）</strong></li>
</ol>
<blockquote>
<p> <strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong></p>
</blockquote>
<p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span></span><br><span class="line">@<span class="title class_">FunctionalInterface</span></span><br><span class="line">public interface <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">	T <span class="title function_">getObject</span>() throws <span class="title class_">BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。 </p>
</blockquote>
<p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p>
<p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来 <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p>
<h3 id="2-2-源码解析"><a href="#2-2-源码解析" class="headerlink" title="2.2 源码解析"></a>2.2 源码解析</h3><p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FactoryBeanRegistrySupport</span> implements <span class="title class_">ConfigurableBeanFactory</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	protected &lt;T&gt; T <span class="title function_">doGetBean</span>(final <span class="title class_">String</span> name, @<span class="title class_">Nullable</span> final <span class="title class_">Class</span>&lt;T&gt; requiredType, @<span class="title class_">Nullable</span> final <span class="title class_">Object</span>[] args, boolean typeCheckOnly) throws <span class="title class_">BeansException</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">		<span class="comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span></span><br><span class="line">		<span class="title class_">Object</span> sharedInstance = <span class="title function_">getSingleton</span>(beanName);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			<span class="title function_">markBeanAsCreated</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// Create bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.<span class="title function_">isSingleton</span>()) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span></span><br><span class="line">			<span class="comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span></span><br><span class="line">			<span class="comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span></span><br><span class="line">			sharedInstance = <span class="title function_">getSingleton</span>(beanName, () -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="title function_">createBean</span>(beanName, mbd, args);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (<span class="title class_">BeansException</span> ex) &#123;</span><br><span class="line">					<span class="title function_">destroySingleton</span>(beanName);</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			bean = <span class="title function_">getObjectForBeanInstance</span>(sharedInstance, name, beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span></span><br><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractBeanFactory</span> implements <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	protected <span class="title class_">Object</span> <span class="title function_">doCreateBean</span>(final <span class="title class_">String</span> beanName, final <span class="title class_">RootBeanDefinition</span> mbd, final @<span class="title class_">Nullable</span> <span class="title class_">Object</span>[] args) throws <span class="title class_">BeanCreationException</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span></span><br><span class="line">		instanceWrapper = <span class="title function_">createBeanInstance</span>(beanName, mbd, args);</span><br><span class="line">		<span class="comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span></span><br><span class="line">		<span class="comment">// 注意：此处是原始对象，这点非常的重要</span></span><br><span class="line">		final <span class="title class_">Object</span> bean = instanceWrapper.<span class="title function_">getWrappedInstance</span>();</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span></span><br><span class="line">		<span class="comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span></span><br><span class="line">		<span class="comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span></span><br><span class="line">		boolean earlySingletonExposure = (mbd.<span class="title function_">isSingleton</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">allowCircularReferences</span> &amp;&amp; <span class="title function_">isSingletonCurrentlyInCreation</span>(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.<span class="title function_">isTraceEnabled</span>()) &#123;</span><br><span class="line">				logger.<span class="title function_">trace</span>(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span></span><br><span class="line">			<span class="comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span></span><br><span class="line">			<span class="comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span></span><br><span class="line">			<span class="comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span></span><br><span class="line">			<span class="comment">// 若不需要执行AOP的逻辑，直接返回Bean</span></span><br><span class="line">			<span class="title function_">addSingletonFactory</span>(beanName, () -&gt; <span class="title function_">getEarlyBeanReference</span>(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title class_">Object</span> exposedObject = bean; <span class="comment">//exposedObject 是最终返回的对象</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 填充属于，解决@Autowired依赖~</span></span><br><span class="line">		<span class="title function_">populateBean</span>(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">// 执行初始化回调方法们~~~</span></span><br><span class="line">		exposedObject = <span class="title function_">initializeBean</span>(beanName, exposedObject, mbd);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span></span><br><span class="line">		<span class="comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span></span><br><span class="line">			<span class="comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span></span><br><span class="line">			<span class="comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span></span><br><span class="line">			<span class="comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了&quot;偷天换日&quot; 特别适合中间件的设计</span></span><br><span class="line">			<span class="comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span></span><br><span class="line">			<span class="title class_">Object</span> earlySingletonReference = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">				<span class="comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span></span><br><span class="line">				<span class="comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span></span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125; </span><br><span class="line"></span><br><span class="line">				<span class="comment">// allowRawInjectionDespiteWrapping这个值默认是false</span></span><br><span class="line">				<span class="comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">allowRawInjectionDespiteWrapping</span> &amp;&amp; <span class="title function_">hasDependentBean</span>(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span></span><br><span class="line">					<span class="title class_">String</span>[] dependentBeans = <span class="title function_">getDependentBeans</span>(beanName);</span><br><span class="line">					<span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.<span class="property">length</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 一个个检查它所以Bean</span></span><br><span class="line">					<span class="comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span></span><br><span class="line">					<span class="comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span></span><br><span class="line">					<span class="comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span></span><br><span class="line">					<span class="comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="title class_">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!<span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.<span class="title function_">add</span>(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span></span><br><span class="line">					<span class="comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span></span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">								<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">								<span class="title class_">StringUtils</span>.<span class="title function_">collectionToCommaDelimitedString</span>(actualDependentBeans) +</span><br><span class="line">								<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">								<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">								<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">								<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 虽然是remove方法 但是它的返回值也非常重要</span></span><br><span class="line">	<span class="comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span></span><br><span class="line">	protected boolean <span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(<span class="params"><span class="built_in">String</span> beanName</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">alreadyCreated</span>.<span class="title function_">contains</span>(beanName)) &#123;</span><br><span class="line">			<span class="title function_">removeSingleton</span>(beanName);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p>
<p>这里有个小细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">	exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p>
<h3 id="2-3-流程总结（非常重要）"><a href="#2-3-流程总结（非常重要）" class="headerlink" title="2.3 流程总结（非常重要）"></a>2.3 流程总结（<code>非常重要</code>）</h3><p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p>
<p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean(&quot;a&quot;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T <span class="title function_">doGetBean</span>(<span class="params">...</span>)&#123;</span><br><span class="line">	... </span><br><span class="line">	<span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line">	<span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line">	<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">		<span class="title function_">markBeanAsCreated</span>(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line">	<span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line">	<span class="title class_">Object</span> beanInstance = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line">	<span class="comment">//1、标注a正在创建中~</span></span><br><span class="line">	<span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line">	<span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line">	<span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">	sharedInstance = <span class="title function_">getSingleton</span>(beanName, () -&gt; &#123; ... <span class="keyword">return</span> <span class="title function_">createBean</span>(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected <span class="title class_">Object</span> <span class="title function_">doCreateBean</span>(<span class="params"></span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span></span><br><span class="line">	instanceWrapper = <span class="title function_">createBeanInstance</span>(beanName, mbd, args);</span><br><span class="line">	<span class="comment">// 此处bean为&quot;原始Bean&quot;   也就是这里的A实例对象：A@1234</span></span><br><span class="line">	final <span class="title class_">Object</span> bean = instanceWrapper.<span class="title function_">getWrappedInstance</span>();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span></span><br><span class="line">	boolean earlySingletonExposure = (mbd.<span class="title function_">isSingleton</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">allowCircularReferences</span> &amp;&amp; <span class="title function_">isSingletonCurrentlyInCreation</span>(beanName));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span></span><br><span class="line">	<span class="comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="title function_">addSingletonFactory</span>(beanName, () -&gt; <span class="title function_">getEarlyBeanReference</span>(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span></span><br><span class="line">	<span class="title class_">Object</span> exposedObject = bean; </span><br><span class="line">	<span class="comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span></span><br><span class="line">	<span class="comment">// 因此此处会调用getBean(&quot;b&quot;)，so 会重复上面步骤创建B类的实例</span></span><br><span class="line">	<span class="comment">// 此处我们假设B已经创建好了 为B@5678</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 需要注意的是在populateBean(&quot;b&quot;)的时候依赖有beanA，所以此时候调用getBean(&quot;a&quot;)最终会调用getSingleton(&quot;a&quot;)，</span></span><br><span class="line">	<span class="comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span></span><br><span class="line">	</span><br><span class="line">	<span class="title function_">populateBean</span>(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span></span><br><span class="line">	<span class="comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span></span><br><span class="line">	<span class="comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span></span><br><span class="line">	exposedObject = <span class="title function_">initializeBean</span>(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span></span><br><span class="line">	<span class="comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span></span><br><span class="line">		<span class="comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span></span><br><span class="line">		<span class="comment">// 因此此处返回A的实例：A@1234</span></span><br><span class="line">		<span class="title class_">Object</span> earlySingletonReference = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span></span><br><span class="line">			<span class="comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span></span><br><span class="line">			<span class="comment">// 这种情况至此，就全部结束了~~~</span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span></span><br><span class="line">			<span class="comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是[&quot;b&quot;]这个依赖</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">allowRawInjectionDespiteWrapping</span> &amp;&amp; <span class="title function_">hasDependentBean</span>(beanName)) &#123;</span><br><span class="line">				<span class="title class_">String</span>[] dependentBeans = <span class="title function_">getDependentBeans</span>(beanName);</span><br><span class="line">				<span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// A@1234依赖的是[&quot;b&quot;]，所以此处去检查b</span></span><br><span class="line">				<span class="comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="title class_">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span></span><br><span class="line">					<span class="comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span></span><br><span class="line">					<span class="keyword">if</span> (!<span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.<span class="title function_">add</span>(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							<span class="title class_">StringUtils</span>.<span class="title function_">collectionToCommaDelimitedString</span>(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解： </p>
<p><img src="/2022/05/17/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="循环依赖流程图"></p>
<hr>
<p><strong>最后的最后，由于我太暖心了_，再来个纯文字版的总结。</strong> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p>
<ol>
<li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li>
<li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li>
<li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li>
<li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li>
<li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li>
<li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li>
<li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li>
<li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li>
<li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li>
<li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li>
</ol>
<p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p>
<hr>
<hr>
<hr>
<h3 id="2-4-循环依赖对AOP代理对象创建流程和结果的影响"><a href="#2-4-循环依赖对AOP代理对象创建流程和结果的影响" class="headerlink" title="2.4 循环依赖对AOP代理对象创建流程和结果的影响"></a>2.4 循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h3><p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p>
<p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span></span><br><span class="line">	<span class="comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span></span><br><span class="line">	<span class="comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span></span><br><span class="line">	<span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span></span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span></span><br><span class="line">	<span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span></span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环依赖校验（非常重要）~~~~</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span></span><br><span class="line">		<span class="comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span></span><br><span class="line">		<span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line">		<span class="comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span></span><br><span class="line">	<span class="comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span></span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span></span><br><span class="line">	<span class="comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环依赖校验</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span></span><br><span class="line">		<span class="comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span></span><br><span class="line">		<span class="comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;...</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀~~~）</p>
<p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Caused</span> <span class="attr">by</span>: org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">BeanCurrentlyInCreationException</span>: <span class="title class_">Error</span> creating bean <span class="keyword">with</span> name <span class="string">&#x27;a&#x27;</span>: <span class="title class_">Requested</span> bean is currently <span class="keyword">in</span> <span class="attr">creation</span>: <span class="title class_">Is</span> there an unresolvable circular reference?</span><br><span class="line">	at org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">support</span>.<span class="property">DefaultSingletonBeanRegistry</span>.<span class="title function_">beforeSingletonCreation</span>(<span class="title class_">DefaultSingletonBeanRegistry</span>.<span class="property">java</span>:<span class="number">339</span>)</span><br><span class="line">	at org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">support</span>.<span class="property">DefaultSingletonBeanRegistry</span>.<span class="title function_">getSingleton</span>(<span class="title class_">DefaultSingletonBeanRegistry</span>.<span class="property">java</span>:<span class="number">215</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别~~ 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置~ </p>
</blockquote>
<p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span></span><br><span class="line">	<span class="comment">// 但是：我们的此bean还是需要AOP代理的~~~</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private HelloService helloService;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样它的大致运行如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line">	<span class="comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	...</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		... 这里更不用说，因为earlySingletonExposure=<span class="literal">false</span>  所以上面的代理对象exposedObject 直接<span class="keyword">return</span>了~</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p>
<p>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</p>
<blockquote>
<p> <code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些 </p>
</blockquote>
<p>该抽象类实现了创建代理的动作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span></span><br><span class="line"><span class="comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span></span><br><span class="line">	<span class="comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">		<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">			<span class="comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span></span><br><span class="line">			<span class="comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span></span><br><span class="line">			<span class="comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p>
<p><strong><code>上面分析了三种case，现给出结论如下：</code></strong> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong></p>
<h2 id="3-Spring-MVC"><a href="#3-Spring-MVC" class="headerlink" title="3. Spring MVC"></a>3. Spring MVC</h2><p><img src="/2022/05/17/spring/springMVC" alt="img"></p>
<p><img src="/2022/05/17/spring/image-20210912190512831.png" alt="image-20210912190512831"></p>
<h2 id="4-java动态代理"><a href="#4-java动态代理" class="headerlink" title="4. java动态代理"></a>4. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/gonjan-blog/p/6685611.html">java动态代理</a></h2><p>关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式–代理模式，而对于代理，根据创建代理类的时间点，又可以分为静态代理和动态代理。</p>
<h3 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h3><p>  代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。在后面我会</p>
<p>解释这种间接性带来的好处。代理模式结构图（图片来自《大话设计模式》）：</p>
<p><img src="/2022/05/17/spring/1085268-20170409105440082-1652546649.jpg" alt="img">                             </p>
<h3 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h3><p>  <strong>1、静态代理</strong></p>
<p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p>
<p>  <strong>2、静态代理简单实现</strong></p>
<p> 根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，</p>
<p>班长就是学生的代理。</p>
<p>  首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Student类实现Person接口。Student可以具体实施上交班费的动作。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>下面测试一下，看如何使用代理模式：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentsProxy</span>(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//班长代理上交班费</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>运行结果：</p>
<p><img src="/2022/05/17/spring/1085268-20170409141805347-556037068.png" alt="img"></p>
<p>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p>
<p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>运行结果：</p>
<p><img src="/2022/05/17/spring/1085268-20170409143428488-1662654340.png" alt="img"></p>
<p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p>
<h3 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a><strong>三、动态代理</strong></h3><p>   <strong>1.动态代理</strong></p>
<p>  代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">       beforeMethod();</span><br><span class="line">       stu.giveMoney();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p>
<p>   <strong>2、动态代理简单实现</strong></p>
<p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p>
<p>创建一个动态代理对象步骤，具体代码见后面：</p>
<ul>
<li>创建一个InvocationHandler对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line"> <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;Person.class&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过构造器constructor来创建一个动态实例stuProxy</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person stuProxy = (Person) cons.newInstance(stuHandler);</span><br></pre></td></tr></table></figure>

<p>就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure>

<p>到这里肯定都会很疑惑，这动态代理到底是如何执行的，是如何通过代理对象来执行被代理对象的方法的，先不急，我们先看看一个简单的完整的动态代理的例子。还是上面静态代理的例子，班长需要帮学生代交班费。**<br>**首先是定义一个Person接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建需要被代理的实际类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">finishTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p>
<p>再再invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuInvocationHandler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StuInvocationHandler</span><span class="params">(T target)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StuInvocationHandler</span>&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">stuProxy</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。</p>
<p>运行结果：</p>
<p><img src="/2022/05/17/spring/1085268-20170409164136175-1515319571.png" alt="img"></p>
<p>上面说到，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p>
<p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p>
<h3 id="四、动态代理原理分析"><a href="#四、动态代理原理分析" class="headerlink" title="四、动态代理原理分析"></a><strong>四、动态代理原理分析</strong></h3><p>  <strong>1、Java动态代理创建出来的动态代理类</strong></p>
<p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，我们最应该关注的是 Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">&quot;$Proxy0&quot;</span>, Student.class.getInterfaces());</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;G:/javacode/javase/Test/bin/proxy/StuProxy.class&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path)) &#123;</span><br><span class="line">    fos.write(classFile);</span><br><span class="line">    fos.flush();</span><br><span class="line">    System.out.println(<span class="string">&quot;代理类class文件写入成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;写文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：\</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">  *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">  *Proxy构造方法：</span></span><br><span class="line"><span class="comment">  *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">  *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">  *         this.h = h;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;proxy.Person&quot;</span>).getMethod(<span class="string">&quot;giveMoney&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">  *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p>
<p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p>
<p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。<br>上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/17/springcloud/"><img class="prev-cover" src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">springCloud入门</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/17/JUC/"><img class="next-cover" src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">盖哥横扫千军</div><div class="author-info__description">啷里格啷</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spring-AOP"><span class="toc-number">1.</span> <span class="toc-text">1.Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%BD%BF%E7%94%A8AOP%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1使用AOP好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-AOP%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 AOP的术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Spring-AOP%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Spring AOP用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Advice%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Advice注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 使用总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">1.7 案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">1.8代理对象创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1-EnableAspectJAutoProxy"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.8.1@EnableAspectJAutoProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-2-AnnotationAwareAspectJAutoProxyCreator%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94AOP"><span class="toc-number">1.8.</span> <span class="toc-text">1.9 面试回答AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spring-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">2. Spring 三级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Spring-Bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Spring Bean的循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 流程总结（非常重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%AF%B9AOP%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 循环依赖对AOP代理对象创建流程和结果的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spring-MVC"><span class="toc-number">3.</span> <span class="toc-text">3. Spring MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">4. java动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">一、代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">二、静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">三、动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">四、动态代理原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.5.</span> <span class="toc-text">五、总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/alogrithm/" title="alogrithm"><img src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="alogrithm"/></a><div class="content"><a class="title" href="/2022/05/17/alogrithm/" title="alogrithm">alogrithm</a><time datetime="2022-05-17T02:07:08.000Z" title="发表于 2022-05-17 10:07:08">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/springcloud/" title="springCloud入门"><img src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="springCloud入门"/></a><div class="content"><a class="title" href="/2022/05/17/springcloud/" title="springCloud入门">springCloud入门</a><time datetime="2022-05-17T02:06:42.000Z" title="发表于 2022-05-17 10:06:42">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/spring/" title="spring"><img src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="spring"/></a><div class="content"><a class="title" href="/2022/05/17/spring/" title="spring">spring</a><time datetime="2022-05-17T02:06:42.000Z" title="发表于 2022-05-17 10:06:42">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/JUC/" title="JUC"><img src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC"/></a><div class="content"><a class="title" href="/2022/05/17/JUC/" title="JUC">JUC</a><time datetime="2022-05-17T02:06:21.000Z" title="发表于 2022-05-17 10:06:21">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/Tomcat/" title="Tomcat"><img src="/img/%E9%A3%8E%E8%8A%B1%E9%9B%AA%E6%9C%881.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tomcat"/></a><div class="content"><a class="title" href="/2022/05/17/Tomcat/" title="Tomcat">Tomcat</a><time datetime="2022-05-17T02:06:21.000Z" title="发表于 2022-05-17 10:06:21">2022-05-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 盖哥横扫千军</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel"><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，联通线路托管于Coding"><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>