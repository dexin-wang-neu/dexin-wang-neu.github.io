<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springCloud入门</title>
      <link href="/2022/05/24/springcloud/"/>
      <url>/2022/05/24/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总技术方案"><a href="#1-总技术方案" class="headerlink" title="1.总技术方案"></a>1.总技术方案</h1><p><img src="/2022/05/24/springcloud/%E6%80%BB%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.png" alt="image-20220522195129338"></p><h1 id="2-工程架构"><a href="#2-工程架构" class="headerlink" title="2.工程架构"></a>2.工程架构</h1><h2 id="2-1-版本选择"><a href="#2-1-版本选择" class="headerlink" title="2.1 版本选择"></a>2.1 版本选择</h2><p>spring cloud每个版本要求的spring boot版本如下：</p><table><thead><tr><th align="left">Cloud Vers</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td><td align="left">2.6.x</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td align="left">2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><p>通过访问 <a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a> 查看更详细的版本要求如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;spring-cloud&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Hoxton.SR12&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.2.0.RELEASE and &lt;2.4.0.M1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2020.0.5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.4.0.M1 and &lt;2.6.0-M1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2021.0.0-M1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.6.0-M1 and &lt;2.6.0-M3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2021.0.0-M3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.6.0-M3 and &lt;2.6.0-RC1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2021.0.0-RC1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.6.0-RC1 and &lt;2.6.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2021.0.2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.6.1 and &lt;2.6.9-SNAPSHOT&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2021.0.3-SNAPSHOT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=2.6.9-SNAPSHOT and &lt;3.0.0-M1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2022.0.0-M1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=3.0.0-M1 and &lt;3.0.0-M2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;2022.0.0-M2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring Boot &gt;=3.0.0-M2 and &lt;3.1.0-M1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="2-2-父工程"><a href="#2-2-父工程" class="headerlink" title="2.2 父工程"></a>2.2 父工程</h2><p>采用IDEA建立工程为父工程，在父工程下建立Module作为子工程，具体如下：</p><p><img src="/2022/05/24/springcloud/%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="image-20220522200737976"></p><p><strong>父工程的POM文件中引入的依赖如下</strong></p><p><img src="/2022/05/24/springcloud/image-20220522201915806.png" alt="image-20220522201915806"></p><p><img src="/2022/05/24/springcloud/image-20220522201952871.png" alt="image-20220522201952871"></p><blockquote><p> <strong>这样做的好处就是</strong>: 如果有多个子项目都引用同一样的依赖,则可以避免在每个使用的子项目里都声明一个版本号,这样想升级或切换到另一个版本时,只需在顶层父容器里更新,而不需要一个一个子项目的修改l;另外如果某个子项目需要另外的一个版本,只需声明version版本 </p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span><span class="comment">&lt;!--  表示pom父工程--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  统一管理jar包版本--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span><span class="comment">&lt;!--mysql驱动，不是数据库版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  子模块继承之后，提供作用：锁定版本+子module不用写groupId和version --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2、子项目可以继承父项目的 version 和 scope --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3、子项目若指定了 version 和 scope，以子项目为准 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      spring boot 2.2.2--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--  spring cloud Hoxton.SR1  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--  spring cloud alibaba 2.1.0.RELEASE    --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- druid--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- junit测试依赖，实际上引入了，这里为了篇幅，就先不写具体内容，下面类似--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并引入自动热部署maven插件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加maven插件 自动热部署  步骤2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当所有子工程建立后会在父工程POM文件里出现以下内容</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-provider-payment8001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-consumer-order80<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-eureka-server7001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-eureka-server7002<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-provider-payment8002<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-provider-payment8004<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-consumerzk-order80<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-providerconsul-payment8006<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-consumerconsul-order80<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-consumerfeign-order80<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-provider-hystri-payment8001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-consumer-feign-hystrix-order80<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-consumer-hystrix-dashboard9001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-gateway-gateway9527<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-config-center3344<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-config-client3355<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-config-client3366<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-stream-rabbitmq-provider8801<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-stream-rabbitmq-consumer8802<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloud-stream-rabbitmq-consumer8803<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloudalibaba-provider-payment9001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloudalibaba-provider-payment9002<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloudalibaba-consumer-nacos-order83<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloudalibaba-config-nacos-client3377<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>cloudalibaba-sentinel-service8401<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-官网"><a href="#2-3-官网" class="headerlink" title="2.3 官网"></a>2.3 官网</h2><p><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">spring cloud</a> </p><p><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes">spring boot</a></p><h2 id="2-4-工程通用类抽取"><a href="#2-4-工程通用类抽取" class="headerlink" title="2.4 工程通用类抽取"></a>2.4 工程通用类抽取</h2><p>问题描述：</p><blockquote><p>多个不同的服务之间可能会用到同样的类，如消费者服务和生产者服务都会用到<strong>Payment支付类和CommonResult通用封装类</strong></p></blockquote><p>解决方案：</p><p>通过<strong>cloud-api-common</strong>子模块，抽取公共类，其他模块引用该模块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//404 not_found</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String  message;</span><br><span class="line">    <span class="keyword">private</span> T       data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonResult</span><span class="params">(Integer code, String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(code,message,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------分隔--------------------------</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在该cloud-api-common 文件里如下</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当其他服务模块需要公共类时，在其POM文件里引用</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入自己定义的api通用包，对工程重构后抽取的类 引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-Eureka"><a href="#3-Eureka" class="headerlink" title="3.Eureka"></a>3.Eureka</h1><p><strong>Eureka 的使用只需要引入依赖jar包即可，不需要下载其他软件</strong></p><h2 id="3-1-服务治理、服务注册"><a href="#3-1-服务治理、服务注册" class="headerlink" title="3.1 服务治理、服务注册"></a>3.1 服务治理、服务注册</h2><p><img src="/2022/05/24/springcloud/image-20220522203015141.png" alt="image-20220522203015141"></p><p><img src="/2022/05/24/springcloud/image-20220522203057135.png" alt="image-20220522203057135"></p><p><img src="/2022/05/24/springcloud/image-20220522203118691.png" alt="image-20220522203118691"></p><p><img src="/2022/05/24/springcloud/image-20220522203225931.png" alt="image-20220522203225931"></p><h2 id="3-2-建立Eureka-server工程"><a href="#3-2-建立Eureka-server工程" class="headerlink" title="3.2 建立Eureka server工程"></a>3.2 建立Eureka server工程</h2><ul><li><p>建立Eureka server工程，作用是建立起Eureka server服务端注册中心：其工程要引入的部分主要依赖如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-eureka-server7001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 服务注册中心的服务端 eureka-server --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>需要在配置文件里指出Eureka注册中心地址及其他配置项</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span>    <span class="comment"># eureka服务端的实例名称</span></span><br><span class="line">  <span class="comment">#    hostname: localhost # eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># false 表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>       <span class="comment"># false 表示自己端就是注册中心，我的职责是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="comment">#      defaultZone: http://eureka7002.com:7002/eureka/   # 集群 相互注册</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span>   <span class="comment"># 关闭自我保护机制，保证不可用服务被即使剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure></li><li><p>最后在主启动类标注   <strong>@EnableEurekaServer</strong>注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaMain7001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终在yaml里配置的端口进行查看注册进其里的服务：</p><p><img src="/2022/05/24/springcloud/Eureka%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2.png" alt="Eureka"></p></li></ul><h2 id="3-2-将服务注册进Eureka"><a href="#3-2-将服务注册进Eureka" class="headerlink" title="3.2 将服务注册进Eureka"></a>3.2 将服务注册进Eureka</h2><h3 id="3-2-1-建立一个消费者服务"><a href="#3-2-1-建立一个消费者服务" class="headerlink" title="3.2.1 建立一个消费者服务"></a>3.2.1 建立一个消费者服务</h3><p><strong>cloud-consumer-order80</strong></p><ul><li><p>需要引入的主要依赖：<strong>spring-cloud-starter-netflix-eureka-client</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 服务注册中心的客户端端 eureka-client --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 下面的ribbon可以不加，因为上面eureka-client中已经自带了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，对工程重构后抽取的类 引入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--包含了sleuth+zipkin--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件指定要注册到Eureka的地址</p><p>单机版只写一个地址，集群版写多个</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span>  <span class="comment"># 表示是否将自己注册进EurekaServer默认true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均很</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka  # 单机版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span>  <span class="comment">#集群版</span></span><br></pre></td></tr></table></figure></li><li><p>在主启动类标注  <strong>@EnableEurekaClient</strong> 注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)  //声明在该微服务启动的时候就去加载自定义的Ribbon配置类，从而使配置生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-2-建立一个生产者服务"><a href="#3-2-2-建立一个生产者服务" class="headerlink" title="3.2.2 建立一个生产者服务"></a>3.2.2 建立一个生产者服务</h3><p><strong>cloud-provider-payment8001</strong> ,该服务要查询数据库，所以引入了数据库的依赖</p><ul><li><p>pom</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-payment8001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  自动热部署  步骤1 ，步骤2在父工程pom里--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，对工程重构后抽取的类 引入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   使用eureka客户端注册服务到eureka服务端     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-metrics-event-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>yaml配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.gjt.mm.mysql.Driver</span>    <span class="comment"># MySQL驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 开启热部署</span></span><br><span class="line">      <span class="attr">additional-paths:</span> <span class="string">src/main/java</span>   <span class="comment">#重启目录</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">templates/**</span>   <span class="comment"># 类路径下的templates文件夹内容修改不重启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.springcloud.entities</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span>  <span class="comment"># 表示是否将自己注册进EurekaServer默认true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均很</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span>  <span class="comment">#集群版</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 在注册里显示服务的ip</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span>  <span class="comment"># Eureka客户端向服务端发送心跳的时间间隔，单位为秒（默认为30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span> <span class="comment"># Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒（默认是90秒），超时将剔除服务</span></span><br></pre></td></tr></table></figure></li><li><p>主配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>      <span class="comment">//服务发现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">        log.info(<span class="string">&quot;Payment8001 启动成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-3-服务注册完成"><a href="#3-3-3-服务注册完成" class="headerlink" title="3.3.3 服务注册完成"></a>3.3.3 服务注册完成</h3><p><img src="/2022/05/24/springcloud/%E6%B3%A8%E5%86%8C%E8%BF%9BEureka%E7%9A%84%E6%9C%8D%E5%8A%A1.png" alt="注册进Eureka的服务"></p><p>服务注册名配置说明：</p><p><img src="/2022/05/24/springcloud/image-20220522211126050.png" alt="image-20220522211126050"></p><p>自我保护机制：</p><p><img src="/2022/05/24/springcloud/image-20220522211232832.png" alt="image-20220522211232832"></p><h2 id="3-3-集群Eureka配置"><a href="#3-3-集群Eureka配置" class="headerlink" title="3.3 集群Eureka配置"></a>3.3 集群Eureka配置</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p><img src="/2022/05/24/springcloud/image-20220522211342974.png" alt="image-20220522211342974"></p><blockquote><p> <strong>解决办法: 搭建Eureka注册中心集群,实现负载均衡+故障容错</strong></p></blockquote><h3 id="3-3-2-配置"><a href="#3-3-2-配置" class="headerlink" title="3.3.2 配置"></a>3.3.2 配置</h3><p>其实已经在3.2里的文件里有了</p><p><strong>7001</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-eureka-service</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># eureka服务端的实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>7002</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-eureka-service</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># eureka服务端的实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-启动方式"><a href="#3-3-3-启动方式" class="headerlink" title="3.3.3 启动方式"></a>3.3.3 启动方式</h3><p><img src="/2022/05/24/springcloud/image-20220522211730704.png" alt="image-20220522211730704"></p><p><img src="/2022/05/24/springcloud/image-20220522211744143.png" alt="image-20220522211744143"></p><p><img src="/2022/05/24/springcloud/image-20220522211802603.png" alt="image-20220522211802603"></p><p><strong>相互注册，相互守望</strong></p><p><img src="/2022/05/24/springcloud/image-20220522211852193.png" alt="image-20220522211852193"></p><p><img src="/2022/05/24/springcloud/%5Cimage-20220522211904479.png" alt="image-20220522211904479"></p><h2 id="3-4-服务集群"><a href="#3-4-服务集群" class="headerlink" title="3.4 服务集群"></a>3.4 服务集群</h2><p>按照3.2的方式，配置多个生产者服务，这里 新建 <strong>cloud-provider-payment8002</strong>服务，与<strong>cloud-provider-payment8001</strong>仅有配置文件的区别和controller的区别</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.gjt.mm.mysql.Driver</span>    <span class="comment"># MySQL驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 开启热部署</span></span><br><span class="line">      <span class="attr">additional-paths:</span> <span class="string">src/main/java</span>   <span class="comment">#重启目录</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">templates/**</span>   <span class="comment"># 类路径下的templates文件夹内容修改不重启</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.springcloud.entities</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span>  <span class="comment"># 表示是否将自己注册进EurekaServer默认true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均很</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span>  <span class="comment">#集群版</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span>    <span class="comment"># 在注册里显示服务的实例名称，配置里以后eureka监控页面里显示的就是他了，而不是含有主机名加应用名的了</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 在注册里显示服务的ip</span></span><br></pre></td></tr></table></figure><p>以下是cloud-provider-payment8001 的controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">//import org.springframework.cloud.client.discovery.DiscoveryClient;</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;    <span class="comment">//对于注册进eureka里的微服务，可以通过服务发现来获取该服务的信息</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;***插入结果：&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;插入数据库成功,serverPort:&quot;</span>+serverPort,result);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,<span class="string">&quot;插入数据库失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">&quot;***查询结果：,哈哈&quot;</span>+<span class="string">&quot;O(∩_∩)O&quot;</span>+payment);</span><br><span class="line">        <span class="keyword">if</span> (payment != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;查询成功,serverPort:&quot;</span>+serverPort,payment);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,<span class="string">&quot;没有对应记录，失败，查询ID:&quot;</span>+id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/lb&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPaymentLB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/discovery&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">discovery</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">            log.info((<span class="string">&quot;*****element:&quot;</span>+service));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">            log.info(instance.getInstanceId()+<span class="string">&quot;\t&quot;</span>+instance.getHost()+</span><br><span class="line">                                 <span class="string">&quot;\t&quot;</span>+instance.getPort()+<span class="string">&quot;\t&quot;</span>+instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟超时，测试openFeign的超时机制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> cloud-provider-payment8002 的controller与cloud-provider-payment8001的一摸一样，唯一的区别是在请求”&#x2F;payment&#x2F;lb”接口时，去到的配置文件中的serverPost为8002</p></blockquote><h2 id="3-5-负载均衡"><a href="#3-5-负载均衡" class="headerlink" title="3.5 负载均衡"></a>3.5 负载均衡</h2><p>使用目的：</p><ul><li>消费者服务<strong>cloud-consumer-order80</strong>调用生产者服务的接口(这里生产者为：cloud-provider-payment8001和 cloud-provider-payment8002)</li><li>也就是在消费者配置文件里的 <strong>cloud-order-service</strong> 服务，调用<strong>cloud-payment-service</strong></li></ul><p>使用步骤：</p><ul><li><p>配置<strong>RestTemplate</strong>,使用**@LoadBalanced**</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RestTemplate是spring提供的远程调用其他http服务接口的工具，是httpClient的封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span>   <span class="comment">//负载均衡机制，不加的话就不知道去找哪个服务，就会报错</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在cloud-consumer-order80的contrller里使用<strong>RestTemplate</strong>，调用<strong>cloud-payment-service</strong>的接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span></span><br><span class="line">    <span class="comment">// 通过在eureka上注册过的微服务名称调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;        <span class="comment">//负载均衡</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">create</span><span class="params">(Payment payment)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">&quot;/payment/create&quot;</span>,payment,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span>  CommonResult&lt;Payment&gt; <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPayment2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + <span class="string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);</span><br><span class="line">        <span class="keyword">if</span> (entity.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">            log.info(entity.getStatusCode()+<span class="string">&quot;\t&quot;</span>+entity.getHeaders());</span><br><span class="line">            <span class="keyword">return</span> entity.getBody();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用效果</p><ul><li>8001&#x2F;8002端口交替出现</li></ul></li></ul><blockquote><p> Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号,且该服务还有负载功能了.</p></blockquote><p>   ![屏幕截图 2022-05-22 214530.png](images&#x2F;屏幕截图 2022-05-22 214530.png)</p><h2 id="3-6-服务发现"><a href="#3-6-服务发现" class="headerlink" title="3.6 服务发现"></a>3.6 服务发现</h2><ul><li>对于注册eureka里面的微服务,可以通过服务发现来获得该服务的信息</li></ul><p><img src="/2022/05/24/springcloud/image-20220522214819914.png" alt="image-20220522214819914"></p><ul><li>8001的启动类<strong>@EnableDiscoveryClient</strong></li></ul><h2 id="3-7-Eureka自我保护"><a href="#3-7-Eureka自我保护" class="headerlink" title="3.7 Eureka自我保护"></a>3.7 Eureka自我保护</h2><p><img src="/2022/05/24/springcloud/image-20220522215148625.png" alt="image-20220522215148625"></p><p><strong>导致原因</strong>：某时刻 一个微服务不可用了,Eureka不会立刻清理,依旧会对该服务的信息进行保存  <strong>属于CAP里面的AP分支</strong></p><p><strong>怎么禁止自我保护：</strong></p><ul><li><p>注册中心eurekaServer端7001</p><ul><li>&#96;&#96;&#96;yaml<br>&#x2F;&#x2F;默认,自我保护机制是开启的<br>eureka.server.enable-self-preservation&#x3D;true<br>&#x2F;&#x2F;eureka.server.enable-self-preservation&#x3D;false 使用可以禁用自我保护模式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 生产者客户端eurekaClient端8001</span><br><span class="line"></span><br><span class="line">  * ```YAML</span><br><span class="line">    # Eureka客户端向服务端发送心跳的时间间隔，单位为秒（默认为30秒）</span><br><span class="line">    eureka.instance.lease-renewal-interval-in-seconds=1    //单位为秒(默认是30秒)</span><br><span class="line">    </span><br><span class="line">    # Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒（默认是90秒），超时将剔除服务</span><br><span class="line">    eureka.instance.lease-expiration-duration-in-seconds=2 //单位为秒(默认是90秒)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试效果</p><ul><li>先启动7001注册中心，再启动8001服务；先关闭8001，8001马上在注册中心中被删除</li></ul></li></ul><h1 id="4-Zookeeper"><a href="#4-Zookeeper" class="headerlink" title="4. Zookeeper"></a>4. Zookeeper</h1><blockquote><p>SpringCloud整合Zookeeper替代Eureka</p></blockquote><p>Zookeeper是一个分布式协调工具,可以实现注册中心功能，需要事先下载Zookeeper软件。</p><h2 id="4-1使用方式"><a href="#4-1使用方式" class="headerlink" title="4.1使用方式"></a>4.1使用方式</h2><h3 id="4-1-1-服务提供者"><a href="#4-1-1-服务提供者" class="headerlink" title="4.1.1 服务提供者"></a>4.1.1 服务提供者</h3><ul><li><strong>新建cloud-provider-payment8004</strong></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-payment8004<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;scope&gt;runtime&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;optional&gt;true&lt;/optional&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>YAML配置</strong></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">dexin.com:2181</span></span><br></pre></td></tr></table></figure><ul><li><strong>主启动类</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8004</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8004.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>controller</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentzk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with zookeeper: &quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>启动8004注册进zookeeper</strong></p><ul><li><p>启动zk  :    zkServer.sh start</p></li><li><p>启动后有问题</p><p><img src="/2022/05/24/springcloud/image-20220522220737527.png" alt="image-20220522220737527"></p></li><li><p>解决zookeeper版本jar包冲突问题</p><p><img src="/2022/05/24/springcloud/image-20220522220828921.png" alt="image-20220522220828921"></p></li><li><p>排除zk冲突后的新POM</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot整合Zookeeper客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注册进Zookeeper验证</p><p><img src="/2022/05/24/springcloud/image-20220522221055489.png" alt="image-20220522221055489"></p></li><li><p>验证测试</p><p><img src="/2022/05/24/springcloud/image-20220522221139182.png" alt="image-20220522221139182"></p></li><li><blockquote><p><strong>服务节点是临时节点</strong></p></blockquote></li></ul><h3 id="4-1-2-服务消费者"><a href="#4-1-2-服务消费者" class="headerlink" title="4.1.2 服务消费者"></a>4.1.2 服务消费者</h3><ul><li><p>新建<strong>cloud-consumerzk-order80</strong></p></li><li><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumerzk-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;scope&gt;runtime&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;optional&gt;true&lt;/optional&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>YAML</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">dexin.com:2181</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderZKMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderZKMain80.class,args);</span><br><span class="line">        log.info(<span class="string">&quot;ConsumerZK80 启动成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getResTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderZKController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INVOKE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/zk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(INVOKE_URL + <span class="string">&quot;/payment/zk&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册进ZOOKEEPER测试</p><p><img src="/2022/05/24/springcloud/image-20220522221647579.png" alt="image-20220522221647579"></p></li><li><p>访问测试地址验证服务调用成功：<a href="http://localhost/consumer/payment/zk">http://localhost/consumer/payment/zk</a></p></li></ul><h1 id="5-Consul"><a href="#5-Consul" class="headerlink" title="5. Consul"></a>5. Consul</h1><h2 id="5-1-Consul简介"><a href="#5-1-Consul简介" class="headerlink" title="5.1 Consul简介"></a>5.1 Consul简介</h2><p><a href="https://www.consul.io/intro/index.html">Consul官网</a></p><p>Consul 是一个服务网格解决方案，提供具有服务发现、配置和分段功能的全功能控制平面。这些功能中的每一个都可以根据需要单独使用，也可以一起使用来构建完整的服务网格。Consul 需要数据平面并支持代理和原生集成模型。Consul 附带一个简单的内置代理，因此一切都可以开箱即用，而且还支持 Envoy 等 3rd 方代理集成。</p><p>Consul 的主要特点是：</p><ul><li><strong>服务发现</strong>：Consul 的客户端可以注册服务，例如 <code>api</code>or <code>mysql</code>，其他客户端可以使用 Consul 发现给定服务的提供者。使用 DNS 或 HTTP，应用程序可以轻松找到它们所依赖的服务。</li><li><strong>健康检查</strong>：Consul 客户端可以提供任意数量的健康检查，或者与给定服务相关联（“网络服务器是否返回 200 OK”），或者与本地节点相关联（“内存利用率是否低于 90%”）。操作员可以使用此信息来监控集群的健康状况，服务发现组件使用它来将流量从不健康的主机中路由出去。</li><li><strong>KV 存储</strong>：应用程序可以将 Consul 的分层键&#x2F;值存储用于任意数量的目的，包括动态配置、特征标记、协调、领导者选举等。简单的 HTTP API 使其易于使用。</li><li><strong>安全服务通信</strong>：Consul 可以为服务生成和分发 TLS 证书以建立相互 TLS 连接。 <a href="https://www.consul.io/docs/connect/intentions">意图</a> 可用于定义允许通信的服务。可以通过可以实时更改的意图轻松管理服务分段，而不是使用复杂的网络拓扑和静态防火墙规则。</li><li><strong>多数据中心</strong>：Consul 支持开箱即用的多个数据中心。这意味着 Consul 的用户不必担心构建额外的抽象层以扩展到多个区域。</li></ul><blockquote><p>Consul 需要下载该软件包  下载地址 ： <a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a></p></blockquote><blockquote><p>Consul 的使用：<a href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></p></blockquote><h2 id="5-2-安装运行"><a href="#5-2-安装运行" class="headerlink" title="5.2 安装运行"></a>5.2 安装运行</h2><p><img src="/2022/05/24/springcloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220524091507.png" alt="微信截图_20220524091507.png"></p><p>浏览器中输入 localhost:8500</p><p><img src="/2022/05/24/springcloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220524091704.png" alt="微信截图_20220524091704.png"></p><h2 id="5-3-将服务注册进Consul"><a href="#5-3-将服务注册进Consul" class="headerlink" title="5.3 将服务注册进Consul"></a>5.3 将服务注册进Consul</h2><h3 id="5-3-1-建立一个服务提供者"><a href="#5-3-1-建立一个服务提供者" class="headerlink" title="5.3.1 建立一个服务提供者"></a>5.3.1 建立一个服务提供者</h3><blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cloud-providerconsul-payment8006</span><br></pre></td></tr></table></figure><p>服务模块</p></blockquote><ul><li><p>POM依赖：引入了<strong>spring-cloud-starter-consul-discovery</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-providerconsul-payment8006<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件YML</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-provider-payment</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8006</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8006.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentConsulController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentConsul</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with consul: &quot;</span>+ serverPort +<span class="string">&quot;\t&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-2-建立一个服务消费者"><a href="#5-3-2-建立一个服务消费者" class="headerlink" title="5.3.2 建立一个服务消费者"></a>5.3.2 建立一个服务消费者</h3><p>服务模块：<strong>cloud-consumerconsul-order80</strong></p><ul><li><p>依赖文件POM ，同样引入<strong>spring-cloud-starter-consul-discovery</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumerconsul-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件YML</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsulMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderConsulMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置类，为了调用服务提供者的接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类 ， 通过服务提供者的<strong>服务名称</strong>，加服务提供者接口<strong>URI</strong>调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsulController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INVOKE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://consul-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/consul&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(INVOKE_URL + <span class="string">&quot;/payment/consul&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-4-三个注册中心的异同"><a href="#5-4-三个注册中心的异同" class="headerlink" title="5.4 三个注册中心的异同"></a>5.4 三个注册中心的异同</h2><blockquote><p>CAP</p></blockquote><p><img src="/2022/05/24/springcloud/image-20220524102639467.png" alt="image-20220524102639467"></p><p><img src="/2022/05/24/springcloud/image-20220524102654789.png" alt="image-20220524102654789"></p><blockquote><p>AP : Eureka</p></blockquote><p><img src="/2022/05/24/springcloud/image-20220524102806946.png" alt="image-20220524102806946"></p><blockquote><p>CP: Zookeeper&#x2F;Consul</p></blockquote><p>CP架构<br>当网络分区出现后,为了保证一致性,就必须拒绝请求,否则无法保证一致性<br>结论:违背了可用性A的要求,只满足一致性和分区容错,即CP</p><p><img src="/2022/05/24/springcloud/%E5%9B%BE%E5%83%8F.png" alt="图像.png"></p><h1 id="6-Ribbon-负载均衡"><a href="#6-Ribbon-负载均衡" class="headerlink" title="6.Ribbon 负载均衡"></a>6.Ribbon 负载均衡</h1><h2 id="6-1-Ribbon概述"><a href="#6-1-Ribbon概述" class="headerlink" title="6.1 Ribbon概述"></a>6.1 Ribbon概述</h2><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。<br>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><p>使用方法：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">https://github.com/Netflix/ribbon/wiki/Getting-Started</a></p><p><img src="/2022/05/24/springcloud/image-20220524110541514.png" alt="image-20220524110541514"></p><p>Ribbon在工作时分成两步<br>第—步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server.</p><p>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略:比如轮询、随机和根据响应时间加权。</p><p><strong>在之前调用的时候，没有引入以下依赖，也可以使用Ribbon</strong>，因为Eureka已经整合了Ribbon</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactld</span>&gt;</span></span><br><span class="line">    spring-cloud-starter-netflix-ribbon</span><br><span class="line">    <span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/05/24/springcloud/image-20220524111237623.png" alt="image-20220524111237623"></p><h2 id="6-2-RestTemplate的使用"><a href="#6-2-RestTemplate的使用" class="headerlink" title="6.2 RestTemplate的使用"></a>6.2 RestTemplate的使用</h2><p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate官网</a></p><p><img src="/2022/05/24/springcloud/image-20220524111716073.png" alt="image-20220524111716073"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回对象为响应体中数据转化成的对象，基本上可以理解为Json</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> commonResult&lt;Payment&gt; <span class="title function_">getPayment</span><span class="params">(<span class="meta">@Pathvariable(&quot;id&quot;)</span> Long id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForobjectk(PAYMENT_SRV+<span class="string">&quot;/payment/get/&quot;</span>+id,commonResult.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等@GetMapping(&quot;/consumer/ payment/getForEntity/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> commonResult&lt;Payment&gt; <span class="title function_">getPayment2</span><span class="params">(<span class="meta">@Pathvariable(&quot;id&quot;)</span> Long id)</span></span><br><span class="line">&#123;</span><br><span class="line">    ResponseEntity&lt;commonResult&gt; entity = restTemplate.getForEntity(PAYMENT_SRV+<span class="string">&quot; / payment/get/&quot;</span>+id，commonResult.clas);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(entity-getstatuscode( ).is2xxSuccessful())&#123;</span><br><span class="line"><span class="keyword">return</span> entity.getBody();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>( code: <span class="number">444</span>，message:<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3-Ribbon核心组件IRule"><a href="#6-3-Ribbon核心组件IRule" class="headerlink" title="6.3 Ribbon核心组件IRule"></a>6.3 Ribbon核心组件IRule</h2><p>IRule根据特定的算法从服务列表中选取以恶搞要访问的服务：</p><p><img src="/2022/05/24/springcloud/image-20220524112426622.png" alt="image-20220524112426622"></p><ul><li><strong>com.netflix.loadbalancer.RoundRobinRule</strong>  ： 轮询</li><li><strong>com.netflix.loadbalancer.RandomRule</strong> ： 随机</li><li><strong>com.netflix.loadbalancer.RetryRule</strong> ：先按照RoundRobinRule的策略获取服务,如果获取服务失败则在指定时间内进行重试,获取可用的服务</li><li><strong>WeightedResponseTimeRule</strong> ： 对RoundRobinRule的扩展,响应速度越快的实例选择权重越多大,越容易被选择</li><li><strong>BestAvailableRule</strong> : 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务,然后选择一个并发量最小的服务</li><li><strong>AvailabilityFilteringRule</strong> : 先过滤掉故障实例,再选择并发较小的实例</li><li><strong>ZoneAvoidanceRule</strong>:  默认规则,复合判断server所在区域的性能和server的可用性选择服务器</li></ul><p>默认的是轮询方式实现负载均衡，可以指定负载均衡的其他算法</p><ul><li><p>新建自定义Rule类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：新定义的负载均衡类，不能放到与主函数相同的包下（因为不能被ComponentScan扫描到，否则就会被所有的ribbon共享），所以新建了一个myrule包。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();<span class="comment">//定义为随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/05/24/springcloud/image-20220524181030048.png" alt="image-20220524181030048"></p></li><li><p>在主启动类上加 <strong>@RibbonClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)</span>  <span class="comment">//声明在该微服务启动的时候就去加载自定义的Ribbon配置类，从而使配置生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-4-自定义负载均衡算法"><a href="#6-4-自定义负载均衡算法" class="headerlink" title="6.4 自定义负载均衡算法"></a>6.4 自定义负载均衡算法</h2><p><img src="/2022/05/24/springcloud/image-20220524181712336.png" alt="image-20220524181712336"></p><ul><li><p>ApplicationContextBean去掉注解@LoadBalanced，这样如果后面能够实现接口的负载均衡调用，那么就是自定义的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RestTemplate是spring提供的远程调用其他http服务接口的工具，是httpClient的封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//    @LoadBalanced   //负载均衡机制，不加的话就不知道去找哪个服务，就会报错</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>新建<strong>LoadBalancer</strong>接口，和实现类.<strong>MyLB</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的负载均衡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注册的提供服务的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceInstances</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ServiceInstance <span class="title function_">instance</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLB</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="type">int</span> next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = <span class="built_in">this</span>.atomicInteger.get();</span><br><span class="line">            next = current &gt;= Integer.MAX_VALUE ? <span class="number">0</span>: current+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">while</span> (!<span class="built_in">this</span>.atomicInteger.compareAndSet(current,next));</span><br><span class="line">        System.out.println(<span class="string">&quot;******第几次访问次数，next:&quot;</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInstance <span class="title function_">instance</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getAndIncrement() % serviceInstances.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层里调用自定义的<strong>LoadBalancer</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自己写的负载均衡类，实现服务的轮询调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/lb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPaymentLB</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (instances == <span class="literal">null</span> || instances.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancer.instance(instances);</span><br><span class="line">    <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> serviceInstance.getUri();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(uri+<span class="string">&quot;/payment/lb&quot;</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="7-OpenFeign-服务接口调用"><a href="#7-OpenFeign-服务接口调用" class="headerlink" title="7.OpenFeign 服务接口调用"></a>7.OpenFeign 服务接口调用</h1><h1 id="8-Hystrix-服务熔断器"><a href="#8-Hystrix-服务熔断器" class="headerlink" title="8.Hystrix 服务熔断器"></a>8.Hystrix 服务熔断器</h1><h1 id="9-zuul-路由网关"><a href="#9-zuul-路由网关" class="headerlink" title="9.zuul 路由网关"></a>9.zuul 路由网关</h1><h1 id="10-Gateway-网关"><a href="#10-Gateway-网关" class="headerlink" title="10.Gateway 网关"></a>10.Gateway 网关</h1>]]></content>
      
      
      <categories>
          
          <category> springCloud </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>alogrithm</title>
      <link href="/2022/05/17/alogrithm/"/>
      <url>/2022/05/17/alogrithm/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>思路</p></blockquote><p>快速排序的主要思想：通过划分将待排序的数组分成两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的数组序列分别进行快速排序。</p><ol><li>选择主元</li><li>维护两个指针  <strong>&#x3D;&#x3D;i  ,  j&#x3D;&#x3D;</strong> ,指针  <strong>j</strong>  从  <strong>l</strong>  至  <strong>r</strong>  遍历，指针  <strong>i</strong>  维护比主元小的数；<ol><li>初始  <strong>i &#x3D; l-1 ,  j &#x3D; l</strong>  ,</li><li>当 **arr[j] &lt;&#x3D; pivot  <strong>时，说明当前遍历到的这个数应该在右边部分，所以，将</strong>arr[j]  <strong>与</strong>arr[i + 1]  <strong>交换，之后</strong>i + + **，使指针  <strong>i</strong>   维护的是比  <strong>pivot</strong>  小的最靠右的数。</li></ol></li><li>递归遍历  <strong>pivot</strong> 左边的</li><li>递归遍历  <strong>pivot</strong> 右边的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        randomQuickSort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomQuickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> randomPartition(nums,l,r);<span class="comment">//快排，返回主元的位置</span></span><br><span class="line">            randomQuickSort(nums,l,pos-<span class="number">1</span>);<span class="comment">//左递归</span></span><br><span class="line">            randomQuickSort(nums,pos+<span class="number">1</span>,r);<span class="comment">//右递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(r - l + <span class="number">1</span>) + l;<span class="comment">//随机选择主元</span></span><br><span class="line">        swap(nums,r,i);<span class="comment">//把主元移到数组末尾</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);<span class="comment">//开始交换排序(返回主元最后的位置)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[r];<span class="comment">//主元的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>;<span class="comment">//比主元小的数最右边的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= r - <span class="number">1</span>;j++)&#123;<span class="comment">//j遍历所有数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;<span class="comment">//当前值比主元小，应该将其移动到左边去</span></span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums,i,j);<span class="comment">//移动交换（此时i+1的位置是比主元大的数）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,i+<span class="number">1</span>,r);<span class="comment">//最后将主元放到“中间”位置上</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//返回主元所在位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路</p></blockquote><p>归并排序利用了分治的思想来对序列进行排序。对于一个长度为 <strong>n</strong> 的序列，将其分解为两个长度为<strong>n&#x2F;2</strong>   的子序列，然后再递归分解子序列，直至不能再分，然后线性合并两个有序的子序列。</p><ol><li>划分左右子序列  <strong>[ l , mid]   [mid + 1，r ]</strong></li><li>左递归 <strong>[ l , mid]</strong></li><li>右递归 <strong>[mid + 1，r ]</strong></li><li>线性合并<ol><li>维护两个指针<strong>i，j</strong>，<strong>i</strong>遍历左&#x3D;&#x3D;有序&#x3D;&#x3D;子序列，<strong>j</strong>  遍历右&#x3D;&#x3D;有序&#x3D;&#x3D;子序列，维护临时数组<strong>temp</strong></li><li>如果 <strong>nums[ i ]  &lt;&#x3D;  nums[ j ]</strong>  ，&#x3D;&#x3D;temp[cnt++] &#x3D; nums[ i ]&#x3D;&#x3D;</li><li>否则：&#x3D;&#x3D;temp[cnt++] &#x3D; nums[ j ]&#x3D;&#x3D;</li><li>如果左&#x2F;右子序列有剩余元素，将剩余元素都追加给temp</li><li>左右子序列都遍历完，将&#x3D;&#x3D;temp&#x3D;&#x3D;赋值给&#x3D;&#x3D;nums&#x3D;&#x3D;</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] temp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//取中点为分界</span></span><br><span class="line">        mergeSort(nums,l,mid);<span class="comment">//左递归</span></span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);<span class="comment">//右递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归结束后，开始线性合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">temp[cnt++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比较完还有剩余</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">            temp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将temp赋值给nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; r - l + <span class="number">1</span>;k ++)&#123;</span><br><span class="line">nums[l + k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>思路</p></blockquote><p>将待排序的序列构建成一个大顶堆，堆顶的元素为最大值，将堆定的元素与堆的最后一个元素交换（最大值就到了堆的最后一个位置上），将最大值元素从堆中移除，重新调整堆的结构，使大顶堆结构不变。重复操作，直至堆中没有元素，那么就从小到大堆序列进行了排序。</p><blockquote><p>堆（Heap）</p></blockquote><p><strong>定义</strong></p><ul><li>堆就是用<strong>数组</strong>实现的二叉树；</li><li>堆是一种<strong>完全二叉树</strong></li><li>有多种具体实现：大顶堆、小顶堆<ul><li><strong>大</strong>顶堆：父节点的值<strong>大于</strong>左&#x2F;右子节点的值</li><li><strong>小</strong>顶堆：父节点的值<strong>小于</strong>左&#x2F;右子节点的值</li></ul></li></ul><blockquote><p>堆排序步骤</p></blockquote><ul><li>构建一个大顶堆<ul><li>从倒数第二层二叉树（最后一个非叶子节点），递归往上进行堆的构建（父子节点的大小判断和移动）</li></ul></li><li>将堆顶元素（最大值）和堆的最后一个元素交换</li><li>移除最后一个元素，调整大顶堆的结构使仍满足大顶堆定义</li><li>重复交换堆顶元素和堆的最后一个元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        buildHeap(nums,nums.length);<span class="comment">//创建一个堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">            swap(nums,i,<span class="number">0</span>);<span class="comment">//将最大值移动到堆的最后一个位置</span></span><br><span class="line">            heapify(nums,i,<span class="number">0</span>);<span class="comment">//调整结构满足大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastNode</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">//堆的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (lastNode - <span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//最后一个非叶子节点，需要heapify的第一个父节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parent;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">heapify(nums,n,i);<span class="comment">// 调整父子节点的大小关系（调整结构）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调整为大顶堆结构</span></span><br><span class="line"><span class="comment">    @params nums:数组（堆）</span></span><br><span class="line"><span class="comment">    @params n : 堆的大小</span></span><br><span class="line"><span class="comment">    @params i : 调整的父节点位置索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> n,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child_1</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//左子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child_2</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;<span class="comment">//右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(child_1 &lt; n &amp;&amp; nums[child_1] &gt; nums[max])&#123; <span class="comment">//确定三个节点中的最大值</span></span><br><span class="line">max = child_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child_2 &lt; n &amp;&amp; nums[child_2] &gt; nums[max])&#123;<span class="comment">//确定三个节点中的最大值</span></span><br><span class="line">            max = child_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != i)&#123;</span><br><span class="line">            swap(nums,max,i);<span class="comment">//交换使堆顶为最大值</span></span><br><span class="line">            heapify(nums,n,max);<span class="comment">//交换完之后再次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路</p></blockquote><ol><li>选择 nums[0] - nums[n - 1]中的最小值，与nums[0]交换</li><li>选择 nums[1] - nums[n - 1]中的最小值，与nums[1]交换</li><li>选择 nums[2] - nums[n - 1]中的最小值，与nums[2]交换</li><li>重复操作</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">selectSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minIndex])&#123;</span><br><span class="line">minIndex = j;</span><br><span class="line">                    swap(nums,j,minIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路</p></blockquote><p>把n个待排序的数看作一个有序表和一个无序表，开始时，有序表只包含一个元素（nums[0]），无序表包含n - 1个元素，排序过程中每次从无序表中取出第一个元素，把他与有序表元素依次比较，插入到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">insertValue = nums[i];</span><br><span class="line">            insertIndex = i;</span><br><span class="line">            <span class="keyword">while</span>(insertIndex &gt; <span class="number">0</span> &amp;&amp; nums[insertIndex - <span class="number">1</span>] &gt; insertValue)&#123;</span><br><span class="line">                nums[insertIndex] = nums[insertIndex - <span class="number">1</span>];</span><br><span class="line">                insertIndex --;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[insertIndex] = insertValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;：当需要插入的数较小时，后移的次数多。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思路</p></blockquote><p>分组进行插入排序：</p><ul><li>将  <strong>n</strong>  个待排序序列分成 <strong>gap</strong> （ <strong>n&#x2F;2</strong> ） 组 ，每组之间前一个数和后一个数的间隔  <strong>gap &#x3D; n &#x2F; 2</strong>  <ul><li>对所有分组进行插入排序</li></ul></li><li><strong>gap  &#x3D; gap &#x2F; 2</strong>  重复进行插入排序，直至  <strong>gap  &#x3D; 0</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        shellSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;gap &gt; <span class="number">0</span>; gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//下面是正常的插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap;i &lt; n;i ++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span>(insertIndex &gt; <span class="number">0</span> &amp;&amp; nums[insertIndex - gap] &gt; insertValue)&#123;</span><br><span class="line">                    nums[insertIndex] = nums[insertIndex - gap];</span><br><span class="line">                    insertIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[insertIndex] = insertValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>思路</p></blockquote><p>将所有待比较的数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低为开始，依次进行一次排序。</p><ul><li>10个桶：对应0~9个数字</li><li>将每个数的<strong>个位</strong>取出，查看应该将这个数（所有位都有）放到哪个对应的桶中</li><li>按照10个桶的顺序，和桶中元素的顺序组成一个新数组</li><li>接下来依据<strong>十位</strong>，将数据放到桶中，之后再取出</li><li>重复操作，直至最高位都已经判断了。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        radixSort(<span class="type">int</span>[] nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();  <span class="comment">//最长的位数</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][nums.length];<span class="comment">//定义十个桶，每个桶都有一定容量</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//存放每个桶中有几个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>;i &lt; maxLength;i ++, n *= <span class="number">10</span>)&#123;<span class="comment">//循环最大数的位数次；和每次判断位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> nums[j] / n % <span class="number">10</span>;<span class="comment">//取出要判断的位上的数</span></span><br><span class="line">                <span class="comment">//放到对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = nums[j];</span><br><span class="line">                bucketElementCounts[digitOfElement] ++;<span class="comment">//桶中元素的个数++</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//取出桶中的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; <span class="number">10</span>;k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//循环拿出桶里的数据</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k];l++)&#123;</span><br><span class="line">nums[index++] = bucked[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bucketElementCounts[k] = <span class="number">0</span>;<span class="comment">//把每个桶的数据清空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2022/05/17/spring/"/>
      <url>/2022/05/17/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Spring-AOP"><a href="#1-Spring-AOP" class="headerlink" title="1.Spring AOP"></a>1.Spring AOP</h2><h3 id="1-1使用AOP好处"><a href="#1-1使用AOP好处" class="headerlink" title="1.1使用AOP好处"></a>1.1使用AOP好处</h3><p><strong>1.集中处理某一关注点&#x2F;横切逻辑</strong><br><strong>2.可以很方便的添加&#x2F;删除关注点</strong><br><strong>3.侵入性少，增强代码可读性及可维护性</strong></p><h3 id="1-2-AOP的术语"><a href="#1-2-AOP的术语" class="headerlink" title="1.2 AOP的术语"></a>1.2 AOP的术语</h3><p><strong>1.Join point（连接点）</strong><br>Spring 官方文档的描述：</p><blockquote><p>A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p></blockquote><p>程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法的执行。通俗的讲，连接点即表示类里面可以被增强的方法<br><strong>2.Pointcut（切入点）</strong></p><blockquote><p>Pointcut are expressions that is matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language</p></blockquote><p>切入点是与连接点匹配的表达式，用于确定是否需要执行通知。切入点使用与连接点匹配的不同类型的表达式，Spring框架使用AspectJ切入点表达式语言。我们可以将切入点理解为需要被拦截的Join point<br><strong>3.Advice（增强&#x2F;通知）</strong><br>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知和环绕通知(切面要完成的功能)<br><strong>4.Aspect（切面）</strong><br>Aspect切面表示Pointcut（切入点）和Advice（增强&#x2F;通知）的结合</p><h3 id="1-3-Spring-AOP用法"><a href="#1-3-Spring-AOP用法" class="headerlink" title="1.3 Spring AOP用法"></a>1.3 Spring AOP用法</h3><p><strong>资源代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置登录用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUserHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        holder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验用户权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;authService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> CurrentUserHolder.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;admin&quot;</span>.equals(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户无此权限！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;productService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">deleteProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品id为&quot;</span> + id + <span class="string">&quot;的商品成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProductByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品名称为&quot;</span> + name + <span class="string">&quot;的商品成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;100&quot;</span>.equals(id.toString())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该商品不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对业务逻辑类进行增强的方法</strong></p><p><strong>1.使用within表达式匹配包类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配ProductServiceImpl类里面的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.aop.service.impl.ProductServiceImpl)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchType</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配com.aop.service包及其子包下所有类的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.aop.service..*)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchPackage</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>2.使用this、target、bean表达式匹配对象类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配AOP对象的目标对象为指定类型的方法，即ProductServiceImpl的aop代理对象的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;this(com.aop.service.impl.ProductServiceImpl)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchThis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配实现ProductService接口的目标对象</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;target(com.aop.service.ProductService)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTarget</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有以Service结尾的bean里面的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;bean(*Service)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchBean</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>3.使用args表达式匹配参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配第一个参数为Long类型的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;args(Long, ..) &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchArgs</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>4.使用@annotation、@within、@target、@args匹配注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配标注有AdminOnly注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.aop.annotation.AdminOnly)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchAnno</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标注有Beta的类底下的方法，要求annotation的Retention级别为CLASS</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@within(com.google.common.annotations.Beta)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchWithin</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标注有Repository的类底下的方法，要求annotation的Retention级别为RUNTIME</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@target(org.springframework.stereotype.Repository)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTarget</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配传入的参数类标注有Repository注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@args(org.springframework.stereotype.Repository)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchArgs</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>5.使用execution表达式</strong><br>execution表达式是我们在开发过程中最常用的，它的语法如下：</p><p><img src="/2022/05/17/spring/1240" alt="execution表达式"></p><p><strong>modifier-pattern</strong>：用于匹配public、private等访问修饰符<br><strong>ret-type-pattern</strong>：用于匹配返回值类型，不可省略<br><strong>declaring-type-pattern</strong>：用于匹配包类型<br><strong>modifier-pattern（param-pattern）</strong>：用于匹配类中的方法，不可省略<br><strong>throws-pattern</strong>：用于匹配抛出异常的方法</p><blockquote><p>切面Aspect代码</p><p>@Aspect：告诉Spring当前类是一个切面类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>    <span class="comment">//一定要写这个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下的方法名以delete开头、参数类型为Long的public方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.aop.service.impl.ProductServiceImpl.delete*(Long))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchCondition</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用matchCondition这个切入点进行增强</span></span><br><span class="line">    <span class="meta">@Before(&quot;matchCondition()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before 前置通知......&quot;</span>);</span><br><span class="line">        authService.checkAccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对切面类增强的方法进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置用户名</span></span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.selectProduct(<span class="number">100L</span>);</span><br><span class="line">        productService.deleteProductByName(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果，（只有deleteProductById方法拦截成功）：</span></span><br><span class="line">查询商品成功！</span><br><span class="line">删除商品名称为衣服的商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: 该用户无此权限！</span><br><span class="line"></span><br><span class="line">at com.aop.service.impl.AuthServiceImpl.checkAccess(AuthServiceImpl.java:<span class="number">15</span>)</span><br><span class="line">at com.aop.security.SecurityAspect.before(SecurityAspect.java:<span class="number">50</span>)</span><br></pre></td></tr></table></figure><blockquote><p>可以在多个表达式之间使用连接符匹配多个条件， 如使用||表示“或”，使用 &amp;&amp;表示“且”</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下方法名以select或delete开头的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.select*(..)) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;execution(* com.aop.service.impl.ProductServiceImpl.delete*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchCondition</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用matchCondition这个切入点进行增强</span></span><br><span class="line"><span class="meta">@Before(&quot;matchCondition()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;before 前置通知......&quot;</span>);</span><br><span class="line">   authService.checkAccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.selectProduct(<span class="number">100L</span>);</span><br><span class="line">        productService.deleteProductByName(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果；全部拦截成功</span></span><br><span class="line">before 前置通知......</span><br><span class="line">查询商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line">删除商品名称为衣服的商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line">删除商品id为<span class="number">100</span>的商品成功！</span><br></pre></td></tr></table></figure><h3 id="1-4-Advice注解"><a href="#1-4-Advice注解" class="headerlink" title="1.4 Advice注解"></a>1.4 Advice注解</h3><p>Advice注解一共有五种，分别是：<br><strong>1.@Before前置通知</strong><br>前置通知在切入点运行前执行，不会影响切入点的逻辑<br><strong>2.@After后置通知</strong><br>后置通知在切入点正常运行结束后执行，如果切入点抛出异常，则在抛出异常前执行<br><strong>3.@AfterThrowing异常通知</strong><br>异常通知在切入点抛出异常前执行，如果切入点正常运行（未抛出异常），则不执行<br><strong>4.@AfterReturning返回通知</strong><br>返回通知在切入点正常运行结束后执行，如果切入点抛出异常，则不执行<br><strong>5.@Around环绕通知</strong><br>环绕通知是功能最强大的通知，可以在切入点执行前后自定义一些操作。环绕通知需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下面的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchAll</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;matchAll()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        authService.checkAccess();</span><br><span class="line">        System.out.println(<span class="string">&quot;befor 在切入点执行前运行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = joinPoint.proceed(joinPoint.getArgs());<span class="comment">//获取参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;after 在切入点执行后运行,result = &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after 在切入点执行后抛出exception运行&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">        productService.selectProduct(<span class="number">10L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">before 在切入点执行前运行</span><br><span class="line">删除商品id为<span class="number">100</span>的商品成功！</span><br><span class="line">after 在切入点执行后运行,result = <span class="number">100</span></span><br><span class="line"><span class="keyword">finally</span>......</span><br><span class="line">before 在切入点执行前运行</span><br><span class="line">查询商品失败！</span><br><span class="line">after 在切入点执行后抛出exception运行</span><br><span class="line">java.lang.RuntimeException: 该商品不存在！</span><br><span class="line">at com.aop.service.impl.ProductServiceImpl.selectProduct(ProductServiceImpl.java:<span class="number">41</span>)</span><br><span class="line"><span class="keyword">finally</span>......</span><br></pre></td></tr></table></figure><p>在执行ProceedingJoinPoint对象的proceed方法前相当于Before前置通知；执行proceed方法相当于运行切入点（同时可以获取参数）；在方法执行之后相当于After后置通知，如果运行切入点抛出异常，则catch中的内容相当于AfterThrowing异常通知;finally中的内容无论切入点是否抛出异常，都将执行</p><h3 id="1-5-使用总结"><a href="#1-5-使用总结" class="headerlink" title="1.5 使用总结"></a>1.5 使用总结</h3><blockquote><p>AOP：【动态代理】<br>          指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</p><p>  1、导入aop模块；Spring AOP：(spring-aspects)<br>  2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<br>  3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；<br>          通知方法：<br>              前置通知(@Before)：logStart：在目标方法(div)运行之前运行<br>              后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<br>              返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<br>              异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<br>              环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）<br>  4、给切面类的目标方法标注何时何地运行（通知注解）；<br>  5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<br>  6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)<br>  7、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】<br>          在Spring中很多的 @EnableXXX;</p><p>  三步：<br>      1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）<br>      2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）<br>      3）、开启基于注解的aop模式；@EnableAspectJAutoProxy</p></blockquote><h3 id="1-7-案例"><a href="#1-7-案例" class="headerlink" title="1.7 案例"></a>1.7 案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">我定义了一个除法方法，作为一个切面：需要增强的业务方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.kun.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathCalculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathCalculator...div...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i/j;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span>： 告诉Spring当前类是一个切面类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspects</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽取公共的切入点表达式</span></span><br><span class="line">    <span class="comment">//1、本类引用</span></span><br><span class="line">    <span class="comment">//2、其他的切面引用</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.kun.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logStart</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;运行。。。@Before:参数列表是：&#123;&quot;</span>+Arrays.asList(args)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(&quot;com.kun.aop.LogAspects.pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logEnd</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;结束。。。@After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JoinPoint一定要出现在参数表的第一位</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;</span>+result+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;异常。。。异常信息：&#123;&quot;</span>+exception+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@EnableAspectJAutoProxy:注解开启切面代理</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">aop的配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kun.aop.LogAspects;</span><br><span class="line"><span class="keyword">import</span> com.kun.aop.MathCalculator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfigOfAOP</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//业务逻辑类加入容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MathCalculator <span class="title function_">calculator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MathCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切面类加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogAspects <span class="title function_">logAspects</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogAspects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8代理对象创建过程"><a href="#1-8代理对象创建过程" class="headerlink" title="1.8代理对象创建过程"></a>1.8代理对象创建过程</h3><h4 id="1-8-1-EnableAspectJAutoProxy"><a href="#1-8-1-EnableAspectJAutoProxy" class="headerlink" title="1.8.1@EnableAspectJAutoProxy"></a>1.8.1@EnableAspectJAutoProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">     * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它导入了一个<strong>AspectJAutoProxyRegistrar</strong>组件，进一步查看其代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.config.AopConfigUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.context.annotation.MetadataUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy&#125; annotation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">     * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">enableAJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">                attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它实现了<strong>ImportBeanDefinitionRegistrar</strong>接口，这个接口可以向IOC容器中注册bean。 由此可以推测aop利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion。</p></blockquote><p><img src="/2022/05/17/spring/1140836-20181031200151572-1248357045.png" alt="img"></p><blockquote><p><em>IOC容器中注入了一个internalAutoProxyCreator&#x3D;AnnotationAwareAspectJAutoProxyCreator的bean，</em>到此可以得出结论，@EnableAspectJAutoProxy给容器中注册一个AnnotationAwareAspectJAutoProxyCreator。</p></blockquote><h4 id="1-8-2-AnnotationAwareAspectJAutoProxyCreator创建过程"><a href="#1-8-2-AnnotationAwareAspectJAutoProxyCreator创建过程" class="headerlink" title="1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程"></a>1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程</h4><p><img src="/2022/05/17/spring/1140836-20181031201123887-743732675.png" alt="img"></p><blockquote><p>在此需要关注两点内容：</p><p>1）关注后置处理器SmartInstantiationAwareBeanPostProcessor（在bean初始化完成前后做事情）</p><p>2）关注自动装配BeanFactory。</p></blockquote><blockquote><p>通过代码查看，发现父类AbstractAutoProxyCreator中有后置处理器的内容；AbstactAdvisorAutoProxyCreator类中重写了其父类AbstractAutoProxyCreator中setBeanFactory()方法，在AnnotationAwareAspectJAutoProxyCreator类中initBeanFactory()方法完成了自动装配BeanFactory。</p></blockquote><p>1）、 @EnableAspectJAutoProxy 开启AOP功能<br> 2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator<br> 3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；<br> 4）、容器的创建流程：<br>        1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象<br>        2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean<br>            1）、创建业务逻辑组件和切面组件<br>            2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>            3）、组件创建完之后，判断组件是否需要增强<br>                     是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；<br> 5）、执行目标方法：<br>        1）、代理对象执行目标方法<br>        2）、CglibAopProxy.intercept()；<br>             1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）<br>             2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>             3）、效果：<br>                      正常执行：前置通知-》目标方法-》后置通知-》返回通知<br>                      出现异常：前置通知-》目标方法-》后置通知-》异常通知</p><h3 id="1-9-面试回答AOP"><a href="#1-9-面试回答AOP" class="headerlink" title="1.9 面试回答AOP"></a>1.9 面试回答AOP</h3><p>简单说说 AOP 的设计：</p><ol><li>每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li><li>每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP。</li><li>当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦截器”。内层拦截器的设计就是职责连的设计。</li></ol><p><strong>可以将 AOP 分成 2 个部分。</strong><br>第一：代理的创建；<br>第二：代理的调用。</p><ol><li>代理的创建（按步骤）：</li></ol><ul><li>首先，需要创建代理工厂，代理工厂需要 3 个重要的信息：拦截器数组，目标对象接口数组，目标对象。</li><li>创建代理工厂时，默认会在拦截器数组尾部再增加一个默认拦截器 —— 用于最终的调用目标方法。</li><li>当调用 getProxy 方法的时候，会根据接口数量大余 0 条件返回一个代理对象（JDK or Cglib）。</li><li>注意：创建代理对象时，同时会创建一个外层拦截器，这个拦截器就是 Spring 内核的拦截器。用于控制整个 AOP 的流程。</li></ul><ol start="2"><li>代理的调用</li></ol><ul><li>当对代理对象进行调用时，就会触发外层拦截器。</li><li>外层拦截器根据代理配置信息，创建内层拦截器链。创建的过程中，会根据表达式判断当前拦截是否匹配这个拦截器。而这个拦截器链设计模式就是职责链模式。</li><li>当整个链条执行到最后时，就会触发创建代理时那个尾部的默认拦截器，从而调用目标方法。最后返回。</li></ul><p>题外话：Spring 的事务也就是个拦截器。</p><p><img src="/2022/05/17/spring/124011111" alt="img"></p><p><img src="/2022/05/17/spring/AOP%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B" alt="img"></p><h2 id="2-Spring-三级缓存"><a href="#2-Spring-三级缓存" class="headerlink" title="2. Spring 三级缓存"></a>2. Spring 三级缓存</h2><h3 id="2-1-Spring-Bean的循环依赖"><a href="#2-1-Spring-Bean的循环依赖" class="headerlink" title="2.1 Spring Bean的循环依赖"></a><strong>2.1 Spring Bean的循环依赖</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这其实就是Spring环境下典型的循环依赖场景</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类：</p><p><img src="/2022/05/17/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p><ol><li><p><strong>构造器注入循环依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p><p><img src="/2022/05/17/spring/image-20210912191502658.png" alt="image-20210912191502658"></p></li></ol><blockquote><p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘） </p><p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决~~~</p></blockquote><ol start="2"><li><p><strong>field属性注入（setter方法注入）循环依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>结果：项目启动成功，能够正常work</strong></p></li><li><p><strong><code>prototype</code> field属性注入循环依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单例Bean内注入</span></span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private A a;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/spring/image-20210912191727007.png" alt="image-20210912191727007"></p></li></ol><blockquote><p>对于Spring循环依赖的情况总结如下：</p><ol><li>不能解决的情况： 1. 构造器注入循环依赖 2. <code>prototype</code> field属性注入循环依赖</li><li>能解决的情况： 1. field属性注入（setter方法注入）循环依赖</li></ol></blockquote><p><strong>Spring创建Bean的流程</strong></p><p><img src="/2022/05/17/spring/20210912.png" alt="20210912"></p><p>对Bean的创建最为核心三个方法解释如下：</p><ul><li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li><li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li><li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li></ul><p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p><p><strong>Spring容器的<code>&#39;三级缓存&#39;</code></strong></p><p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p><p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line"><span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line"><span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line"><span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p><ol><li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li><li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li><li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li></ol><p><strong>获取单例Bean的源码如下：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isActuallyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li><li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li><li>如果还是获取不到，且允许singletonFactories（allowEarlyReference&#x3D;true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从</strong><code>**singletonFactories**</code><strong>中移除，并且放进</strong><code>**earlySingletonObjects**</code><strong>。其实也就是从三级缓存</strong><code>**移动（是剪切、不是复制哦~）**</code><strong>到了二级缓存）</strong></li></ol><blockquote><p> <strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong></p></blockquote><p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span></span><br><span class="line">@<span class="title class_">FunctionalInterface</span></span><br><span class="line">public interface <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">T <span class="title function_">getObject</span>() throws <span class="title class_">BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。 </p></blockquote><p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p><p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来 <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p><h3 id="2-2-源码解析"><a href="#2-2-源码解析" class="headerlink" title="2.2 源码解析"></a>2.2 源码解析</h3><p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FactoryBeanRegistrySupport</span> implements <span class="title class_">ConfigurableBeanFactory</span> &#123;</span><br><span class="line">...</span><br><span class="line">protected &lt;T&gt; T <span class="title function_">doGetBean</span>(final <span class="title class_">String</span> name, @<span class="title class_">Nullable</span> final <span class="title class_">Class</span>&lt;T&gt; requiredType, @<span class="title class_">Nullable</span> final <span class="title class_">Object</span>[] args, boolean typeCheckOnly) throws <span class="title class_">BeansException</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span></span><br><span class="line"><span class="title class_">Object</span> sharedInstance = <span class="title function_">getSingleton</span>(beanName);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="title function_">markBeanAsCreated</span>(beanName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.<span class="title function_">isSingleton</span>()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span></span><br><span class="line"><span class="comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span></span><br><span class="line"><span class="comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span></span><br><span class="line">sharedInstance = <span class="title function_">getSingleton</span>(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">createBean</span>(beanName, mbd, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">BeansException</span> ex) &#123;</span><br><span class="line"><span class="title function_">destroySingleton</span>(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = <span class="title function_">getObjectForBeanInstance</span>(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span></span><br><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractBeanFactory</span> implements <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line">...</span><br><span class="line">protected <span class="title class_">Object</span> <span class="title function_">doCreateBean</span>(final <span class="title class_">String</span> beanName, final <span class="title class_">RootBeanDefinition</span> mbd, final @<span class="title class_">Nullable</span> <span class="title class_">Object</span>[] args) throws <span class="title class_">BeanCreationException</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span></span><br><span class="line">instanceWrapper = <span class="title function_">createBeanInstance</span>(beanName, mbd, args);</span><br><span class="line"><span class="comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span></span><br><span class="line"><span class="comment">// 注意：此处是原始对象，这点非常的重要</span></span><br><span class="line">final <span class="title class_">Object</span> bean = instanceWrapper.<span class="title function_">getWrappedInstance</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span></span><br><span class="line"><span class="comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span></span><br><span class="line"><span class="comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span></span><br><span class="line">boolean earlySingletonExposure = (mbd.<span class="title function_">isSingleton</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">allowCircularReferences</span> &amp;&amp; <span class="title function_">isSingletonCurrentlyInCreation</span>(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.<span class="title function_">isTraceEnabled</span>()) &#123;</span><br><span class="line">logger.<span class="title function_">trace</span>(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span></span><br><span class="line"><span class="comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span></span><br><span class="line"><span class="comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span></span><br><span class="line"><span class="comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span></span><br><span class="line"><span class="comment">// 若不需要执行AOP的逻辑，直接返回Bean</span></span><br><span class="line"><span class="title function_">addSingletonFactory</span>(beanName, () -&gt; <span class="title function_">getEarlyBeanReference</span>(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span> exposedObject = bean; <span class="comment">//exposedObject 是最终返回的对象</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 填充属于，解决@Autowired依赖~</span></span><br><span class="line"><span class="title function_">populateBean</span>(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 执行初始化回调方法们~~~</span></span><br><span class="line">exposedObject = <span class="title function_">initializeBean</span>(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span></span><br><span class="line"><span class="comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span></span><br><span class="line"><span class="comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span></span><br><span class="line"><span class="comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span></span><br><span class="line"><span class="comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了&quot;偷天换日&quot; 特别适合中间件的设计</span></span><br><span class="line"><span class="comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span></span><br><span class="line"><span class="title class_">Object</span> earlySingletonReference = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span></span><br><span class="line"><span class="comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// allowRawInjectionDespiteWrapping这个值默认是false</span></span><br><span class="line"><span class="comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">allowRawInjectionDespiteWrapping</span> &amp;&amp; <span class="title function_">hasDependentBean</span>(beanName)) &#123;</span><br><span class="line"><span class="comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span></span><br><span class="line"><span class="title class_">String</span>[] dependentBeans = <span class="title function_">getDependentBeans</span>(beanName);</span><br><span class="line"><span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个个检查它所以Bean</span></span><br><span class="line"><span class="comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span></span><br><span class="line"><span class="comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span></span><br><span class="line"><span class="comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span></span><br><span class="line"><span class="comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="title class_">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.<span class="title function_">add</span>(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span></span><br><span class="line"><span class="comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line"><span class="title class_">StringUtils</span>.<span class="title function_">collectionToCommaDelimitedString</span>(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然是remove方法 但是它的返回值也非常重要</span></span><br><span class="line"><span class="comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span></span><br><span class="line">protected boolean <span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(<span class="params"><span class="built_in">String</span> beanName</span>) &#123;</span><br><span class="line"><span class="comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">alreadyCreated</span>.<span class="title function_">contains</span>(beanName)) &#123;</span><br><span class="line"><span class="title function_">removeSingleton</span>(beanName);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p><p>这里有个小细节：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p><h3 id="2-3-流程总结（非常重要）"><a href="#2-3-流程总结（非常重要）" class="headerlink" title="2.3 流程总结（非常重要）"></a>2.3 流程总结（<code>非常重要</code>）</h3><p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p><p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean(&quot;a&quot;)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T <span class="title function_">doGetBean</span>(<span class="params">...</span>)&#123;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line"><span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="title function_">markBeanAsCreated</span>(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line"><span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line"><span class="title class_">Object</span> beanInstance = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line"><span class="comment">//1、标注a正在创建中~</span></span><br><span class="line"><span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line"><span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line"><span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">sharedInstance = <span class="title function_">getSingleton</span>(beanName, () -&gt; &#123; ... <span class="keyword">return</span> <span class="title function_">createBean</span>(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected <span class="title class_">Object</span> <span class="title function_">doCreateBean</span>(<span class="params"></span>)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span></span><br><span class="line">instanceWrapper = <span class="title function_">createBeanInstance</span>(beanName, mbd, args);</span><br><span class="line"><span class="comment">// 此处bean为&quot;原始Bean&quot;   也就是这里的A实例对象：A@1234</span></span><br><span class="line">final <span class="title class_">Object</span> bean = instanceWrapper.<span class="title function_">getWrappedInstance</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span></span><br><span class="line">boolean earlySingletonExposure = (mbd.<span class="title function_">isSingleton</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">allowCircularReferences</span> &amp;&amp; <span class="title function_">isSingletonCurrentlyInCreation</span>(beanName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span></span><br><span class="line"><span class="comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="title function_">addSingletonFactory</span>(beanName, () -&gt; <span class="title function_">getEarlyBeanReference</span>(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span></span><br><span class="line"><span class="title class_">Object</span> exposedObject = bean; </span><br><span class="line"><span class="comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span></span><br><span class="line"><span class="comment">// 因此此处会调用getBean(&quot;b&quot;)，so 会重复上面步骤创建B类的实例</span></span><br><span class="line"><span class="comment">// 此处我们假设B已经创建好了 为B@5678</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是在populateBean(&quot;b&quot;)的时候依赖有beanA，所以此时候调用getBean(&quot;a&quot;)最终会调用getSingleton(&quot;a&quot;)，</span></span><br><span class="line"><span class="comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">populateBean</span>(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span></span><br><span class="line"><span class="comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span></span><br><span class="line"><span class="comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span></span><br><span class="line">exposedObject = <span class="title function_">initializeBean</span>(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span></span><br><span class="line"><span class="comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span></span><br><span class="line"><span class="comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span></span><br><span class="line"><span class="comment">// 因此此处返回A的实例：A@1234</span></span><br><span class="line"><span class="title class_">Object</span> earlySingletonReference = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span></span><br><span class="line"><span class="comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span></span><br><span class="line"><span class="comment">// 这种情况至此，就全部结束了~~~</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span></span><br><span class="line"><span class="comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是[&quot;b&quot;]这个依赖</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">allowRawInjectionDespiteWrapping</span> &amp;&amp; <span class="title function_">hasDependentBean</span>(beanName)) &#123;</span><br><span class="line"><span class="title class_">String</span>[] dependentBeans = <span class="title function_">getDependentBeans</span>(beanName);</span><br><span class="line"><span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A@1234依赖的是[&quot;b&quot;]，所以此处去检查b</span></span><br><span class="line"><span class="comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span></span><br><span class="line"><span class="keyword">for</span> (<span class="title class_">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span></span><br><span class="line"><span class="comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.<span class="title function_">add</span>(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line"><span class="title class_">StringUtils</span>.<span class="title function_">collectionToCommaDelimitedString</span>(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解： </p><p><img src="/2022/05/17/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="循环依赖流程图"></p><hr><p><strong>最后的最后，由于我太暖心了_，再来个纯文字版的总结。</strong> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p><ol><li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li><li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li><li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li><li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li><li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li><li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li><li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li><li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li><li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li><li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li></ol><p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p><hr><hr><hr><h3 id="2-4-循环依赖对AOP代理对象创建流程和结果的影响"><a href="#2-4-循环依赖对AOP代理对象创建流程和结果的影响" class="headerlink" title="2.4 循环依赖对AOP代理对象创建流程和结果的影响"></a>2.4 循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h3><p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p><p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span></span><br><span class="line"><span class="comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span></span><br><span class="line"><span class="comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span></span><br><span class="line"><span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span></span><br><span class="line"><span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环依赖校验（非常重要）~~~~</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span></span><br><span class="line"><span class="comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span></span><br><span class="line"><span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line"><span class="comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span></span><br><span class="line"><span class="comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span></span><br><span class="line"><span class="comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环依赖校验</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span></span><br><span class="line"><span class="comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span></span><br><span class="line"><span class="comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">&#125;...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀~~~）</p><p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Caused</span> <span class="attr">by</span>: org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">BeanCurrentlyInCreationException</span>: <span class="title class_">Error</span> creating bean <span class="keyword">with</span> name <span class="string">&#x27;a&#x27;</span>: <span class="title class_">Requested</span> bean is currently <span class="keyword">in</span> <span class="attr">creation</span>: <span class="title class_">Is</span> there an unresolvable circular reference?</span><br><span class="line">at org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">support</span>.<span class="property">DefaultSingletonBeanRegistry</span>.<span class="title function_">beforeSingletonCreation</span>(<span class="title class_">DefaultSingletonBeanRegistry</span>.<span class="property">java</span>:<span class="number">339</span>)</span><br><span class="line">at org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">support</span>.<span class="property">DefaultSingletonBeanRegistry</span>.<span class="title function_">getSingleton</span>(<span class="title class_">DefaultSingletonBeanRegistry</span>.<span class="property">java</span>:<span class="number">215</span>)</span><br></pre></td></tr></table></figure><blockquote><p> 注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别~~ 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置~ </p></blockquote><p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span></span><br><span class="line"><span class="comment">// 但是：我们的此bean还是需要AOP代理的~~~</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private HelloService helloService;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样它的大致运行如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line"><span class="comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">...</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">... 这里更不用说，因为earlySingletonExposure=<span class="literal">false</span>  所以上面的代理对象exposedObject 直接<span class="keyword">return</span>了~</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p><p>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</p><blockquote><p> <code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些 </p></blockquote><p>该抽象类实现了创建代理的动作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span></span><br><span class="line"><span class="comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span></span><br><span class="line"><span class="comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span></span><br><span class="line"><span class="comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span></span><br><span class="line"><span class="comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p><p><strong><code>上面分析了三种case，现给出结论如下：</code></strong> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong></p><h2 id="3-Spring-MVC"><a href="#3-Spring-MVC" class="headerlink" title="3. Spring MVC"></a>3. Spring MVC</h2><p><img src="/2022/05/17/spring/springMVC" alt="img"></p><p><img src="/2022/05/17/spring/image-20210912190512831.png" alt="image-20210912190512831"></p><h2 id="4-java动态代理"><a href="#4-java动态代理" class="headerlink" title="4. java动态代理"></a>4. <a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html">java动态代理</a></h2><p>关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式–代理模式，而对于代理，根据创建代理类的时间点，又可以分为静态代理和动态代理。</p><h3 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h3><p>  代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。在后面我会</p><p>解释这种间接性带来的好处。代理模式结构图（图片来自《大话设计模式》）：</p><p><img src="/2022/05/17/spring/1085268-20170409105440082-1652546649.jpg" alt="img">                             </p><h3 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h3><p>  <strong>1、静态代理</strong></p><p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p><p>  <strong>2、静态代理简单实现</strong></p><p> 根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，</p><p>班长就是学生的代理。</p><p>  首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>Student类实现Person接口。Student可以具体实施上交班费的动作。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>下面测试一下，看如何使用代理模式：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentsProxy</span>(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//班长代理上交班费</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行结果：</p><p><img src="/2022/05/17/spring/1085268-20170409141805347-556037068.png" alt="img"></p><p>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行结果：</p><p><img src="/2022/05/17/spring/1085268-20170409143428488-1662654340.png" alt="img"></p><p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p><h3 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a><strong>三、动态代理</strong></h3><p>   <strong>1.动态代理</strong></p><p>  代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">       beforeMethod();</span><br><span class="line">       stu.giveMoney();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p><p>   <strong>2、动态代理简单实现</strong></p><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p>创建一个动态代理对象步骤，具体代码见后面：</p><ul><li>创建一个InvocationHandler对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line"> <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br></pre></td></tr></table></figure><ul><li>使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;Person.class&#125;);</span><br></pre></td></tr></table></figure><ul><li>获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);</span><br></pre></td></tr></table></figure><ul><li>通过构造器constructor来创建一个动态实例stuProxy</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person stuProxy = (Person) cons.newInstance(stuHandler);</span><br></pre></td></tr></table></figure><p>就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure><p>到这里肯定都会很疑惑，这动态代理到底是如何执行的，是如何通过代理对象来执行被代理对象的方法的，先不急，我们先看看一个简单的完整的动态代理的例子。还是上面静态代理的例子，班长需要帮学生代交班费。**<br>**首先是定义一个Person接口:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建需要被代理的实际类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">finishTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><p>再再invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuInvocationHandler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StuInvocationHandler</span><span class="params">(T target)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StuInvocationHandler</span>&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">stuProxy</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。</p><p>运行结果：</p><p><img src="/2022/05/17/spring/1085268-20170409164136175-1515319571.png" alt="img"></p><p>上面说到，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p><p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p><h3 id="四、动态代理原理分析"><a href="#四、动态代理原理分析" class="headerlink" title="四、动态代理原理分析"></a><strong>四、动态代理原理分析</strong></h3><p>  <strong>1、Java动态代理创建出来的动态代理类</strong></p><p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我们最应该关注的是 Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">&quot;$Proxy0&quot;</span>, Student.class.getInterfaces());</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;G:/javacode/javase/Test/bin/proxy/StuProxy.class&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path)) &#123;</span><br><span class="line">    fos.write(classFile);</span><br><span class="line">    fos.flush();</span><br><span class="line">    System.out.println(<span class="string">&quot;代理类class文件写入成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;写文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：\</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">  *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">  *Proxy构造方法：</span></span><br><span class="line"><span class="comment">  *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">  *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">  *         this.h = h;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;proxy.Person&quot;</span>).getMethod(<span class="string">&quot;giveMoney&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">  *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。<br>上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/2022/05/17/Tomcat/"/>
      <url>/2022/05/17/Tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="1-Tomcat底层架构"><a href="#1-Tomcat底层架构" class="headerlink" title="1.Tomcat底层架构"></a>1.Tomcat底层架构</h2><p><img src="/2022/05/17/Tomcat/image-20210817221121173.png" alt="image-20210817221121173"></p><h3 id="1-1-连接器-Connector-Coyote"><a href="#1-1-连接器-Connector-Coyote" class="headerlink" title="1.1 连接器(Connector):Coyote"></a>1.1 连接器(Connector):Coyote</h3><h4 id="1-1-1架构介绍"><a href="#1-1-1架构介绍" class="headerlink" title="1.1.1架构介绍"></a>1.1.1架构介绍</h4><p>Coyote是Tomcat的连接器框架的名称，是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接收响应。</p><p>Coyote封装了底层的网络通信（Socker请求即响应处理），为Catalina容器提供了统一的接口，使Catalina容器与具体的请求协议即IO操作方式完全解耦。Coyote将Socket输入封装为Request对象，交由Catalina容器进行处理，处理请求完成 后，Catalina通过Coyote提供的Response对象将结果写入输出流。</p><p>Coyote作为独立的模块，只负责具体的协议和IO的相关操作，与Servlet规范实现没有任何关系，因此即便是Request和Response对象也并未实现Servlet规范的接口，而是在Catalina中将他们进一步封装为ServletResquest和ServletResponse.</p><p><img src="/2022/05/17/Tomcat/image-20210817221855041.png" alt="image-20210817221855041"></p><h4 id="1-1-2-IO模型和协议"><a href="#1-1-2-IO模型和协议" class="headerlink" title="1.1.2 IO模型和协议"></a>1.1.2 IO模型和协议</h4><p>在Coyote中，Tomcat支持的多种I&#x2F;O模型和应用协议，具体包含如下：</p><p>Tomcat支持的IO模型（自8.5&#x2F;9.0版本起，Tomcat移除了BIO):</p><table><thead><tr><th>IO模型</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>非阻塞I&#x2F;O，采用java NIO类库实现。</td></tr><tr><td>NIO2</td><td>异步I&#x2F;O，采用JDK 7最新的NIO2类库实现</td></tr><tr><td>APR</td><td>采用Apache可移植运行库实现，使C&#x2F;C++编写的本地库。如果选择该方案，需要单独安装APR库。</td></tr></tbody></table><p>Tomcat支持的应用协议:</p><table><thead><tr><th>应用协议</th><th>描述</th></tr></thead><tbody><tr><td>HTTP&#x2F;1.1</td><td>这是大部分web应用采用的访问协议</td></tr><tr><td>AJP</td><td>用于和web服务器集成（如Apache），以实现对静态资源的优化以及集群部署，当前支持AJP&#x2F;1.3</td></tr><tr><td>HTTP&#x2F;2</td><td>HTTP 2.0大幅度的提升了web性能。下一代HTTP协议，自8.5和9.0版本后支持。</td></tr></tbody></table><p>应用分层：</p><p><img src="/2022/05/17/Tomcat/image-20210817222906538.png" alt="image-20210817222906538"></p><p>Tomcat为了实现支持多种I&#x2F;O模型和应用协议，一个容易可能对接多个连接器，就好比一个房间由多个们，但是单独的连接器或容器都不能对外提供服务，需要把他们组装起来才嗯那个工作，组装后的这个整体叫做Service组件。</p><h4 id="1-1-3-连接器组件"><a href="#1-1-3-连接器组件" class="headerlink" title="1.1.3 连接器组件"></a>1.1.3 连接器组件</h4><p><img src="/2022/05/17/Tomcat/image-20210817223222876.png" alt="image-20210817223222876"></p><p><strong>EndPoint</strong></p><ol><li>EndPoint：Coyote通信端点，即通信监听的接口，使具体Scoket接收和发送处理器，是对传输层的抽象，因此EndPoint用来实现TCP&#x2F;IP协议的。</li><li>Tomcat并没有EndPoint接口，而是提供了一个抽象类AbstractEndpoint，里面定义了两个内部类：Acceptor和SockerProcessor。Acceptor用于监听Scoket连接请求。SockerProcessor用于处理接收到的Scoket请求，它实现Runnalbe接口，在Run方法里面调用通信协议处理组件Processor进行处理。为了提高处理能力，SockerProcessor被提交到线程池来执行。而这个线程池叫做执行器（Executor）。</li></ol><p><strong>Processor</strong></p><p>Processor：Coyote协议处理接口，如果说EndPoint是用来实现TCP&#x2F;IP协议的，那么Processor用来实现HTTP协议，Processor接收来自EndPoint的Scoket，读取字节流解析成Tomcat  Request和Response对象，并通过Adapter将其交给容器处理，Processor是对应用层协议的抽象。</p><p><strong>Adapter</strong>:</p><p><img src="/2022/05/17/Tomcat/image-20210817224443275.png" alt="image-20210817224443275"></p><h3 id="1-2-容器-Catalina"><a href="#1-2-容器-Catalina" class="headerlink" title="1.2 容器 - Catalina"></a>1.2 容器 - Catalina</h3><p>Tomcat是一个由一系列可配置的组件构成的web容器，而Catalina是Tomcat的Servlet容器</p><p>Catalina是Servlet容器实现，包括之前所有的容器组件。</p><h4 id="1-2-1-Catalina地位"><a href="#1-2-1-Catalina地位" class="headerlink" title="1.2.1 Catalina地位"></a>1.2.1 Catalina地位</h4><p><img src="/2022/05/17/Tomcat/image-20210817224813861.png" alt="image-20210817224813861"></p><h4 id="1-2-2-Catalina结构"><a href="#1-2-2-Catalina结构" class="headerlink" title="1.2.2 Catalina结构"></a>1.2.2 Catalina结构</h4><p><img src="/2022/05/17/Tomcat/image-20210817225055523.png" alt="image-20210817225055523"></p><p>Catalina负责管理server，而server表示着整个服务器。server下面由多个服务service，每个服务都包含着多个连接器组件connector（coyote实现）和一个容器组件container。在tomcat启动的时候，会初始化一个catalina的实例。</p><p>Catalina各个组件的职责：</p><p><img src="/2022/05/17/Tomcat/image-20210817225430577.png" alt="image-20210817225430577"></p><h4 id="1-2-3-Container结构"><a href="#1-2-3-Container结构" class="headerlink" title="1.2.3 Container结构"></a>1.2.3 Container结构</h4><p>tomcat设计了4中容器，分别是Engine，Host，Context，Wrapper。这4中容器不是平行关系，而是父子管理。tomcat通过一种分层的架构，使得servlet容器具有很好的灵活性。</p><p><img src="/2022/05/17/Tomcat/image-20210817225844574.png" alt="image-20210817225844574"></p><p>各个组件的含义：</p><p><img src="/2022/05/17/Tomcat/image-20210817225932967.png" alt="image-20210817225932967"></p><p><img src="/2022/05/17/Tomcat/image-20210817231058250.png" alt="image-20210817231058250"></p><p><img src="/2022/05/17/Tomcat/image-20210817231212925.png" alt="image-20210817231212925"></p><h3 id="1-3-Tomcat启动流程"><a href="#1-3-Tomcat启动流程" class="headerlink" title="1.3 Tomcat启动流程"></a>1.3 Tomcat启动流程</h3><img src="/2022/05/17/Tomcat/image-20210817231401335.png" alt="image-20210817231401335" style="zoom:200%;"><p><img src="/2022/05/17/Tomcat/image-20210817232055812.png" alt="image-20210817232055812"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2022/05/17/JUC/"/>
      <url>/2022/05/17/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是JUC"><a href="#1-什么是JUC" class="headerlink" title="1.什么是JUC"></a>1.什么是JUC</h2><p><img src="/2022/05/17/JUC/image-20210620105003163.png" alt="image-20210620105003163"></p><p>java.util工具包</p><p>业务：普通的线程代码 Thread</p><p>Runnable:m:没有返回值，效率相比callable较低</p><p><img src="/2022/05/17/JUC/image-20210620105330818.png" alt="image-20210620105330818"></p><h2 id="2-线程和进程"><a href="#2-线程和进程" class="headerlink" title="2.线程和进程"></a>2.线程和进程</h2><p>进程：一个程序，QQ.exe Music.exe  程序的集合；</p><ul><li>一个进程往往由多个线程，至少包含一个！</li><li>Java默认有两个线程：Main  GC(垃圾回收)</li></ul><p>线程：开了一个进程Typora，写字，自动保存（线程负责）</p><p>对于Java而言：Thread、Runnable、Callable</p><blockquote><p> ｊａva不能开启线程</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//本地方法，用C++写的,Java无法直接操作硬件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>并发、并行</p></blockquote><p>并发编程：并发、并行</p><p>并发：多线程操作同一个资源</p><p>​CPU一核，模拟出来多条线程、快速交替</p><p>并行：多核CPU，多个线程可以同时执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取CPU的核数</span></span><br><span class="line">        <span class="comment">//cpu 密集型 IO密集型</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发编程的本质：<strong>充分利用CPU的资源</strong></p><blockquote><p> 线程有几个状态</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">   <span class="comment">//新生</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待，死等</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//超时等待</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>wait&#x2F;sleep 区别</p></blockquote><ol><li><p>来自不同的类</p><p>wait &#x3D;&gt; Object</p><p>sleep &#x3D;&gt; Thread</p></li><li><p><strong>关于锁的释放</strong></p><p>wait会释放锁，sleep不会释放</p></li><li><p><strong>使用的范围不同</strong></p><p>wait:必须在同步代码块</p><p>sleep可以在任何地方</p></li><li><p><strong>是否需要捕获异常</strong></p><p>wait不需要捕获异常</p><p>sleep必须捕获异常</p></li></ol><h2 id="3-lock锁"><a href="#3-lock锁" class="headerlink" title="3.lock锁"></a>3.lock锁</h2><blockquote><p>传统Synchronized</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是一个单独的资源类，没有任何操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTickedDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//并发：多个线程操作同一个资源类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//@FunctionalInterface  函数式接口，jdk1.8后用lambda表达式    ( 参数 ) -&gt;&#123;  代码  &#125;简化</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable()&#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run()&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类  OOP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//买票方式</span></span><br><span class="line">    <span class="comment">// synchronize本质  ：队列  锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;张票，剩余：&quot;</span>+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Lock 接口</p></blockquote><p><img src="/2022/05/17/JUC/image-20210620115435601.png" alt="image-20210620115435601"></p><p><img src="/2022/05/17/JUC/image-20210620115548843.png" alt="image-20210620115548843"></p><p><img src="/2022/05/17/JUC/Users\user\AppData\Roaming\Typora\typora-user-images\image-20210620115753684.png" alt="image-20210620115753684"></p><p>公平锁：先来后到</p><p><strong>非公平锁：可以插队（默认）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTickedDemo02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//并发：多个线程操作同一个资源类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//@FunctionalInterface  函数式接口，jdk1.8后用lambda表达式    ( 参数 ) -&gt;&#123;  代码  &#125;简化</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable()&#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run()&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">            ticket.sale();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//lock三部曲</span></span><br><span class="line"><span class="comment">//1.new ReentrantLock();</span></span><br><span class="line"><span class="comment">//2.  lock.lock();//加锁</span></span><br><span class="line"><span class="comment">//3.lock.unlock();//解锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;张票，剩余：&quot;</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>synchronized 和lock的区别</p></blockquote><ol><li>Synchronized 内置关键字，Lock是一个Java类</li><li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</li><li>Synchronized会自动释放锁，lock必须要手动释放锁，如果不释放，<strong>死锁</strong></li><li>Synchronized 线程1（获得锁，阻塞）、线程2（等待，傻傻的等），lock就不会傻傻的等</li><li>Synchronized可重入锁，不可以中断的，非公平；lock，可重入锁，可以判断锁，非公平（可以自己配置）</li><li>Synchronized适合锁少量的代码同步问题，lock适合锁大量的同步代码</li></ol><blockquote><p>锁是什么，如何判断锁的是谁</p></blockquote><h2 id="4-生产者和消费者"><a href="#4-生产者和消费者" class="headerlink" title="4.生产者和消费者"></a>4.生产者和消费者</h2><blockquote><p>生产者和消费者问题 Synchronized版：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题!  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A  B  操作同一个变量  num = 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A num + 1</span></span><br><span class="line"><span class="comment"> * B num - 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//资源类</span></span><br><span class="line">    <span class="comment">//判断等待，业务，通知</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//+1操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程，加操作完成</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-1 操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span>(number ==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            number --;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程，减操作完成</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题 A B C D 四个线程</p></blockquote><p><img src="/2022/05/17/JUC/image-20210620165915100.png" alt="image-20210620165915100"></p><p><strong>if 改为 while</strong>(上面的if有可能使多个线程都拿到锁，然后都释放，执行加减操作)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number ++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程，加操作完成</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span>(number ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number --;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程，减操作完成</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JUC版的生产者和消费者问题</p></blockquote><p><img src="/2022/05/17/JUC/image-20210620170957316.png" alt="image-20210620170957316"></p><p><img src="/2022/05/17/JUC/image-20210620170831801.png" alt="image-20210620170831801"></p><p>实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A执行完 调用B,</span></span><br><span class="line"><span class="comment"> * B执行完 调用C,</span></span><br><span class="line"><span class="comment"> * C执行完 调用A,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span>&#123;    <span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//1A  2B  3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;AAAAAAAAA&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒，唤醒指定的人 B</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//唤醒C</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;BBBBBBBBB&quot;</span>);</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//唤醒C</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;CCCCCCCC&quot;</span>);</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8锁现象"><a href="#5-8锁现象" class="headerlink" title="5. 8锁现象"></a>5. 8锁现象</h2><p>如何判断锁的是谁！</p><p>对象、Class</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁：就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1.标准情况下，两个线程是先打印发短信还是打电话  1.发短信   2.打电话</span></span><br><span class="line"><span class="comment"> * 2.sendSms延迟4秒时，两个线程是先打印发短信还是打电话  1.发短信   2.打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//synchronized 修饰方法，锁的对象是方法的调用者 phone ！</span></span><br><span class="line">    <span class="comment">//两个方法用的是同一把锁，谁先拿到先执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">sendSms</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁：就是关于锁的8个问题（有延迟的情况）</span></span><br><span class="line"><span class="comment"> * 3. 增加了一个普通方法时，先执行hello？普通方法</span></span><br><span class="line"><span class="comment"> * 4. 两个对象时，先 执行没延迟的打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//两个对象，两把锁</span></span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            phone.call();</span></span><br><span class="line"><span class="comment">//            phone.hello();</span></span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span>&#123;</span><br><span class="line">    <span class="comment">//synchronized 修饰方法，锁的对象是方法的调用者 phone ！</span></span><br><span class="line">    <span class="comment">//两个方法用的是同一把锁，谁先拿到先执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">sendSms</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里没有锁，不是同步方法，不受锁的影响</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁：就是关于锁的8个问题（有延迟的情况）</span></span><br><span class="line"><span class="comment"> * 5.增加两个静态的同步方法，只有一个对象</span></span><br><span class="line"><span class="comment"> * 6.两个对象，两个静态同步方法，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//两个对象的Class类模板只有一个,static,锁的是模板</span></span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Phone3只有唯一的一个Class对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span>&#123;</span><br><span class="line">    <span class="comment">//static 静态方法</span></span><br><span class="line">    <span class="comment">//类一加载就有了！Class 模板</span></span><br><span class="line">    <span class="comment">//锁的是Class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">sendSms</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁：就是关于锁的8个问题（有延迟的情况）</span></span><br><span class="line"><span class="comment">    7.一个静态同步方法，一个普通同步方法</span></span><br><span class="line"><span class="comment">    8.一个静态同步方法，一个普通同步方法，两个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//两个对象的Class类模板只有一个,static,锁的是模板</span></span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span>&#123;</span><br><span class="line">    <span class="comment">//静态的同步方法  锁的是Class类模板</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">sendSms</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通同步方法  锁的是调用者对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小节</p></blockquote><p>new this 具体的对象</p><p>static Class 唯一的类模板</p><h2 id="6-集合类不安全"><a href="#6-集合类不安全" class="headerlink" title="6.集合类不安全"></a>6.集合类不安全</h2><blockquote><p>List不安全</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//并发下，ArrayList是不安全的</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  解决方案：</span></span><br><span class="line"><span class="comment">         * 1.  Vector&lt;String&gt; strings = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2.List&lt;Object&gt; synList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3.CopyOnWriteArrayList&lt;String&gt; copy = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;String&gt; slist = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Vector&lt;String&gt; strings = new Vector&lt;&gt;();//1</span></span><br><span class="line"><span class="comment">//        List&lt;Object&gt; synList = Collections.synchronizedList(new ArrayList&lt;&gt;());//2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CopyOnWrite写入时复制  COW 计算机程序设计领域的一种优化策略</span></span><br><span class="line">        <span class="comment">//多个线程调用的时候，list,读取的时候，固定的，写入（覆盖）</span></span><br><span class="line">        <span class="comment">//在写入的时候避免覆盖，造成数据问题</span></span><br><span class="line">        CopyOnWriteArrayList&lt;String&gt; copy = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();<span class="comment">//3</span></span><br><span class="line">        <span class="comment">//CopyOnWriteArrayList比Vector好在：用lock锁实现，Vector使用Synchronized实现效率低</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                copy.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(copy);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Set不安全</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//解决方案1：Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">        <span class="comment">//解决方案2：</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet的底层是什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add方法  本质就是map  key是无法重复的</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//常量</span></span><br></pre></td></tr></table></figure><blockquote><p>HashMap不安全</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//map 是这样用的吗？默认等价于什么？不是，工作中不用HashMap</span></span><br><span class="line"><span class="comment">//        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//加载因子，初始化容量 new HashMap&lt;&gt;(16,0.75);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方案</span></span><br><span class="line">        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Callable-简单"><a href="#7-Callable-简单" class="headerlink" title="7.Callable(简单)"></a>7.Callable(简单)</h2><p><img src="/2022/05/17/JUC/image-20210623103936109.png" alt="image-20210623103936109"></p><ol><li>多线程的第三种创建方式</li><li>可以有返回值，可以抛出异常。</li><li>方法不同，run()&#x2F;call()</li></ol><p><img src="/2022/05/17/JUC/image-20210623105117161-1624416678610.png" alt="image-20210623105117161"></p><p><img src="/2022/05/17/JUC/image-20210623105306057-1624416787146.png" alt="image-20210623105306057"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//new Thread(new MyThread()).start();//传统的多线程方式  类实现Runnable(功能有限，没有返回值)</span></span><br><span class="line">        <span class="comment">//使用Callable接口</span></span><br><span class="line">        <span class="comment">//怎么启动Callable,因为Thread只能接收Runnable类型</span></span><br><span class="line">        <span class="comment">//Runnable的实现类有FutureTask,FutureTask可以接收Callable和Runnable的构造参数，所以能够启动Callable的线程。</span></span><br><span class="line">        <span class="comment">//1.new Thread(new Runnable()).start();</span></span><br><span class="line">        <span class="comment">//2.new Thread(new FutureTask&lt;V&gt;(Callable)).start();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>().start();<span class="comment">//怎么启动</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(myThread); <span class="comment">//适配类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> (String) futureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li>有缓存</li><li>结果可能需要等待，会阻塞</li></ol><h2 id="8-常用的辅助类"><a href="#8-常用的辅助类" class="headerlink" title="8.常用的辅助类"></a>8.常用的辅助类</h2><h3 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h3><p><img src="/2022/05/17/JUC/image-20210623110521611-1624417522603.png" alt="image-20210623110521611"></p><p><strong>计数辅助类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//总数是6,必须要执行任务的手，再使用</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;GO OUT&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();<span class="comment">//数量减一</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//等待计数器归零，然后再向下执行</span></span><br><span class="line"><span class="comment">//        countDownLatch.countDown();//-1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Closed door&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>&#x3D;&#x3D;countDownLatch.countDown();&#x3D;&#x3D;&#x2F;&#x2F;数量减一</p><p>&#x3D;&#x3D;countDownLatch.await();&#x3D;&#x3D;&#x2F;&#x2F;等待计数器归零，然后再向下执行</p><p>每次有线程调用countDown()数据量-1，假设计数器变为0，countDownLatch.await()就会被唤醒，继续执行。</p><h3 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h3><p><img src="/2022/05/17/JUC/image-20210623113200827-1624419127855.png" alt="image-20210623113200827"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//lambda能拿到i吗</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;收集&quot;</span>+temp+<span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Semaphore"><a href="#8-3-Semaphore" class="headerlink" title="8.3 Semaphore"></a>8.3 Semaphore</h3><p>semaphore:信号量</p><p><img src="/2022/05/17/JUC/image-20210623113953458-1624419594670.png" alt="image-20210623113953458"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//线程数量，停车位！限流！</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//acquire()得到</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//release()释放</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>&#x3D;&#x3D;semaphore.acquire();&#x3D;&#x3D;获得，假设如果已经满了，等待，等待被释放为止！</p><p>&#x3D;&#x3D;semaphore.release();&#x3D;&#x3D;  释放 ，会将当前的信号量释放+1，然后唤醒等待的线程！</p><p>作用：多个共享资源互斥的使用！并发限流！</p><h2 id="9-读写锁"><a href="#9-读写锁" class="headerlink" title="9.读写锁"></a>9.读写锁</h2><p>&#x3D;&#x3D;ReadWriteLock&#x3D;&#x3D;</p><p><img src="/2022/05/17/JUC/image-20210623120523436-1624421126081.png" alt="image-20210623120523436"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        MyCache myCache = new MyCache();</span></span><br><span class="line">        <span class="type">MyCache2</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache2</span>();</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.put(temp+<span class="string">&quot;&quot;</span>,temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.get(temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache2</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存，写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,Object val)</span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入&quot;</span>+key);</span><br><span class="line">            map.put(key,val);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入完毕&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取，读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取&quot;</span>+key);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存，写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,Object val)</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入&quot;</span>+key);</span><br><span class="line">        map.put(key,val);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取，读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取&quot;</span>+key);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-阻塞队列"><a href="#10-阻塞队列" class="headerlink" title="10.阻塞队列"></a>10.阻塞队列</h2><p>阻塞队列：BlockingQueue<E></E></p><p><img src="/2022/05/17/JUC/image-20210623152851695-1624433333035.png" alt="image-20210623152851695"></p><p><img src="/2022/05/17/JUC/image-20210623153243151-1624433564002.png" alt="image-20210623153243151"></p><p>BlockingQueue不是新东西</p><p>什么情况下会使用阻塞队列：多线程并发处理、线程池。</p><p>队列使用：</p><table><thead><tr><th align="center">方式</th><th align="center">抛出异常</th><th align="center">有返回值，不抛出异常</th><th align="center">阻塞等待</th><th align="center">超时等待</th><th></th></tr></thead><tbody><tr><td align="center">添加</td><td align="center">add</td><td align="center">offer</td><td align="center">put</td><td align="center">offer(“d”,2,TimeUnit.SECONDS)</td><td></td></tr><tr><td align="center">移除</td><td align="center">remove</td><td align="center">poll</td><td align="center">take</td><td align="center">blockingQueue.poll(2,TimeUnit.SECONDS)</td><td></td></tr><tr><td align="center">检测队首元素</td><td align="center">element</td><td align="center">peek</td><td align="center">-</td><td align="center">-</td><td></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><ol><li>抛出异常</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IllegalStateException: Queue full</span></span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.add(&quot;d&quot;));</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//java.util.NoSuchElementException</span></span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.remove());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>不会抛出异常</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.peek());</span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.offer(&quot;d&quot;));//false，不抛出异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.poll());//null,不抛出异常</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>阻塞等待</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//一直阻塞</span></span><br><span class="line">    blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="comment">//blockingQueue.put(&quot;d&quot;);//队列没有位置了，一直阻塞</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());<span class="comment">//没有元素了，一直阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>超时等待</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//一直阻塞</span></span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;d&quot;</span>,<span class="number">2</span>,TimeUnit.SECONDS);<span class="comment">//两秒后超时推出</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS));<span class="comment">//两秒后超时推出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SynchronizedQueue  同步队列</p></blockquote><p>没有容量，进去一个元素必须等待取出来之后，才能再往里边存放一个元素</p><h2 id="11-线程池（重点）"><a href="#11-线程池（重点）" class="headerlink" title="11.线程池（重点）"></a>11.线程池（重点）</h2><p>线程池：三大方法、七大参数、四种拒绝策略</p><blockquote><p>池化技术</p></blockquote><p>​    事先准备好一些资源，有人要用，就来这里拿，用完之后还给我。</p><p>线程池的好处：</p><pre><code>1. 降低资源消耗2. 提高相应速度（创建和销毁十分消耗资源）3. 方便管理</code></pre><p>&#x3D;&#x3D;<strong>线程复用、可以控制最大并发数、管理线程</strong>&#x3D;&#x3D;</p><blockquote><p>线程：三大方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Executors 工具类、三大方法</span></span><br><span class="line"><span class="comment">//使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</span></span><br><span class="line">        <span class="comment">//ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();<span class="comment">//可伸缩的线程池大小</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//线程池用完、程序结束、关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>7大参数</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质 ThreadPoolExecutor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  //核心线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,//最大核心线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,//超时了没有人调用就是释放</span></span><br><span class="line"><span class="params">                              TimeUnit unit,//超时单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,//线程工厂：创建线程的，一般不用动</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略&#123;</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个线程池</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());<span class="comment">//队列满了，尝试去和最早的竞争，也不会抛出异常</span></span><br></pre></td></tr></table></figure><blockquote><p> &#x3D;&#x3D;4种拒绝策略&#x3D;&#x3D;</p></blockquote><p><img src="/2022/05/17/JUC/image-20210623170419807-1624439061628.png" alt="image-20210623170419807"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbortPolicy();//银行满了，还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="comment">//CallerRunsPolicy());//哪来的去哪里</span></span><br><span class="line"><span class="comment">//DiscardPolicy());//队列满了，丢掉任务，不会抛出异常</span></span><br><span class="line"><span class="comment">//DiscardOldestPolicy());//队列满了，尝试去和最早的竞争，也不会抛出异常</span></span><br></pre></td></tr></table></figure><blockquote><p>IO密集型   CPU密集型(线程池的最大线程数量)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Executors 工具类、三大方法</span></span><br><span class="line"><span class="comment">//使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line"><span class="comment">//AbortPolicy();//银行满了，还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="comment">//CallerRunsPolicy());//哪来的去哪里</span></span><br><span class="line"><span class="comment">//DiscardPolicy());//队列满了，丢掉任务，不会抛出异常</span></span><br><span class="line"><span class="comment">//DiscardOldestPolicy());//队列满了，尝试去和最早的竞争，也不会抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</span></span><br><span class="line">        <span class="comment">//ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="comment">//ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的线程池大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义线程池</span></span><br><span class="line">        <span class="comment">//最大线程到底如何定义</span></span><br><span class="line">        <span class="comment">//1.CPU密集型  ，几核的CPU就是几个，可以保持CPU效率最高</span></span><br><span class="line">        <span class="comment">//2.IO密集型   ，程序有15个大型任务，io十分占用资源！判断你程序中十分耗IO的线程，设置大于他就行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cpuCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();<span class="comment">//获取CPU核数</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,</span><br><span class="line">                    <span class="number">5</span>,</span><br><span class="line">                    <span class="number">3</span>,</span><br><span class="line">                    TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                    Executors.defaultThreadFactory(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());<span class="comment">//队列满了，尝试去和最早的竞争，也不会抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//最大承载：DEQUE + MAX</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//线程池用完、程序结束、关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-四大函数式接口"><a href="#12-四大函数式接口" class="headerlink" title="12.四大函数式接口"></a>12.四大函数式接口</h2><p>新时代程序员：lambda表达式、链式编程、函数式接口、Stream流式计算</p><blockquote><p>函数式接口：只有一个方法的接口，方法是抽象的</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//超级多@FunctionalInterface</span></span><br><span class="line"><span class="comment">//简化编程模型，在西南版本的框架底层大量应用</span></span><br><span class="line"><span class="comment">//foreach (消费者类的函数式接口)</span></span><br></pre></td></tr></table></figure><img src="/2022/05/17/JUC/image-20210623172602095-1624440363998.png" alt="image-20210623172602095" style="zoom: 67%;"><p><strong>代码测试：</strong></p><p>&#x3D;&#x3D;函数式接口&#x3D;&#x3D;：</p><p><img src="/2022/05/17/JUC/image-20210623173006361-1624440607309.png" alt="image-20210623173006361"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 函数型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//工具类：输出输入的值</span></span><br><span class="line"><span class="comment">//       Function function = new Function&lt;String,String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String str) &#123;</span></span><br><span class="line"><span class="comment">//                return str;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> (Function&lt;String, String&gt;) str -&gt; str;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;adb&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/JUC/image-20210623173645917-1624441007623.png" alt="image-20210623173645917"></p><p> &#x3D;&#x3D;断定型接口：有一个输入参数，返回值只能是 布尔值&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">       <span class="comment">// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line">        <span class="comment">//    @Override</span></span><br><span class="line">        <span class="comment">//    public boolean test(String str) &#123;</span></span><br><span class="line">         <span class="comment">//       return str.isEmpty();</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">       <span class="comment">// &#125;;</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = str -&gt; str.isEmpty();</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Consumer消费型接口:只有输入，没有返回值</p></blockquote><p><img src="/2022/05/17/JUC/image-20210623174253777-1624441374663.png" alt="image-20210623174253777"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neu.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;()&#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String str) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(str);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br><span class="line">       consumer.accept(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Supplier供给型接口  没有参数，只有返回值</p></blockquote><p><img src="/2022/05/17/JUC/image-20210623182846117-1624444127530.png" alt="image-20210623182846117"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;()&#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String get() &#123;</span></span><br><span class="line"><span class="comment">//                return &quot;123&quot;;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-Stream流式计算"><a href="#13-Stream流式计算" class="headerlink" title="13.Stream流式计算"></a>13.Stream流式计算</h2><blockquote><p>什么是Stream流式计算</p></blockquote><p>​    <img src="/2022/05/17/JUC/image-20210623183613710-1624444575195.png" alt="image-20210623183613710"></p><h2 id="14-ForkJoin"><a href="#14-ForkJoin" class="headerlink" title="14.ForkJoin"></a>14.ForkJoin</h2><blockquote><p>什么是ForkJoin</p></blockquote><p>   在JDK1.7中出现，并行执行任务！提高效率</p><p>​    类似于分治算法。</p><blockquote><p> ForkJoin特点：工作窃取</p></blockquote><p>   这个里边维护的都是双端队列。</p><blockquote><p> ForkJoin操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何使用forkjoin</span></span><br><span class="line"><span class="comment"> * 1.forkJoinPool通过它来执行</span></span><br><span class="line"><span class="comment"> * 2.计算任务forkJoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * 3.计算类要继承ForkJoinTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> start,<span class="type">long</span> end)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end - start)&gt;temp)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//forkJion</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;<span class="comment">//中间值</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            task1.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle+<span class="number">1</span>, middle);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join()+task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">10_0000_0000</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;, 时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0</span>, <span class="number">10_0000_0000</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">//提交任务</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;, 时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stream并行流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0</span>,<span class="number">10_0000_0000</span>).parallel().reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;, 时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-异步回调"><a href="#15-异步回调" class="headerlink" title="15.异步回调"></a>15.异步回调</h2><blockquote><p>Future 设计的初衷：对将来的某个事件的结果进行建模</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步调用：CompletableFuture</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//没有返回值的runAysnc异步回调</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName()+&quot;runAsync=&gt;Void&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;11111111&quot;);</span></span><br><span class="line"><span class="comment">//        completableFuture.get();//阻塞获取执行结果</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;22222222&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有返回值的异步回调</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;supplyAsync=&gt;Integer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t=&gt;&quot;</span> + t);<span class="comment">//正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;u=&gt;&quot;</span> + u);<span class="comment">//错误信息：</span></span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16.JMM"></a>16.JMM</h2><blockquote><p>Volatile理解：是Java虚拟机提供的<strong>轻量级的同步机制</strong></p></blockquote><pre><code>1.  保证可见性   2.  不保证原子性    3.  禁止指令重排</code></pre><blockquote><p>JMM: java 内存模型，不存在的东西，概念，约定。</p></blockquote><p>关于JMM的同步约定：</p><ol><li>线程解锁前：必须把共享变量&#x3D;&#x3D;立刻&#x3D;&#x3D;刷回内存</li><li>线程加锁前：必须读取主存中的最新值到工作内存中。</li><li>加锁和解锁是同一把锁。</li></ol><p>线程：<strong>工作内存</strong>，<strong>主内存</strong></p><p>8种操作</p><p><img src="/2022/05/17/JUC/image-20210624110402520-1624503843536.png" alt="image-20210624110402520"></p><p><img src="/2022/05/17/JUC/image-20210624110715196.png" alt="image-20210624110715196"></p><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p><p><strong>问题</strong>：程序不知道主内存种的值已经被改了</p><h2 id="17-Volatile"><a href="#17-Volatile" class="headerlink" title="17.Volatile"></a>17.Volatile</h2><p><img src="/2022/05/17/JUC/image-20210725112623270.png" alt="image-20210725112623270"></p><blockquote><p>1.保证可见性</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMMDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//不加volatile程序就会死循环，加了保证可见性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;  <span class="comment">//线程对主内存的变化不知道的</span></span><br><span class="line">            <span class="keyword">while</span> (num ==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.不保证原子性</p></blockquote><p>原子性：不可分割</p><p>线程A在执行任务的时候，是不能被打扰的，也不能被分割；要么同时成功，要么同时失败。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不保证原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        num ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//理论上num结果为20000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123; <span class="comment">//main gc</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果不加lock和synchronized，怎么保证原子性</strong></p><p><img src="/2022/05/17/JUC/%5C62967a9e46fd38f9617b49d3b138170-1624505034784.png" alt="62967a9e46fd38f9617b49d3b138170"></p><p>使用原子类，解决原子性问题</p><img src="/2022/05/17/JUC/image-20210624112615945-1624505176922.png" alt="image-20210624112615945" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不保证原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"><span class="comment">//    private volatile static AtomicInteger num = 0;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        num ++;//不是一个原子性操作</span></span><br><span class="line">        num.getAndIncrement();<span class="comment">//原子性的+1方法，底层用到CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//理论上num结果为20000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123; <span class="comment">//main gc</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些类的底层都直接和操作系统挂钩。</p><blockquote><p>&#x3D;&#x3D;指令重排：&#x3D;&#x3D;写的程序，计算机并不是按照写的那样去执行。</p></blockquote><p>源代码—-&gt;  编译器优化的重排 —&gt;  指令并行也可能回重排 —-&gt;    内存系统也会重排—-&gt; 执行</p><p>&#x3D;&#x3D;处理器在进行指令重排的手，考虑：数据之间的依赖性&#x3D;&#x3D;</p><p><strong>volatile可以避免指令重排</strong>：由于内存屏障。</p><h2 id="18-单例模式"><a href="#18-单例模式" class="headerlink" title="18.单例模式"></a>18.单例模式</h2><blockquote><p> 饿汉式、</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    <span class="comment">//可能回浪费空间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DCL懒汉式、</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neu.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lazyMan != <span class="literal">null</span>)&#123;<span class="comment">//防止反射破坏</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式的  饿汉式单例 = DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>)&#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();<span class="comment">//不是原子性操作</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 1.分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2.执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3.把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                LazyMan.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> LazyMan.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射可以破坏单例</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态内部类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neu.single;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">HOLDER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neu.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//enum 是什么：本身是一个Class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        <span class="comment">// java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-CAS"><a href="#19-CAS" class="headerlink" title="19.CAS"></a>19.CAS</h2><blockquote><p>什么是CAS</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS  compareAndSet比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span>  <span class="variable">atomicInteger</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2021</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//期望、更新</span></span><br><span class="line">        <span class="comment">//public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//如果期望的值达到了，就更新，否则不更新,CAS是CPU的并发原语</span></span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">2021</span>,<span class="number">2022</span>);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Unsafe类</p></blockquote><p><img src="/2022/05/17/JUC/image-20210624144406829-1624517048707.png" alt="image-20210624144406829"></p><p><img src="/2022/05/17/JUC/image-20210624145003276-1624517404681.png" alt="image-20210624145003276"></p><p> CAS:比较当前工作内存中的值和主内存种的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环。</p><p><strong>缺点：</strong></p><ol><li>循环耗时</li><li>一次性只能保证一个共享变量的原子性</li><li>存在ABA问题</li></ol><blockquote><p>CAS:ABA问题（狸猫换太子）</p></blockquote><p><img src="/2022/05/17/JUC/481034a168cb89fe0e7f3146c649e8d-1624517652114.png" alt="481034a168cb89fe0e7f3146c649e8d"></p><h2 id="20-原子引用"><a href="#20-原子引用" class="headerlink" title="20.原子引用"></a>20.原子引用</h2><p>带版本号的原子操作 &#x3D;&#x3D;解决ABA问题&#x3D;&#x3D;：对应的思想：乐观锁</p><p><img src="/2022/05/17/JUC/1034a56ca844ced56d5fd27411ac261-1624519485524.png" alt="1034a56ca844ced56d5fd27411ac261"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neu.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS  compareAndSet比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span>  <span class="variable">atomicInteger</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2021</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//期望、更新</span></span><br><span class="line">        <span class="comment">//public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//如果期望的值达到了，就更新，否则不更新,CAS是CPU的并发原语</span></span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">2021</span>,<span class="number">2022</span>);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">        <span class="comment">//原子引用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();<span class="comment">//基本类</span></span><br><span class="line">        AtomicStampedReference&lt;Object&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//带时间的</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();<span class="comment">//获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a1=&gt;&quot;</span>+stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//version + 1</span></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;a2=&gt;&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;a3=&gt;&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//乐观锁的原理一样</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();<span class="comment">//获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;b1=&gt;&quot;</span>+stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">66</span>,</span><br><span class="line">                    stamp, stamp + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;b2=&gt;&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-各种锁的理解"><a href="#21-各种锁的理解" class="headerlink" title="21.各种锁的理解"></a>21.各种锁的理解</h2><h3 id="1-公平锁、非公平锁"><a href="#1-公平锁、非公平锁" class="headerlink" title="1.公平锁、非公平锁"></a>1.公平锁、非公平锁</h3><p>公平锁：不能插队，先来后到</p><p>非公平锁：可以插队，默认的是他</p><h3 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h3><p>可重入锁（递归锁）</p><h2 id="22-synchronized与volatile对比"><a href="#22-synchronized与volatile对比" class="headerlink" title="22.synchronized与volatile对比"></a>22.synchronized与volatile对比</h2><p><img src="/2022/05/17/JUC/image-20210725111610271.png" alt="image-20210725111610271"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/05/17/redis/"/>
      <url>/2022/05/17/redis/</url>
      
        <content type="html"><![CDATA[<h4 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h4><h5 id="为什么要用Nosql"><a href="#为什么要用Nosql" class="headerlink" title="为什么要用Nosql"></a>为什么要用Nosql</h5><blockquote><p>1、单机MYSQL的年代</p></blockquote><ul><li>数据量如果太大，一个机器放不下了</li><li>数据的索引（B + Tree）,一个机器内存也放不下</li><li>访问量（读写混合），一个服务器承受不了</li></ul><p><img src="/2022/05/17/redis/image-20210602111138714.png" alt="image-20210602111138714"></p><p>出现以上三种情况之一，就必须要晋级</p><blockquote><p>2、Memacshed(缓存) + MYSQL + 垂直拆分（读写分离）</p></blockquote><p>希望减轻服务器的压力、使用缓存来保证效率</p><p>发展过程：优化数据结构和索引 —&gt; 文件缓存（IO） –&gt; Memcacahed(当时最热门的技术)</p><blockquote><p>3、分库分表+水平拆分+MYSQL集群</p></blockquote><blockquote><p>4、如今时代</p></blockquote><ul><li>MYSQL等关系型数据库就不够用了！数据量很多 </li><li>MYSQL有的使用它来存储一些较大的文件，博客，图片！数据表很大，效率就低了！如果有一种数据库来专门处理这种数据，MySQL的压力就小了</li></ul><blockquote><p>5.目前的互联网项目</p></blockquote><p><img src="/2022/05/17/redis/image-20210602110847515.png" alt="image-20210602110847515"></p><blockquote><p>为什么用NoSQL</p></blockquote><p>用户的个人信息、社交网络、地理位置。用户自己产生的数据、用户日志等等爆发式增长。</p><p>这时候我们就需要使用NoSQL数据库，NoSQL可以很好的处理以上的情况。</p><h5 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h5><blockquote><p>NoSQL</p></blockquote><p>NoSQL &#x3D;  Not Only SQL(不仅仅是SQL)</p><p>关系型数据库：表格、行、列。</p><p>泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代。尤其是超大规模的高并发社区。</p><p>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！</p><p>不需要多余的操作就可以横向扩展的！Map&lt;String,Object&gt;使用键值对来控制！</p><blockquote><p>NoSQL特点</p></blockquote><ul><li>方便扩展（数据之间没有关系，很好扩展）</li><li>大数据量高性能（Redis一秒写8万次，读取11万一秒，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</li><li>数据类型是多样型的（不需要事先设计数据库。随去随用。如果数据库十分大的表，很多人就无法设计了）</li><li>传动的关系型数据库（RDBMS）和NoSQL</li></ul><blockquote><p>传统的RDBMS</p><ul><li>结构化祖师</li><li>SQL</li><li>数据和关系都存在单独的表中</li><li>数据操作语言，数据定义语言</li><li>严格的一致性</li><li>基础的事务</li></ul></blockquote><blockquote><p>NoSQL</p><ul><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储，列存储，文档存储，图形数据库（社交关系）</li><li>最终一致性</li><li>CAP定理和BASE(异地多活)</li><li>高新能、高可用、高可扩展性</li></ul></blockquote><h5 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h5><p><img src="/2022/05/17/redis/image-20210602120705404.png" alt="image-20210602120705404"></p><h5 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h5><p><strong>KV键值对</strong></p><ul><li>新浪：Redis</li><li>美团：Redis + Tair</li><li>阿里，百度：Redis + memcache</li></ul><p><strong>文档型数据库（bson格式）</strong></p><ul><li>MongoDB(一般必须要掌握)<ul><li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关心性数据库中功能最丰富，最像关系型数据库的！</li></ul></li></ul><p><strong>列存储数据库</strong></p><ul><li>HBase</li><li>分布式文件系统</li></ul><p><strong>图关系数据库</strong></p><ul><li>不是存图形的，放的是关系。如：朋友圈社交网络，广告推荐</li></ul><p><strong>对比</strong></p><p><img src="/2022/05/17/redis/image-20210602121947362.png" alt="image-20210602121947362"></p><h4 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p>Redis是什么？</p></blockquote><p>Redis(Remote Dictionary Server),远程字典服务</p><blockquote><p>Redis能做什么？</p></blockquote><ul><li>内存存储、持久化，内存中是断电丢失、所以说持久化很重要（rdb,aof）</li><li>小路高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量）</li></ul><blockquote><p>特性</p></blockquote><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事物</li></ul><blockquote><p>学习中需要用到的东西</p></blockquote><ul><li>官网：<a href="https://redis.io/">https://redis.io/</a></li><li>中文网：<a href="https://www.redis.cn/">https://www.redis.cn/</a></li><li>下载地址：</li></ul><h5 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h5><ul><li>1.下载安装包</li></ul><p><img src="/2022/05/17/redis/image-20210602144746430.png" alt="image-20210602144746430"></p><h5 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h5><p><img src="/2022/05/17/redis/image-20210603190644081.png" alt="image-20210603190644081"></p><p><img src="/2022/05/17/redis/image-20210603195130190.png" alt="image-20210603195130190"></p><p><img src="/2022/05/17/redis/image-20210603195512417.png" alt="image-20210603195512417"></p><p><img src="/2022/05/17/redis/image-20210603195553950.png" alt="image-20210603195553950"></p><p>5.redis的默认安装路径 <code>/usr</code>下面</p><p><img src="/2022/05/17/redis/image-20210603195823324.png" alt="image-20210603195823324"></p><p>6.将redis配置文件复制到当前目录下</p><p><img src="/2022/05/17/redis/image-20210603200133459.png" alt="image-20210603200133459"></p><p>7.redis默认不知后台启动的，需要修改配置文件<code>vim redis.conf</code> </p><p><img src="/2022/05/17/redis/image-20210603200452315.png"></p><p>8.启动redis服务</p><p><img src="/2022/05/17/redis/image-20210603200622845.png" alt="image-20210603200622845"></p><p>9.使用redis客户端连接</p><p><img src="/2022/05/17/redis/image-20210603200835121.png" alt="image-20210603200835121"></p><p>10.查看redis进程是否开启</p><p>![image-20210603200959309](<br>11.关闭redis服务</p><p><img src="/2022/05/17/redis/image-20210603201102943.png" alt="image-20210603201102943"></p><h5 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h5><p><strong>redis-benchmark</strong>是一个压力测试工具！</p><p>官方自带的性能测试工具</p><p>redis-benchmark命令参数</p><p><img src="/2022/05/17/redis/image-20210604140602063.png" alt="image-20210604140602063"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试：100各并发连接 10000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 10000</span><br></pre></td></tr></table></figure><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>redis默认有16个数据库</p><p><img src="/2022/05/17/redis/image-20210604141851021.png" alt="image-20210604141851021"></p><p>默认使用的第0个数据库，可以使用select进行切换数据库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3<span class="comment">#切换数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize<span class="comment">#查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *<span class="comment">#查看所有key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; flushdb<span class="comment">#清空数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushall  <span class="comment">#清空全部数据库</span></span><br></pre></td></tr></table></figure><blockquote><p>Redis 是单线程</p></blockquote><p>Redis是基于内存操作，CUP不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就是用单线程了。</p><p><strong>Redis为什么是单线程的还这么快</strong></p><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CUP上下文会切换！）一定比单线程效率高？</li></ul><p>核心：redis是将所有的数据都放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p><h4 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h4><h5 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name chuchu</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">3) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line">5) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; expire name 60<span class="comment">#设置name的过期时间？</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ttl anme</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name<span class="comment">#查看key的类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> ange<span class="comment">#查看key的类型</span></span><br><span class="line">none</span><br></pre></td></tr></table></figure><h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; append key1 hello<span class="comment">#append命令，向字符串尾部追加字符串。如果key不存在，就会新建这个key</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen key1<span class="comment">#获取字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;,world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello,world&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0<span class="comment">#初始浏览量为0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views<span class="comment"># 每次加1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views<span class="comment">#每次减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby views 10<span class="comment">#加10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; decrby views 5<span class="comment">#减5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;get&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment">#字符串范围 range</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 3<span class="comment">#截取字符串[0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1<span class="comment">#获取全部字符串</span></span><br><span class="line"><span class="string">&quot;hello,world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#替换</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 xx<span class="comment">#替换 1 索引位置的bc 为 xx</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;axxdefg&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment">#setex (set with expire)#设置过期时间</span></span><br><span class="line"><span class="comment">#setnx (set if not exist)#不存在设置（在分布式锁中会常常使用）</span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 <span class="string">&quot;hello&quot;</span><span class="comment">#设置key3的值为&quot;hello&quot;，30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;redis&quot;</span><span class="comment">#mykey不存在时设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key2&quot;</span></span><br><span class="line">2) <span class="string">&quot;mykey&quot;</span></span><br><span class="line">3) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx key3 <span class="string">&quot;MongDB&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SETNX mykey <span class="string">&quot;mongdb&quot;</span><span class="comment">#mykey存在时设置失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment">#mset #批量设置</span></span><br><span class="line"><span class="comment">#mget #批量获取</span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k5 v5<span class="comment">#msetnx 批量不存在时设置，要么一起成功，要么一起失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="built_in">set</span> user:1 &#123;name:zhangsan,age:3&#125; <span class="comment">#设置一个user:1对象  值为json字符串来保存一个对象</span></span><br><span class="line"><span class="comment">#这里的key时巧妙的设计：  user:&#123;id&#125;:&#123;filed&#125;,如此设计</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line">getset <span class="comment">#先get后set</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getset db redis<span class="comment">#如果不存在值，返回null,如果存在值返回db</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb<span class="comment">#如果存在值，获取原来的值，并设置新的值</span></span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String类似的使用场景：value除了时字符串还可以时数组</p><ul><li>计数器</li><li>统计多单位的数量</li></ul><hr><h5 id="List-列表"><a href="#List-列表" class="headerlink" title="List (列表)"></a>List (列表)</h5><p>基本的数据类型，列表</p><p>在redis中可以将list用成<strong>栈、队列、阻塞队列</strong></p><p>所有的list命令都是<strong>L</strong>开头的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one<span class="comment">#将一个值或多个值插入列表的头部（左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1<span class="comment">#获取list中的值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list four<span class="comment">#将一个值或多个值插入列表的尾部（右）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list <span class="comment">#移除左边的值</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list<span class="comment">#移除右边的值</span></span><br><span class="line"><span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">lindex <span class="comment">#获取索引对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1<span class="comment">#通过下标获取某一个值</span></span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">llen <span class="comment">#获取list长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen list<span class="comment">#返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">移除指定的值</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 three<span class="comment">#移除list中指定个数的value,精确匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">trim 修剪：list 截断</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello2&quot;</span> <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2<span class="comment">#通过下标截取指定的长度，这个list已经被改变了，只剩下截取的元素了</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">rpoplpush<span class="comment">#移除列表最后一个元素，并且将它添加到另一个元素并返回</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span> <span class="string">&quot;hello1&quot;</span> <span class="string">&quot;hello2&quot;</span> <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist<span class="comment">#移除mylist最后一个元素，并且将它添加到myotherlist中并返回</span></span><br><span class="line"><span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello3&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">lset  <span class="comment">#将列表指定索引处设置元素值（替换）</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">linsert <span class="comment">#在某个元素的前面或者后面插入一个值</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before <span class="string">&quot;world&quot;</span> <span class="string">&quot;other&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after <span class="string">&quot;world&quot;</span> <span class="string">&quot;new&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">4) <span class="string">&quot;new&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>他实际是一个链表，before node after,left  ,right都可以插入值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高。中间元素，相对来说效率会低一点。</li></ul><p>消息排队！消息队列 (lpush rpop )，栈（lpush,lpop）.</p><hr><h5 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h5><p>set中的值不能重复</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;world&quot;</span> <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello<span class="comment">#判断某个值是不是在set中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset <span class="comment">#获取set中元素的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset <span class="string">&quot;hello&quot;</span><span class="comment">#移除某个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="built_in">set</span> 无序不重复集合</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset<span class="comment">#随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2<span class="comment">#随机抽选出两个元素</span></span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span> <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">删除指定的key,随机删除key</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset<span class="comment">#随机删除集合中的一些元素</span></span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">将一个指定的值，移动到另一个集合中</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span> <span class="string">&quot;nihao&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 hello<span class="comment">#将myset中的hello移动到myset2中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;nihao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">微博，b站，共同关注（交集）</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 c d </span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2<span class="comment">#查看不同的</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2<span class="comment">#查看相同的（交集）</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sunion key1 key2<span class="comment">#并集</span></span><br><span class="line">1) <span class="string">&quot;d&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微博，A用户将所有关注的人放在一个set集合中。将它的粉丝也放在一个集合中。</p><h5 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h5><hr><p>Map集合，key-map!这时候这个值是一个map集合！本质与String类型没有太大区别，还是一个简单的key-value.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 chuchu<span class="comment">#往map里添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1<span class="comment">#获取元素</span></span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<span class="comment">#一次添加多个</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2<span class="comment">#一次获取多个</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash<span class="comment">#获取全部</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field2<span class="comment">#删除指定的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash </span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">获取长度</span><br><span class="line">hlen</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field3 hello field4 redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash<span class="comment">#获取字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field3&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">5) <span class="string">&quot;field4&quot;</span></span><br><span class="line">6) <span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget myhash field3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">判断某个值是否存在</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field<span class="comment">#判断field是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">#只获得所有的字段</span></span><br><span class="line"><span class="comment">#只获得所有的值</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash<span class="comment">#获取所有的字段key</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;field3&quot;</span></span><br><span class="line">3) <span class="string">&quot;field4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash<span class="comment">#获取所有的值value</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">#incr decr</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field 6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field 2<span class="comment">#增加2</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 9<span class="comment">#不存在时设置自动为9，如果已经存在就不成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field7 2<span class="comment">#不存在时设置自动为9，如果不存在就成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><hr><h5 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h5><p>在set的基础上，增加了一个值，set k1 v1 &#x3D;&gt; zset k1 score v1</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 zhangsan 5000 wangsi 500 liwu</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf<span class="comment">#从最小值到最大值排序</span></span><br><span class="line">1) <span class="string">&quot;liwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1<span class="comment">#从最大值到最小值排序</span></span><br><span class="line">1) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores<span class="comment">#加上key</span></span><br><span class="line">1) <span class="string">&quot;liwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">移除rem中的元素</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;liwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary liwu<span class="comment">#移除指定集合中的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary<span class="comment">#获取集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello 2 world 3 chuchu 4 dedi</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3<span class="comment">#获取指定区间内的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h4><h5 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h5><hr><blockquote><p>geoadd</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#geoadd 添加地理位置</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing <span class="comment">#添加城市数据</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai 106.50 29.53 chongqing 114.05 22.52 shenzhen</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>geopos</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing chongqing<span class="comment">#获取指定城市的经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>geodist</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city chongqing xian<span class="comment">#获取重庆 西安之间的距离</span></span><br><span class="line"><span class="string">&quot;575046.9885&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city chongqing xian km<span class="comment">#获取重庆 西安之间的距离 km</span></span><br><span class="line"><span class="string">&quot;575.0470&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>我附近的人？（获得所有附近的人的地址，定位）通过半径来查询</p><p>georadius:以给定的经纬度为中心，查询某一半径内的元素</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km<span class="comment">#以经纬度110 30 为中心寻找方圆1000km的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord<span class="comment">#把经纬度一块查出来</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 1<span class="comment">#限制查询多少个</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>georadiusbymember :以给定的元素为中心，寻找</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city shanghai 300 km<span class="comment">#找出以上海为中心，300km内的城市</span></span><br><span class="line">1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>geo 底层的实验原理其实就是zset，我们可以使用zset命令来操作geo!</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1<span class="comment">#查看地图中全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing<span class="comment">#移除特定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><hr><h5 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h5><blockquote><p>什么是基数？</p></blockquote><p>A{1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（不重复的元素） &#x3D; 5，可以接受误差。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd myset a b c d e f g h i j<span class="comment">#创建第一组元素myset</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount myset<span class="comment">#统计myset元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; pfadd myset2 i j k z x c v b n m<span class="comment">#创建第二组元素myset2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount myset2</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey3 myset myset2<span class="comment">#合并两个元素 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br></pre></td></tr></table></figure><p>如果允许容错，可以使用hyperloglog;如果不允许容错，使用set</p><hr><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><blockquote><p>位存储</p></blockquote><p>统计疫情感染人数：0 1 0 1</p><p>统计用户信息，活跃，不活跃！登录，未登录！两个状态的都可以使用bitmaps</p><p>Bitmaps位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态！</p><p>365天&#x3D; 365 bit    1字节&#x3D; 8 bit  46个字节左右</p><p>使用bitmap记录周一到周日的打卡！</p><p>周一：1  周二 ：0  周三 0  周四：1 ………</p><p><img src="/2022/05/17/redis/image-20210604222909632.png" alt="image-20210604222909632"></p><p>查看某一个是否有打卡：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>统计操作，统计打卡的天数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign 0 3  <span class="comment">#查看0-3天的打卡记录（可以忽略最后两个参数）</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>要么同时成功，要么同时失败，原子性！</p><p><strong>redis单条命令是保证原子性的，但redis的事务是不保证原子性的！</strong></p><p>redis事务本质：一组命令的集合！一个事务中的所有米杠零都会被序列化，在事务执行国策和观念中，会按照顺序执行！</p><p>一次性、顺序性、排他性！</p><p><strong>redis没有隔离级别的概念</strong></p><p>所有的命令在食物中，并没有直接被执行！只有发起执行名命令的之后才会执行！Exec</p><p>redis的事务：</p><ul><li>开启事务（）</li><li>命令入队（）</li><li>执行事务（）</li></ul><blockquote><p>正常执行事务：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1<span class="comment">#命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard<span class="comment">#放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4<span class="comment">#事务队列中的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>编译型异常（代码有问题！命令有错！），事务中所有的命令都不会被执行!</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; getset k3<span class="comment">#错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务报错</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="comment">#所有的命令都没有执行</span></span><br></pre></td></tr></table></figure><blockquote><p>运行时异常（1&#x2F;0)，如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1<span class="comment">#执行的时候会失败</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range<span class="comment">#虽然第一条命令报错了，但是依旧执行成功了</span></span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>监控！Watch</p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，什么时候都会出问题，无论什么时候都会加锁</li></ul><p><strong>乐观锁</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据，version！</li><li>获取version</li><li>更新的时候比较version</li></ul><blockquote><p> Redis的监视测试</p></blockquote><p>正常执行成功！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#事务正常结束，数据期间没有发生变动，这个时候就正常执行成功</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>测试多线程修改值，使用watch可以当作redis的乐观锁操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment">#监视 money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行之前 ，另一个线程，修改了money,这个时候，就会导致事务执行失败。</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><hr><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>我们要使用java来操作redis</p><blockquote><p>jedis是redis官方推荐的Java连接开发工具！使用Java操作redis的中间件</p></blockquote><p>1、导入对应的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  导入jedis包  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   fastjson     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编码测试：</p><ul><li>连接数据库</li><li>操作命令</li><li>断开连接</li></ul><hr><h4 id="Springboot整合"><a href="#Springboot整合" class="headerlink" title="Springboot整合"></a>Springboot整合</h4><p>Springboot操作数据：spring-data  jpa  jdbc  mongodb  redis</p><p>springdata也是和springboot齐名的项目</p><p>说明：在springboot2.x后，原来使用的jedis被替换为了lettuce</p><p>jedis:采用直连，多个线程操作的话，是不安全的，如果想要避免，使用jedis pool连接池。更像BIO模式</p><p>lettuce:采用netty，实例可以在多个线程中共享，不存在不安全的情况，减少线程数量。更像NIO模式。</p><blockquote><p>整合测试</p></blockquote><hr><h4 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h4><hr><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><p>redis是内存数据库，如果不保存到磁盘那么一旦服务器进行退出，服务器中的数据库状态也会消失，所以redis提供了持久化的功能！</p><h5 id="rdb（redis-database"><a href="#rdb（redis-database" class="headerlink" title="rdb（redis database)"></a>rdb（redis database)</h5><blockquote><p>什么是rdb</p><p>在rdb中是做备份的。</p></blockquote><p><img src="/2022/05/17/redis/image-20210605220814251.png" alt="image-20210605220814251"></p><p>在指定的时间间隔内将内存中的数据集体快照写入磁盘，也就是行话说的Snapshot快照，他恢复时是将快照文件直接读到内存里</p><p>Redis会单独创建（fork）一子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模的数据回复，且对于数据恢复的完整性不是非常铭感，那么RDB方式要比AOF方式更加的搞笑。RDB的缺点是最后一个持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。</p><p><strong>rdb保存的文件就是dump.rdb</strong>，都是再配置文件的快照中配置的。</p><p><img src="/2022/05/17/redis/image-20210605215959106.png" alt="image-20210605215959106"></p><p><img src="/2022/05/17/redis/image-20210605220113199.png" alt="image-20210605220113199"></p><blockquote><p>触发机制</p></blockquote><p>1.save的规则满足的情况下，会自动触发rdb规则</p><p>2.执行flushall命令，也会触发rdb规则</p><p>3.退出redis,也会产生rdb文件</p><p>备份就自动生成一个dump.rdb文件</p><blockquote><p>如何恢复rdb文件</p></blockquote><p>1.将rdb文件放在redis启动目录下，redis启动的时候就会自动检测dump.rdb文件，恢复其中的数据！</p><p><img src="/2022/05/17/redis/image-20210605220725190.png" alt="image-20210605220725190"></p><p>优点：</p><p>1.适合大规模的数据恢复</p><p>2.对数据的完整性不高！</p><p>缺点：</p><p>1.需要一定的时间间隔进行操作。如果redis意外宕机了，这个最后一个修改的数据就没有了</p><p>2.frok进程的时候，会占用一定的内存。</p><h5 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h5><p>将我们的所有命令都记录下来，history,恢复的时候就把这个文件都执行一遍。</p><blockquote><p>是什么</p></blockquote><p><img src="/2022/05/17/redis/image-20210605221159230.png" alt="image-20210605221159230"></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有执行记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话根据日志文件的内容将写质量从前到后执行一次完成数据的恢复工作。</p><p><strong>AOF保存的是appendonly.aof文件</strong></p><blockquote><p>append</p></blockquote><p><img src="/2022/05/17/redis/image-20210605221453938.png" alt="image-20210605221453938"></p><p>默认是不开启的，首要手动进行配置。只需要将图片中的no改成yes即可。</p><p>重启，redis就可以生效了</p><p>如果这个aof文件有错误，这时候，redis是启动不起来的，我们需要修复这个aof文件。</p><p>redis给提供了一个工具<strong>redis-check-aof –fix</strong></p><p><img src="/2022/05/17/redis/image-20210605221951633.png" alt="image-20210605221951633"></p><p>如果文件正常，重启就可以直接恢复</p><p><img src="/2022/05/17/redis/image-20210605222035669.png" alt="image-20210605222035669"></p><blockquote><p>重写的说明</p></blockquote><p>aof默认就是文件的无限追加，文件会越来越大</p><p><img src="/2022/05/17/redis/image-20210605222459699.png" alt="image-20210605222459699"></p><p>如果文件大于64mb,就会fork一个新进程，来存储。</p><blockquote><p>优点和缺点</p></blockquote><p>优点：</p><p><img src="/2022/05/17/redis/image-20210605222146491.png" alt="image-20210605222146491"></p><ul><li>每一次修改都同步，文件的完成行会更好。</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高。</li></ul><p>缺点</p><ul><li>相对于数据文件来说，aof远远大于rdb,修复的速度比rdb慢</li><li>aof运行效率要比rdb慢，所以redis默认是rdb持久化</li></ul><p><img src="/2022/05/17/redis/image-20210605222653878.png" alt="image-20210605222653878"></p><p><img src="/2022/05/17/redis/image-20210605222710992.png" alt="image-20210605222710992"></p><hr><h4 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h4><p>Redis发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者(sub)接收消息。微信、微博、关注系统</p><p>Redis客户端可以订阅任意数量的频道。</p><p>订阅&#x2F;发布消息图：</p><p>第一个：消息发送者，第二个：i难道  第三个：消息订阅者</p><p><img src="/2022/05/17/redis/image-20210605222937453.png" alt="image-20210605222937453"></p><p>下图展示了频道channel1,以及订阅这个批到的三个客户端    cliend2  client5  client1之间的关系：</p><p><img src="/2022/05/17/redis/image-20210605223110336.png" alt="image-20210605223110336"></p><p>当有新消息通过PUBLISH命令发送给频道channel1是，这个消息就会被发送给订阅他的三个客户端：</p><p><img src="/2022/05/17/redis/image-20210605223151668.png" alt="image-20210605223151668"></p><blockquote><p>命令</p></blockquote><p><img src="/2022/05/17/redis/image-20210605223221923.png" alt="image-20210605223221923"></p><blockquote><p>测试</p></blockquote><p><img src="/2022/05/17/redis/image-20210605223513325.png" alt="image-20210605223513325"></p><p><img src="/2022/05/17/redis/image-20210605223555029.png" alt="image-20210605223555029"></p><p>使用场景：</p><ul><li>实时消息系统</li><li>实时聊天（频道当作聊天室，将信息回显给所有人）</li><li>订阅，关注系统</li></ul><p>稍微复杂的场景就会使用消息中间件做。</p><hr><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p><img src="/2022/05/17/redis/image-20210605224004576.png" alt="image-20210605224004576"></p><p><img src="/2022/05/17/redis/image-20210605224158394.png" alt="image-20210605224158394"></p><p><img src="/2022/05/17/redis/image-20210605223945161.png" alt="image-20210605223945161"></p><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@wang bin]<span class="comment"># cd /usr/local/bin/</span></span><br><span class="line">[root@wang bin]<span class="comment"># redis-server myconfig/redis.conf </span></span><br><span class="line">[root@wang bin]<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication<span class="comment">#查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#角色  master</span></span><br><span class="line">connected_slaves:0<span class="comment">#没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:2854ce507ff1f9aff323997061d3b23625d6630f</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>复制三个配置文件，然后修改对应的信息：</p><ul><li>端口</li><li>pid名字</li><li>log文件名字</li><li>dump.rdb名字</li></ul><p>修改完毕之后启动3个服务，可以通过进程查看。</p><p><img src="/2022/05/17/redis/image-20210605225646549.png" alt="image-20210605225646549"></p><h5 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h5><p><strong>默认情况下，每台Redis服务器都是主节点；</strong>一般情况下配置从机就好</p><p>认老大！一主（79）二从（80，81）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379<span class="comment">#配置为从机</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave<span class="comment">#当前角色</span></span><br><span class="line">master_host:127.0.0.1<span class="comment">#主机的信息</span></span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1c57c3653aeea15421b2823d167bafeb33328320</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"><span class="comment">#主机信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=224,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=224,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1c57c3653aeea15421b2823d167bafeb33328320</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:224</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:224</span><br></pre></td></tr></table></figure><p>真实的配置应该在配置文件中进行配置。</p><blockquote><p>细节</p></blockquote><p>主机可以写，从机布恩那个写只能读。主机的所有数据，都会被从机自动保存。</p><p><img src="/2022/05/17/redis/image-20210606123842636.png" alt="image-20210606123842636"></p><p><img src="/2022/05/17/redis/image-20210606124414757.png" alt="image-20210606124414757"></p><h4 id="哨兵模式（自动选举老大的模式）"><a href="#哨兵模式（自动选举老大的模式）" class="headerlink" title="哨兵模式（自动选举老大的模式）"></a>哨兵模式（自动选举老大的模式）</h4><hr><p><img src="/2022/05/17/redis/image-20210606124522477.png" alt="image-20210606124522477"></p><p><img src="/2022/05/17/redis/image-20210606124552896.png" alt="image-20210606124552896"></p><p><img src="/2022/05/17/redis/Cimage-20210606124640481.png" alt="image-20210606124640481"></p><p><img src="/2022/05/17/redis/image-20210606124712184.png" alt="image-20210606124712184"></p><p><img src="/2022/05/17/redis/image-20210606125014448.png" alt="image-20210606125014448"></p><p><img src="/2022/05/17/redis/image-20210606125528056.png" alt="image-20210606125528056"></p><p><img src="/2022/05/17/redis/image-20210606125421955.png" alt="image-20210606125421955"></p><p><img src="/2022/05/17/redis/image-20210606125552003.png" alt="image-20210606125552003"></p><p><img src="/2022/05/17/redis/image-20210606125658591.png" alt="image-20210606125658591"></p><p><img src="/2022/05/17/redis/image-20210606125811111.png" alt="image-20210606125811111"></p><hr><h4 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h4><h5 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h5><p><img src="/2022/05/17/redis/image-20210606130057642.png" alt="image-20210606130057642"></p><p><img src="/2022/05/17/redis/image-20210606130334389.png" alt="image-20210606130334389"></p><p><img src="/2022/05/17/redis/image-20210606130406045.png"></p><h5 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h5><p><img src="/2022/05/17/redis/image-20210606130504240.png" alt="image-20210606130504240"></p><p><img src="/2022/05/17/redis/Cimage-20210606130645085.png" alt="image-20210606130645085"></p><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p><img src="/2022/05/17/redis/image-20210606130812505.png" alt="image-20210606130812505"></p><p><img src="/2022/05/17/redis/image-20210606131018633.png" alt="image-20210606131018633"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2022/05/17/linux/"/>
      <url>/2022/05/17/linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2022/05/17/mysql/"/>
      <url>/2022/05/17/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL基本架构"><a href="#一、MySQL基本架构" class="headerlink" title="一、MySQL基本架构"></a>一、MySQL基本架构</h2><h3 id="1、MySQL介绍"><a href="#1、MySQL介绍" class="headerlink" title="1、MySQL介绍"></a>1、MySQL介绍</h3><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong>开源免费，默认端口号是<strong>3306</strong>。</p><p>是一个<strong>单进程多线程</strong>数据库</p><blockquote><p><strong>SQL</strong>：<strong>结构化查询语言</strong>，是一种数据库查询语言，用于<strong>对数据库进行增删改查</strong>等操作；</p><p><strong>数据库</strong>：物理操作系统文件或其他形式文件类型的集合 </p><p><strong>实例：</strong>MySQL数据库有后台线程以及一个共享内存区组成，数据库实例才是操作数据库文件的，在系统上的表现就是一个进程</p><p><strong>关系型数据库：</strong>是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一列就存放着一条数据（比如一个用户的信息）。</p></blockquote><h3 id="2、MySQL的客户端-x2F-服务器架构"><a href="#2、MySQL的客户端-x2F-服务器架构" class="headerlink" title="2、MySQL的客户端&#x2F;服务器架构"></a>2、MySQL的客户端&#x2F;服务器架构</h3><p>MySQL是一个<strong>客户端&#x2F;服务器架构</strong></p><blockquote><p>日常使用场景如下：</p><p>1、启动MySQL服务器程序</p><p>2、启动MySQL客户端程序</p><p>3、在客户端程序输入命令语句请求发到服务器端，服务器端根据请求内容处理请求并向客户端返回处理结果</p></blockquote><p><strong>客户端进程向服务器进程</strong>发送请求并得到回复的过程本质上是一个<strong>进程间通信的过程</strong>，MySQL支持三种进程间通信方式：</p><ul><li><p><strong>TCP&#x2F;IP</strong>（服务器与客户端不在同一主机中必须用）</p><p>TCP&#x2F;IP套接字方式是任何平台均提供的最常用方式</p></li><li><p><strong>命名管道和共享内存</strong>（windows环境可以用）</p></li><li><p><strong>Unix域套接字文件</strong>（类Unix环境可以用）</p></li></ul><h3 id="3、MySQL的逻辑架构（一条查询语句是如何执行的）"><a href="#3、MySQL的逻辑架构（一条查询语句是如何执行的）" class="headerlink" title="3、MySQL的逻辑架构（一条查询语句是如何执行的）"></a>3、MySQL的逻辑架构（一条查询语句是如何执行的）</h3><p>MySQL的逻辑架构如下：大致分为<strong>Server层和存储引擎层</strong></p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等；<strong>存储引擎层负责数据的存储和提取。其架构模式是插件式</strong>的，支持 InnoDB（默认）、MyISAM、Memory 等多个存储引擎。</p><img src="/2022/05/17/mysql/image-20210516155741654.png" alt="image-20210516155741654" style="zoom:80%;"><h4 id="（1）连接器"><a href="#（1）连接器" class="headerlink" title="（1）连接器"></a>（1）<strong>连接器</strong></h4><p>负责<strong>与客户端建立连接、获取权限、维持和管理连接</strong>，在完成经典的 TCP 握手后，连接器就要开始认证你的身份（用户名和密码），若正确，回到<strong>权限表查出你拥有的权限</strong>。</p><blockquote><p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。</p></blockquote><p>连接完成后若长时间空闲，默认是8小时，连接器会自行与客户端断开连接。</p><p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则<strong>一直使用同一个连接</strong>。<strong>短连接</strong>则是指每次<strong>执行完很少的几次查询就断开</strong>连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<strong>建议尽量使用长连接</strong>。</p><blockquote><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉，从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol></blockquote><h4 id="（2）查询缓存（8-0版本已删掉）"><a href="#（2）查询缓存（8-0版本已删掉）" class="headerlink" title="（2）查询缓存（8.0版本已删掉）"></a>（2）<strong>查询缓存</strong>（8.0版本已删掉）</h4><p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果能在缓存中找到 key，即查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>多数情况下会建议不要使用查询缓存</strong></p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了<strong>额外的开销：每次查询后都要做一次缓存操作，失效后还要销毁</strong>。</p><p>查询缓存的失效非常频繁，<strong>只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。对于更新压力大的数据库来说，查询缓存的命中率会非常低。<strong>除非你的业务就是有一张静态表（例如系统配置表）</strong>，很长时间才会更新一次。</p><h4 id="（3）分析器"><a href="#（3）分析器" class="headerlink" title="（3）分析器"></a>（3）<strong>分析器</strong></h4><p>MySQL 需要知道你要做什么，因此需要对 <strong>SQL 语句做解析</strong>。</p><p>首先做“<strong>词法分析”，识别出字符串的内容分别代表什么</strong>；其次做“<strong>语法分析</strong>”，判断输入的这个 SQL 语句<strong>是否满足 MySQL 语法</strong>。</p><h4 id="（4）优化器"><a href="#（4）优化器" class="headerlink" title="（4）优化器"></a>（4）<strong>优化器</strong></h4><p>MySQL需要知道该怎么做。</p><p>优化的结果就是<strong>生成一个执行计划</strong>，这个执行计划表明了<strong>应该使用哪些索引进行查询，表之间的连接顺序是啥样的</strong>。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划</p><h4 id="（5）执行器"><a href="#（5）执行器" class="headerlink" title="（5）执行器"></a>（5）<strong>执行器</strong></h4><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，<strong>开始执行语句</strong>。</p><p>开始执行的时候，要先判断一下你对这个表<strong>有没有执行查询的权限</strong>，若有则<strong>调用存储引擎查询结果并将结果集返回给客户端</strong></p><h3 id="4、日志系统（一条更新语句如何执行）"><a href="#4、日志系统（一条更新语句如何执行）" class="headerlink" title="4、日志系统（一条更新语句如何执行）"></a>4、日志系统（一条更新语句如何执行）</h3><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和bin log（归档日志）</p><h4 id="（1）redo-log（重做日志）"><a href="#（1）redo-log（重做日志）" class="headerlink" title="（1）redo log（重做日志）"></a>（1）redo log（重做日志）</h4><p>MySQL更改数据的时候，之所以不直接写磁盘文件中的数据，主要因为<strong>直接写磁盘文件是随机写</strong>，开销大性能低。所以先在内存中对数据进行更改，再由后台线程<strong>异步刷新到磁盘</strong>（一般等空闲时）。为<strong>防止断电重启丢失内存内容</strong>，所以还需要加上写日志这个步骤，万一断电重启，还能通过日志中的记录进行恢复。</p><p><strong>写日志到磁盘是顺序写</strong>，相比随机写开销更小，能提升语句执行的性能</p><p>这个技术就是<strong>WAL(Write Ahead Log)技术</strong>，也称为<strong>日志先行</strong>的技术，指的是对数据文件进行修改前，必须将修改先记录日志。保证了数据<strong>一致性</strong>和<strong>持久性</strong>，并且提升语句执行性能。</p><p>有了 redo log，事务提交过程中任何阶段，MySQL突然奔溃，<strong>重启后都能保证事务的持久性，已提交的数据不会丢失</strong>，这个能力称为<strong>crash-safe</strong>。</p><p>redo log记录的是数据库中<strong>每个页的修改</strong>，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页（恢复数据页，只能恢复到最后一次提交的位置，因为修改会覆盖之前的）。</p><p>redo log<strong>固定大小</strong>，只能<strong>循环写</strong>，从头开始写，写到末尾就又回到开头，<strong>相当于一个环形</strong>。当日志写满了，就需要对<strong>旧的记录进行擦除</strong>，但在擦除之前，需要确保这些要被擦除记录对应在内存中的数据页都已经刷到磁盘中了。在redo log满了到擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求，所以有可能会导致MySQL卡顿。（所以针对<strong>并发量大的系统</strong>，适当设置<strong>redo log的文件大小非常重要</strong>）</p><h4 id="（2）bin-log（归档日志）"><a href="#（2）bin-log（归档日志）" class="headerlink" title="（2）bin log（归档日志）"></a>（2）bin log（归档日志）</h4><p>binlog（归档日志）是MySQL的 Server 层的日志 ，主要记录用户对<strong>数据库操作的SQL语句</strong>（除了查询语句），之所以称为归档日志，是因为不想redo log会擦掉之前的记录而是一直记录，主要用作<strong>主从同步</strong>和数据库<strong>基于某时间点的还原</strong>。（即主从模式下是必须的，若单机模式下，可视情况而定）</p><p>这两种日志有以下三点不同。</p><ol><li><strong>redo log 是 InnoDB 引擎</strong>特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是<strong>物理日志</strong>，记录的是“在<strong>某个数据页上做了什么修改</strong>”；binlog 是<strong>逻辑日志</strong>，记录的是这个<strong>语句的原始逻辑</strong>，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>两种日志<strong>写入磁盘的时间点</strong>不同，redolog在事务进行中不断地被顺序写入，而binlog只在事务提交时写入一次。</li><li><strong>redo log 是循环写的，空间固定会用完</strong>；binlog 是可以追加写入的。<strong>“追加写</strong>”是指 binlog 文件写到一定大小后会切换到下一个，并<strong>不会覆盖以前的日志</strong>。</li></ol><p><strong>MySQL能够恢复到任意时间点的状态就是依赖binlog实现</strong></p><blockquote><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul></blockquote><h4 id="（3）为什么bin-log没有crash-safe"><a href="#（3）为什么bin-log没有crash-safe" class="headerlink" title="（3）为什么bin log没有crash-safe"></a>（3）为什么bin log没有crash-safe</h4><p>当数据库 crash 后，想要恢复<strong>未刷盘但已经写入 redo log 和 binlog 的数据</strong>到内存时，binlog 是无法恢复的。虽然 <strong>binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有</strong>。而 redo log 不一样，<strong>只要刷入磁盘的数据，都会从 redo log 中抹掉</strong>，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</p><blockquote><p>举个栗子，binlog 记录了两条日志：</p><p>给 ID&#x3D;2 这一行的 c 字段加1<br>给 ID&#x3D;2 这一行的 c 字段加1</p><p>在记录1刷盘后，记录2未刷盘时，数据库 crash。重启后，只通过 binlog 数据库无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘</p></blockquote><h4 id="（4）undo-log回滚日志"><a href="#（4）undo-log回滚日志" class="headerlink" title="（4）undo log回滚日志"></a>（4）undo log回滚日志</h4><p>主要就是提供了<strong>回滚</strong>的作用，但其还有另一个主要作用，就是<strong>多版本并行控制(MVCC)，保证事务的原子性</strong>。在数据修改的流程中，会记录一条与<strong>当前操作相反的逻辑日志到undo log</strong>中（可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录），如果因为某些原因导致事务异常失败了，可以借助该undo log进行回滚，保证事务的原子性，所以undo log也必不可少。</p><h4 id="（5）update语句的更新流程"><a href="#（5）update语句的更新流程" class="headerlink" title="（5）update语句的更新流程"></a>（5）update语句的更新流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><ol><li><strong>执行器先找引擎取 ID&#x3D;2 这一行</strong>。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器<strong>拿到引擎给的行数据</strong>，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，<strong>再调用引擎接口写入这行新数据</strong>。</li><li>引擎<strong>将这行新数据更新到内存中</strong>，同时将这个更新操作<strong>记录到 redo log</strong> 里面，此时 redo log 处于 <strong>prepare 状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器<strong>生成这个操作的 binlog，并把 binlog 写入磁盘</strong>。</li><li>执行器调用引擎的<strong>提交事务接口</strong>，引擎把刚刚写入的 <strong>redo log 改成提交（commit）状态</strong>，更新完成。</li></ol><img src="/2022/05/17/mysql/image-20210518132954825.png" alt="image-20210518132954825" style="zoom:67%;"><p>图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><h4 id="（6）两阶段提交"><a href="#（6）两阶段提交" class="headerlink" title="（6）两阶段提交"></a>（6）两阶段提交</h4><p><strong>为什么redo log要分两步写，中间再穿插写binlog呢？</strong>可用反证法</p><blockquote><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol></blockquote><p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><h3 id="5、存储引擎"><a href="#5、存储引擎" class="headerlink" title="5、存储引擎"></a>5、存储引擎</h3><p>MySQL服务器把<strong>数据的存储和提取操作</strong>都封装到了一个叫存储引擎的模块里。</p><p>MySQL 的server层在完成<strong>查询优化后，执行器只需要按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端</strong>。</p><p>注意：<strong>存储引擎是基于表的，而不是数据库</strong>。</p><p>常用存储引擎：</p><ul><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><h4 id="（1）InnoDB存储引擎简介"><a href="#（1）InnoDB存储引擎简介" class="headerlink" title="（1）InnoDB存储引擎简介"></a>（1）InnoDB存储引擎简介</h4><p>MySQL默认的<strong>事务型</strong>存储引擎，支持<strong>行锁</strong>，支持<strong>外键</strong>，通过使用多版本并发控制（<strong>MVCC</strong>）来获得高并发性，并实现了SQL标准的四种隔离级别，默认为REPEATABLE级别，同时使用一种<strong>Next-Key Locking防止幻读</strong>。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><p>此外还提供了<strong>插入缓冲</strong>（Insert buffer）、<strong>二次写</strong>（double write）、<strong>自适应哈希索引</strong>（Adaptive hash index）、<strong>预读</strong>（read ahead）等高性能高可用的功能。</p><p>InnoDB存储引擎将数据放在一个逻辑的<strong>表空间</strong>中，4.1版本开始后，可以将每个该引擎的表放在一个<strong>独立的ibd文件</strong>中。</p><p>对表中数据的存储，采用了<strong>聚集</strong>（cluster）的方法，每张表的存储都是按<strong>主键顺序存放</strong>（若无显示定义主键或唯一键，则会生成一个隐藏列rowid，以此为主键）</p><h4 id="（2）MyISAM存储引擎简介"><a href="#（2）MyISAM存储引擎简介" class="headerlink" title="（2）MyISAM存储引擎简介"></a>（2）MyISAM存储引擎简介</h4><p>不支持事务、行锁、外键</p><p>在表读取时，也可以往表中插入新的记录，称为并发插入</p><p>MyISAM存储引擎表由MYD和MYI组成，M<strong>YD存放数据文件，MYI存放索引文件</strong>。</p><p>与大多数数据库不同的是它的缓<strong>冲池只缓存索引文件，不缓冲数据文件</strong></p><h4 id="（3）MyISAM和InnoDB的区别"><a href="#（3）MyISAM和InnoDB的区别" class="headerlink" title="（3）MyISAM和InnoDB的区别"></a>（3）MyISAM和InnoDB的区别</h4><p>以下五点，前者均不支持，后者均支持</p><ul><li><p>是否支持<strong>事务</strong></p></li><li><p>是否支持<strong>行锁</strong></p><p>MyISAM、MEMORY等<strong>只支持表锁</strong>，，而且同一时刻只允许一个用户对表进行写操作，所以这些引擎最好用在只读或大部分读或单用户的情景下，不适合并发场景</p></li><li><p>是否支持<strong>MVCC</strong></p></li><li><p>是否支持<strong>外键</strong></p><p>一般也不建议在数据库层面使用外键的，应用层面可以解决，根据项目而定</p></li><li><p>是否支持<strong>数据库异常崩溃后的安全恢复</strong></p><p>依赖于 <code>redo log</code></p></li></ul><blockquote><ul><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的<strong>隔离性</strong>（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul></blockquote><h4 id="（4）设置、修改表的存储引擎"><a href="#（4）设置、修改表的存储引擎" class="headerlink" title="（4）设置、修改表的存储引擎"></a>（4）设置、修改表的存储引擎</h4><p><strong>设置表的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名&#123;</span><br><span class="line">建表语句</span><br><span class="line">&#125;ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><p><strong>修改表的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h3 id="6、MySQL字符集"><a href="#6、MySQL字符集" class="headerlink" title="6、MySQL字符集"></a>6、MySQL字符集</h3><h4 id="（1）字符集"><a href="#（1）字符集" class="headerlink" title="（1）字符集"></a>（1）字符集</h4><p>计算机中只能存储二进制数据，为存储字符串数据，需要建立字符与二进制数据的映射关系（解码和编码），人们抽象出一个字符集的概念描述某个字符范围内的编码规则</p><h4 id="（2）常用字符集"><a href="#（2）常用字符集" class="headerlink" title="（2）常用字符集"></a>（2）常用字符集</h4><ul><li><p>ASCII字符集</p><p>收录128个字符，所以可用1字节来编码</p></li><li><p>ISO 8859-1字符集</p><p>收录256个字符，前者的扩充，可用1字节编码</p></li><li><p>GB2312字符集</p><p>收录了汉字等，兼容ASCII字符集，若该字符在ASCII字符集中，则1字节编码，否则2字节编码，即变长编码方式</p></li><li><p>GBK字符集</p><p>前者的扩充，编码方式兼容前者，2字节编码</p></li><li><p>UTF-8字符集</p><p>收录地球上能想到的所有字符，而且还在不断扩充。兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用1～4个字节</p><blockquote><p>准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。</p></blockquote></li></ul><h4 id="（3）MySQL支持的字符集"><a href="#（3）MySQL支持的字符集" class="headerlink" title="（3）MySQL支持的字符集"></a>（3）MySQL支持的字符集</h4><p>MySQL中常用utf-8字符集</p><ul><li><p><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</p></li><li><p><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</p></li></ul><p>在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用<code>utf8mb4</code>。</p><h3 id="7、MySQL数据类型"><a href="#7、MySQL数据类型" class="headerlink" title="7、MySQL数据类型"></a>7、MySQL数据类型</h3><h4 id="（1）整型"><a href="#（1）整型" class="headerlink" title="（1）整型"></a>（1）整型</h4><blockquote><p>INT(11) 中的<strong>数字只是规定了交互工具显示字符的个数</strong>，对于存储和计算来说是没有意义的。</p></blockquote><p>TINYINT, SMALLINT, MEDIUMINT, <strong>INT</strong>, BIGINT 分别使用 8, 16, 24, <strong>32</strong>, 64 位存储空间，<strong>一般情况下越小的列越好</strong>。</p><h4 id="（2）浮点数"><a href="#（2）浮点数" class="headerlink" title="（2）浮点数"></a>（2）浮点数</h4><p><strong>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型</strong>。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 <strong>DECIMAL 的计算比浮点类型需要更高的代价</strong>。</p><p>FLOAT占用4个字节，DOUBLE占用8个字节；</p><h4 id="（3）字符串"><a href="#（3）字符串" class="headerlink" title="（3）字符串"></a>（3）字符串</h4><blockquote><p>VARCHAR(50)：50表示最多存放50个字符；VARCHAR最多存放65532个字符</p><p>CHAR(50)：50表示存放50个字符，不足就用空格补齐；CHAR最多存放255个字符</p></blockquote><p>主要有 <strong>CHAR</strong> 和 <strong>VARCHAR</strong> 两种类型，一种是<strong>定长的</strong>，一种是<strong>变长的</strong>。还有TEXT、BLOB</p><p><strong>VARCHAR 这种变长类型能够节省空间</strong>，因为只需要存储必要的内容。但是在执行 <strong>UPDATE 时可能会使行变得比原来长</strong>，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行<strong>拆成不同的片段</strong>存储，而 InnoDB 则需要<strong>分裂页</strong>来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h4 id="（4）时间和日期"><a href="#（4）时间和日期" class="headerlink" title="（4）时间和日期"></a>（4）时间和日期</h4><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><p><strong>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</strong>切忌使用字符串存储日期（占用空间大，比较效率低，无法用日期相关的API）</p><h5 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h5><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 <strong>8 字节</strong>的存储空间。它是<strong>时区无关的</strong>。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h5 id="TIMESTAMP（推荐）"><a href="#TIMESTAMP（推荐）" class="headerlink" title="TIMESTAMP（推荐）"></a>TIMESTAMP（推荐）</h5><p><strong>和 UNIX 时间戳相同</strong>，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的<strong>秒数</strong>，使用 <strong>4 字节</strong>，只能表示从 1970 年到 2038 年。</p><p><strong>它和时区有关</strong>，也就是说<strong>一个时间戳在不同的时区所代表的具体时间是不同的</strong>。</p><p>MySQL 提供了 FROM_UNIXTIME() <strong>函数把 UNIX 时间戳转换为日期</strong>，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>若插入时未指定 TIMESTAMP 列的值，会将这个值<strong>默认设置为当前时间</strong>。</p><h3 id="8、数据库设计三大范式"><a href="#8、数据库设计三大范式" class="headerlink" title="8、数据库设计三大范式"></a>8、数据库设计三大范式</h3><h4 id="（1）第一范式"><a href="#（1）第一范式" class="headerlink" title="（1）第一范式"></a>（1）第一范式</h4><p>1NF是对属性的<strong>原子性</strong>，要求属性具有原子性，每一列必须是不可分割的最小单元</p><blockquote><p>不能把多个列组合成一个列，比如把邮箱和手机号合为一个列就是不满足第一范式；</p><p>同时也不能把已是不可分割的原子列再进行拆分；</p></blockquote><h4 id="（2）第二范式"><a href="#（2）第二范式" class="headerlink" title="（2）第二范式"></a>（2）第二范式</h4><p>在满足1NF的基础上，2NF是对记录的<strong>唯一性</strong>，要求<strong>记录有唯一标识</strong>，也就是<strong>要有主键，其他字段都完全依赖于主键，不能只与主键的某一部分相关</strong>（针对联合主键来说）。</p><p><strong>在通俗来讲就是一个数据库表中只能保存一种对象的信息，如果属于这个对象的属性就可以放进来，不属于就不能放进来。不可以把多种对象的数据保存在同一张数据库表中</strong></p><blockquote><p>表：学号、课程号、姓名、学分；</p><p>这个表保存了两种对象的数据:学生信息, 课程信息；这里<strong>学分依赖课程号</strong>，<strong>姓名依赖于学号</strong>，所以不符合二范式。</p><p>正确做法:<br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p></blockquote><h4 id="（3）第三范式"><a href="#（3）第三范式" class="headerlink" title="（3）第三范式"></a>（3）第三范式</h4><p><strong>不能有冗余信息</strong>，<strong>数据表中的每个字段都和主键直接相关，而不能间接相关</strong>，<strong>不能存在传递依赖关系</strong></p><p><strong>通俗来讲，比如一个表描述的这个对象里引用了另一个对象，那么没必要把另一个对象的全部属性都加进来，只需要把它的主键放进来就足够了。</strong></p><blockquote><p>比如一个表: 学号, 姓名, 学院, 学院电话</p><p>这个表存在一种传递依赖关系，学院电话依赖于学院，学院依赖于学号，也就是学院电话并不是直接依赖于学号</p></blockquote><p>如果不满足第三范式的话会有重复冗余的信息，修改时需要同时修改多条记录，否则就会出现<strong>数据不一致的情况</strong> 。</p><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 学院)；</p><p>学院：(学院, 学院电话)。</p><h2 id="二、InnoDB存储引擎"><a href="#二、InnoDB存储引擎" class="headerlink" title="二、InnoDB存储引擎"></a>二、InnoDB存储引擎</h2><h3 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h3><p>后台线程的主要作用是<strong>刷新内存池中的数据，保证缓冲池数据都是最新的数据</strong>；将<strong>已修改的数据文件刷新到磁盘</strong>；<strong>保证数据库发生异常崩溃后，能将数据恢复；</strong></p><h4 id="（1）Master-Thread"><a href="#（1）Master-Thread" class="headerlink" title="（1）Master Thread"></a>（1）Master Thread</h4><p>核心后台线程，保证将缓冲池中的数据异步刷新到磁盘，保证数据的一致性（脏页刷新、合并插入缓冲、undo页回收）</p><h4 id="（2）IO-Thread"><a href="#（2）IO-Thread" class="headerlink" title="（2）IO Thread"></a>（2）IO Thread</h4><p>因为大量使用了AIO（Async  IO）处理写请求，该线程负责这些IO请求的回调处理</p><h4 id="（3）Purge-Thread"><a href="#（3）Purge-Thread" class="headerlink" title="（3）Purge Thread"></a>（3）Purge Thread</h4><p>事务被提交后。undo日志可能不再需要，该线程负责回收已经使用并分配的undo页</p><h4 id="（4）Page-Cleaner-Thread"><a href="#（4）Page-Cleaner-Thread" class="headerlink" title="（4）Page Cleaner Thread"></a>（4）Page Cleaner Thread</h4><p>1.2版本引入，将脏页刷新工作放到该线程处理，减轻Master Thread的压力</p><h3 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h3><h4 id="（1）缓冲池"><a href="#（1）缓冲池" class="headerlink" title="（1）缓冲池"></a>（1）缓冲池</h4><p><strong>缓冲池是一块内存区域，用来弥补CPU与磁盘速度之间的鸿沟</strong>。缓冲池缓存的数据页类型：数据页、索引页、undo页、插入缓冲、自适应哈希索引等等，绝非只有数据页和索引页。</p><h4 id="（2）LRU-List-、Free-List和Flush-List"><a href="#（2）LRU-List-、Free-List和Flush-List" class="headerlink" title="（2）LRU List 、Free List和Flush List"></a>（2）LRU List 、Free List和Flush List</h4><p>缓冲池通过<strong>LRU算法</strong>来进行管理，<strong>频繁使用</strong>的页放在LRU列表的<strong>前端</strong>，首先<strong>释放末尾的页</strong>，页大小默认16KB</p><p>InnoDB的LRU算法对传统算法做了<strong>优化</strong>，再LRU列表中加入了<strong>midpoint位置</strong>，新读取的页并非放入首端，而是放在midpoint位置（默认在LRU列表尾部37%的位置，差不多<strong>3&#x2F;8</strong>）。该位置前面称作<strong>new列表（热数据），后面为old列表（冷数据）</strong>。</p><blockquote><p>主要是为了<strong>避免某些操作例如扫描操作，需要访问许多页甚至全部的页</strong>，这些页通常只在本次操作中需要，并非活跃的热数据，而如果直接放入首部，势必会让LRU列表大换血，导<strong>致真正的热点数据被挤出</strong></p></blockquote><p>此外，还引入另一个参数表示页读取到该位置后，需要等待多久才会被加入热端</p><p>数据刚启动时，LRU列表是空的，此时缓冲池的页都放在<strong>Free列表中</strong>，当<strong>需要缓冲页时</strong>，会从Free表查找是否有<strong>空闲页</strong>，若有，则删除并<strong>加入到LRU列表</strong></p><p><strong>LRU表中的数据页被修改后，称为脏页</strong>，数据库会通过checkpoint机制将其<strong>刷新到磁盘上</strong>，而<strong>Flush列表的页即为脏页</strong>，注意脏页既存在于LRU也存在于Flush中，<strong>Flush列表只是管理将页刷新回磁盘，而非特定用于存储脏页</strong></p><h4 id="（3）重做日志缓冲（redo-log）"><a href="#（3）重做日志缓冲（redo-log）" class="headerlink" title="（3）重做日志缓冲（redo log）"></a>（3）重做日志缓冲（redo log）</h4><p>内存区域除了缓冲池，还有redo log缓冲池，将redo log想放入该区域，之后再异步刷新到重做日志文件。</p><p>刷盘时机：</p><ul><li><strong>master thread以每秒一次</strong>的频率定时刷新</li><li>每个<strong>事务提交时</strong>会刷新</li><li>当该<strong>缓冲池剩余空间小于一半</strong>时刷新</li></ul><h4 id="（4）额外内存池"><a href="#（4）额外内存池" class="headerlink" title="（4）额外内存池"></a>（4）额外内存池</h4><p>在对一些数据结构本身的内存进行分配时，需从额外的内存池中进行申请，当该区域内存不够时，会从缓冲池进行申请</p><h3 id="3、Checkpoint"><a href="#3、Checkpoint" class="headerlink" title="3、Checkpoint"></a>3、Checkpoint</h3><p>checkpoint（检查点）技术的目的是解决以下几个问题：</p><ul><li>缩短数据库的恢复时间</li><li>缓冲池不够用时，将脏页刷新到磁盘</li><li>redo log不可用时，刷新脏页</li></ul><p>当数据库宕机时，无需重做所有的日志，因为checkpoint之前的页都已经刷新回磁盘，故数据库秩序对checkpoint后的重做日志进行恢复即可，缩短恢复时间。</p><h3 id="4、InnoDB的关键特性"><a href="#4、InnoDB的关键特性" class="headerlink" title="4、InnoDB的关键特性"></a>4、InnoDB的关键特性</h3><ul><li><p><strong>插入缓冲</strong></p></li><li><p><strong>两次写</strong></p></li><li><p><strong>自适应哈希索引</strong></p><p>哈希是一种非常快的查找方法，时间复杂度一般为O(1)，一般只需要一次查找就能；而B+树高度一般3~4层，需要3 ~ 4次查找。</p><p>InnoDB存储引擎会监控对表上各索引页的查询。若观察到建立哈希索引可以带来速度提升，则建立哈希索引，称为自适应哈希索引。</p><p>InnoDB会自动根据访问的频率和模式自动地为某些热点页建立哈希索引，它是根据B+树页构造而来，不需要为整张表建立索引。其设计思想是数据库自优化的，无需人为调整</p></li><li><p><strong>异步IO</strong></p><p>用户可以在发送一个请求后立即发送下一个请求，全部请求发送完后，等待IO操作完成即可，AIO可以进行IO Merge操作，将多个IO合并为一个IO。（访问多个连续的页时）</p></li><li><p><strong>刷新临近页</strong></p><p>刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起刷新。与IO Merge绝配。</p></li></ul><h2 id="三、文件"><a href="#三、文件" class="headerlink" title="三、文件"></a>三、文件</h2><h3 id="1、参数文件"><a href="#1、参数文件" class="headerlink" title="1、参数文件"></a>1、参数文件</h3><p>MySQL数据的参数类型：</p><ul><li><p>动态参数</p><p>可以在MySQL实例中进行更改，可通过SET命令更改，关键字session和global分别表示参数修改是基于当前会话还是整个实例的生命周期</p></li><li><p>静态参数</p><p>整个实例的生命周期中不得更改</p></li></ul><h3 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h3><p>常见日志文件有：</p><ul><li>错误日志（err log）</li><li>二进制（归档）日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）</li></ul><h4 id="（1）错误日志"><a href="#（1）错误日志" class="headerlink" title="（1）错误日志"></a>（1）错误日志</h4><p>对MySQL的启动、运行、关闭过程进行了记录。不仅记录了所有错误信息还有一些警告信息或正确信息，DBA遇到问题应首先查看该文件。默认为 ”主机名.err“</p><h4 id="（2）慢查询日志"><a href="#（2）慢查询日志" class="headerlink" title="（2）慢查询日志"></a>（2）慢查询日志</h4><p>帮助DBA定位可能存在问题的SQL语句，进行SQL语句层面的优化，默认关闭</p><h4 id="（3）查询日志"><a href="#（3）查询日志" class="headerlink" title="（3）查询日志"></a>（3）查询日志</h4><p>记录了所有对MySQL数据库请求的信息，默认为“主机名.log”</p><h4 id="（4）二进制（归档）日志"><a href="#（4）二进制（归档）日志" class="headerlink" title="（4）二进制（归档）日志"></a>（4）二进制（归档）日志</h4><p>记录了对MySQL数据库执行更改的所有操作，所以不包括SELECT和SHOW这类操作（该类操作可以查查询日志）。</p><p>该日志默认关闭，开始会损失1%的性能，可以接受。</p><p>未提交的binlog会被记录到一个缓存中，事务提交时将其写入磁盘。</p><p>主要作用：</p><ul><li><strong>恢复</strong>（recovery）：在一个数据库全备文件恢复后，可以通过binlog进行part-in-time的恢复</li><li><strong>复制</strong>（replication）：主从复制</li><li>审计（audit）：判断是否有对数据库进行注入的攻击</li></ul><h3 id="3、表结构定义文件"><a href="#3、表结构定义文件" class="headerlink" title="3、表结构定义文件"></a>3、表结构定义文件</h3><p>每个表都有一个与之对应的frm文件，记录了该表的表结构定义，此外，frm还用来记录视图的定义。</p><h3 id="4、InnoDB存储引擎文件"><a href="#4、InnoDB存储引擎文件" class="headerlink" title="4、InnoDB存储引擎文件"></a>4、InnoDB存储引擎文件</h3><h4 id="（1）表空间文件"><a href="#（1）表空间文件" class="headerlink" title="（1）表空间文件"></a>（1）表空间文件</h4><p>InnoDB采用将存储的数据按照表空间进行存放的设计。默认有个ibdata1的表空间文件，初始10MB，但是是自增文件</p><p>所有记录都会存放在该共享表空间中。此外，用户还可以将每个InnoDB引擎的表产生一个独立表空间：表名.ibd。</p><p>注意：独立表空间仅存储该表的数据、索引和插入缓冲BITMAP等，其余信息依旧在共享表空间</p><h4 id="（2）重做日志文件"><a href="#（2）重做日志文件" class="headerlink" title="（2）重做日志文件"></a>（2）重做日志文件</h4><p>同样是记录事务日志，redolog与binlog有什么不同？</p><ul><li>binlog是MySQl Server层实现的，可以记录所有的MySQL记录，而redolog是InnoDB引擎特有的，只记录有关该引擎的记录</li><li>记录的内容不同，binlog记录的是一个事务的具体操作，是逻辑日志；而redolog记录的是每个页的更改的物理情况，是物理日志</li><li>写入的时间不同，binlog仅在事务提交前提交，不论事务多大，即只写盘一次；而在事务进行的过程中，却不断有重做日志条目写入到重做日志文件中</li><li><strong>redolog 是循环写的，空间固定会用完</strong>；binlog 是可以追加写入的。<strong>“追加写</strong>”是指 binlog 文件写到一定大小后会切换到下一个，并<strong>不会覆盖以前的日志</strong>。</li></ul><h2 id="四、表"><a href="#四、表" class="headerlink" title="四、表"></a>四、表</h2><h3 id="1、索引组织表"><a href="#1、索引组织表" class="headerlink" title="1、索引组织表"></a>1、索引组织表</h3><p>在InnoDB存储引擎中，表<strong>都是根据主键顺序组织存放的</strong>，这种存储方式的表称为<strong>索引组织表</strong>。</p><p>在InnoDB存储引擎的表中，<strong>每个表都有主键</strong>，若未显示的定义主键，则会按下面方式选择或创建主键：</p><ul><li>判断是否有<strong>非空的唯一索引</strong>，有则设为主键</li><li>否则，自行创建一个<strong>隐藏主键row_id</strong></li></ul><h3 id="2、InnoDB逻辑存储结构"><a href="#2、InnoDB逻辑存储结构" class="headerlink" title="2、InnoDB逻辑存储结构"></a>2、InnoDB逻辑存储结构</h3><p>所有数据都被逻辑地存放在一个空间中，称为表空间。表空间由段（segment）、区（extent）、页（page）组成。</p><h4 id="（1）表空间"><a href="#（1）表空间" class="headerlink" title="（1）表空间"></a>（1）表空间</h4><p>前文已介绍，分为共享表空间和独立表空间</p><h4 id="（2）段"><a href="#（2）段" class="headerlink" title="（2）段"></a>（2）段</h4><p>常见的段有数据段、索引段、回滚段等，因为InnoDB<strong>存储引擎表是索引组织的</strong>，因此<strong>数据即索引，索引即数据</strong>，数据段也就是B+树的叶子节点，索引段即B+树的非叶子结点。</p><h4 id="（3）区"><a href="#（3）区" class="headerlink" title="（3）区"></a>（3）区</h4><p>区由<strong>连续的页</strong>组成，一个区为1MB，一个页为16KB，那么一个区由64个连续页</p><blockquote><p>每个段开始时，先用32个页大小的碎片页来存放数据，在使用完碎片页后才是64个连续页的申请，对于一些小表，这样做可以在开始时申请较少的空间，节省磁盘容量开销</p></blockquote><h4 id="（4）页"><a href="#（4）页" class="headerlink" title="（4）页"></a>（4）页</h4><p>InnoDB磁盘管理的最小单位</p><h4 id="（5）行"><a href="#（5）行" class="headerlink" title="（5）行"></a>（5）行</h4><p>数据是按行排列的</p><h3 id="3、InnoDB行记录格式"><a href="#3、InnoDB行记录格式" class="headerlink" title="3、InnoDB行记录格式"></a>3、InnoDB行记录格式</h3><p>两种格式存放行记录数据：</p><ul><li>Compact（默认）</li><li>Redundant</li></ul><h4 id="（1）Compact行记录格式"><a href="#（1）Compact行记录格式" class="headerlink" title="（1）Compact行记录格式"></a>（1）Compact行记录格式</h4><p>设计目标是<strong>高效地存储数据</strong>。一个页中存放地<strong>行数据越多，性能也就越高</strong>。</p><p>固定长度CHAR字段在未能完全占用其长度时，会用0x20进行填充</p><p>不论是CHAR还是VARCHAR，该格式下<strong>NULL值都不占用任何存储空间</strong></p><h4 id="（2）Redundant行记录格式"><a href="#（2）Redundant行记录格式" class="headerlink" title="（2）Redundant行记录格式"></a>（2）Redundant行记录格式</h4><p><strong>CHAR类型的NULL值需要占用空间</strong></p><h4 id="（3）行溢出数据"><a href="#（3）行溢出数据" class="headerlink" title="（3）行溢出数据"></a>（3）行溢出数据</h4><p>InnoDB存储引擎可以<strong>将一条记录的某些数据存在真正的数据页面之外</strong>。</p><p>如果某一列中的数据非常多的话，在本记录的真实数据处只会存储<strong>该列的前768个字节的数据</strong>和一个<strong>指向其他页的地址</strong>，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出<code>768</code>字节的那些页面也被称为溢出页</p><img src="/2022/05/17/mysql/image-20210605081536271.png" alt="image-20210605081536271" style="zoom: 67%;"><blockquote><p>VARCHAR类型最大支持<strong>65535，单位是字节</strong>。</p><p>VARCHAR(N)中的<strong>N指的是字符的长度，并非字节长度</strong>，不同字符集中，字符占用的字节数不一样，即使同一字符集，也不一定一样</p></blockquote><h4 id="（4）Compressed和Dynamic行记录格式"><a href="#（4）Compressed和Dynamic行记录格式" class="headerlink" title="（4）Compressed和Dynamic行记录格式"></a>（4）Compressed和Dynamic行记录格式</h4><p>这俩行格式和<code>Compact</code>行格式挺像，只不过在处理**<code>行溢出</code>数据时有点儿分歧**，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址</p><h3 id="4、InnoDB数据页结构"><a href="#4、InnoDB数据页结构" class="headerlink" title="4、InnoDB数据页结构"></a>4、InnoDB数据页结构</h3><h4 id="（1）File-Header"><a href="#（1）File-Header" class="headerlink" title="（1）File Header"></a>（1）File Header</h4><p>记录各种页都通用的一些头信息。描述了针对各种页的通用信息。例如：</p><ul><li><p>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以<strong>所有的数据页会组成一个双链表</strong>，无需物理上相连。</p></li><li><p>每个页都有一个页号，InnoDB<strong>通过页号可以唯一定位一个页</strong>。</p></li><li><p>校验和与File Trailer中相对应</p></li></ul><h4 id="（2）Page-Header"><a href="#（2）Page-Header" class="headerlink" title="（2）Page Header"></a>（2）Page Header</h4><p>记录数据页的状态信息</p><h4 id="（3）Infimum和Supremum-Record"><a href="#（3）Infimum和Supremum-Record" class="headerlink" title="（3）Infimum和Supremum Record"></a>（3）Infimum和Supremum Record</h4><p>每个数据页有两个虚拟的行记录，用来限定记录的边界。Infimum是比数据页中任何主键值都要小的值，同理另一个。</p><h4 id="（4）User-Record和Free-Space"><a href="#（4）User-Record和Free-Space" class="headerlink" title="（4）User Record和Free Space"></a>（4）User Record和Free Space</h4><p>User Record是实际存储行记录的内容。</p><p>Free Space是空闲空间，链表数据结构。每当我们插入一条记录，都会从该部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，在一条记录被删除后，加入空闲链表中。</p><h4 id="（5）Page-Directory（页目录）"><a href="#（5）Page-Directory（页目录）" class="headerlink" title="（5）Page Directory（页目录）"></a>（5）Page Directory（页目录）</h4><p><strong>B+树索引只能找到记录所在的页，将页载入内存中，再通过page directory进行二分查找才能找到具体的记录</strong>。</p><p><code>InnoDB</code>会为把页中的<strong>记录划分为若干个组</strong>，每个组的最后一个记录的页内地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：</p><ul><li>通过<strong>二分法</strong>确定该记录所在的<strong>槽</strong>。</li><li>通过<strong>记录的next_record</strong>属性<strong>遍历</strong>该槽所在的组中的各个记录。</li></ul><blockquote><p>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</p></blockquote><h4 id="（6）File-Trailer"><a href="#（6）File-Trailer" class="headerlink" title="（6）File Trailer"></a>（6）File Trailer</h4><p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</p><blockquote><p>这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trialer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p></blockquote><h3 id="5、约束"><a href="#5、约束" class="headerlink" title="5、约束"></a>5、约束</h3><p>关系型数据库系统和文件系统地一个不同在于，关系数据库本身能保证存储数据的完整性，无需程序控制。几乎所有的关系型数据库都支持约束机制，来保证数据库的完整性。</p><h4 id="（1）数据完整性"><a href="#（1）数据完整性" class="headerlink" title="（1）数据完整性"></a>（1）数据完整性</h4><p>一般来说数据完整性有三种形式：</p><ul><li>实体完整性保证表中有一个主键（通过PRIMARTY KEY或UNIQUE KEY保证）</li><li>域完整性保证数据每列的值满足特定的条件（通过选定合适的数据类型或外键或触发器保证）</li><li>参照完整性保证两张表之间的关系（通过外键或触发器保证）</li></ul><blockquote><p>InnoDB提供了以下几种约束：</p><ul><li>Primary Key 主键约束</li><li>Unique Key 唯一键约束</li><li>Foreign Key 外键约束</li><li>Default 默认</li><li>NOT NULL 非空约束</li></ul></blockquote><h4 id="（2）约束和索引的区别？"><a href="#（2）约束和索引的区别？" class="headerlink" title="（2）约束和索引的区别？"></a>（2）约束和索引的区别？</h4><p>用户<strong>创建了一个唯一索引就创建了一个唯一的约束</strong>，但是约束和索引的概念还是有所不同的：<strong>约束是一个逻辑概念，用来保证数据的完整性</strong>，而<strong>索引是一个数据结构，既有逻辑上的概念，在数据库中也还代表着物理存储的方式</strong>。</p><h4 id="（3）外键约束"><a href="#（3）外键约束" class="headerlink" title="（3）外键约束"></a>（3）外键约束</h4><p>外键建立时，InnoDB会自动对该列创建一个索引，可以很好地避免外键列上无索引而导致地死锁问题。</p><p>对于参照完整性，外键很有用。但是对于<strong>数据导入时，外键往往导致在外键约束的检查上花费大量时间，因为外键是即时检查的，所以对于导入的每一行都会检查，严重影响性能。</strong></p><h3 id="6、视图"><a href="#6、视图" class="headerlink" title="6、视图"></a>6、视图</h3><p><strong>什么是视图</strong></p><p>视图(VIEW)是一个<strong>虚拟的表</strong>，<strong>一组数据的逻辑表示</strong>，是从数据库中一个或多个表中导出来的，内容由查询定义。视图本身不包含任何数据，这些数据仍然存放在原来的表（基表）中。使用视图查询数据时，仍然从基表中取数据，一旦基表中的数据变化，视图中的数据也会相应改变。</p><p><strong>特点：</strong></p><ul><li>视图的列可以来自不同的表；</li><li>视图是由基表（实表）产生的虚表；</li><li>视图的建立和删除不影响基表；</li><li>对视图内容的更新（增删改）会影响基表；</li><li>当视图来自多个基表时，不允许添加和删除数据</li></ul><p><strong>优点：</strong></p><ul><li><p>简单性</p><p>简化用户对数据的理解和操作，看到的就是需要的，可以将那些经常使用到的查询定义为视图，简化操作；</p></li><li><p>安全性</p><p>可以防止未授权用户查看特定的行或列，使有权限用户只能看到表中特定行</p></li><li><p>逻辑数据独立性</p><p>视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，程序一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。视图可以在以下几个方面使程序与数据独立。</p><p>（1）如果应用建立在数据库表上，当数据库表发生变化时，可以在表上建立视图，通过视图屏蔽表的变化，从而使应用程序可以不动。</p><p>（2）如果应用建立在数据库表上，当应用发生变化时，可以在表上建立视图，通过视图屏蔽应用的变化，从而使数据库表不动。</p><p>（3）如果应用建立在视图上，当数据库表发生变化时，可以在表上修改视图，通过视图屏蔽表的变化，从而使应用程序可以不动。</p><p>（4）如果应用建立在视图上，当应用发生变化时，可以在表上修改视图，通过视图屏蔽应用的变化，从而使数据库可以不动。</p></li></ul><h2 id="五、索引"><a href="#五、索引" class="headerlink" title="五、索引"></a>五、索引</h2><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><blockquote><p>红黑树的性质</p></blockquote><ol><li>每个节点要么是黑色，要么是红色</li><li>根节点是黑色</li><li>每个叶子节点（NIL)是黑色（NIL就是其他树的null）</li><li>每个红色节点的两个子节点一定是黑色，不能有两个红色节点相连</li><li>任意一节点到每个叶子节点的路径都包含数量相同的黑节点。俗称黑高。<ol><li>如果一个节点存在黑子节点，那么该节点肯定有两个子节点。</li></ol></li></ol><p><strong>红黑树并不是一个完美的平衡二叉查找树</strong>，但左子树和右子树的黑节点的层数是相等的，也即任意一个节点到每个叶子节点的路径都包含相同数量的黑节点，所以叫红黑树这种平衡为<strong>黑色完美平衡</strong></p><blockquote><p>红黑树能自平衡：<strong>左旋、右旋、变色</strong></p></blockquote><ol><li><strong>变色</strong>：节点的颜色由红变黑或由黑变红</li><li><strong>左旋</strong>：以某个节点作为支点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为选装节点的右子节点，左子节点保持不变。</li><li><strong>右旋</strong>：以某个节点作为支点（旋转节点），其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。</li></ol><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><blockquote><p>磁盘预读：预读的长度一般为页（page）的整数倍</p></blockquote><p><strong>页</strong>是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4K），贮存和磁盘以页为单位交换数据。</p><h3 id="1-索引是什么？"><a href="#1-索引是什么？" class="headerlink" title="1.索引是什么？"></a>1.索引是什么？</h3><ol><li><p>索引是帮助MySQL高效获取数据的数据结构</p></li><li><p>索引存储在文件系统中</p></li><li><p>索引的文件存储形式与储存引擎有关</p></li><li><p>索引文件的结构</p><ol><li><p>hash</p><ol><li>缺点：<ol><li>利用hash存储的画需要将所有的数据文件添加到内存，比较耗费内存空间</li><li>如果所有的查询都是等值查询，那么hash确实很快，但是在企业或者实际共工作环境中范围查找的数据更多，而不是等职查询，因此hash就不太适合</li></ol></li></ol></li><li><p>二叉树</p><p>缺点：无论是二叉树还是红黑树，都会因为树的深度过深而造成io次数变多，影响数据读取的效率。</p></li><li><p>B树</p><ol><li>B树特点：<ol><li>所有键值分布在整棵树中</li><li>搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找</li><li>每个节点最多拥有m个子树</li><li>根节点至少有2个子树</li><li>分支节点至少拥有m&#x2F;2棵子树（除根节点和叶子节点外都是分支节点）</li><li>搜索叶子节点都在同一层，每个节点最多可以有m-1个key，并且升序排列</li></ol></li></ol></li><li><p>B+树</p><p>B+树是在B树的基础上做的一种优化，变化如下：</p><ul><li>B+树每个节点可以包含更多的节点，这么做的原因：为了降低树的高度；将数据范围变为多个区间，区间越多，数据检索越快</li><li>非叶子节点存储key，叶子节点存储key和数据</li><li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高。</li></ul></li></ol></li></ol><h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2.索引分类"></a>2.索引分类</h3><ol><li><p>主键索引：</p><p>主键是一种唯一性索引，但他必须指定为PRIMARY KEY，每个表只能由一个主键</p></li><li><p>唯一索引</p><p>索引列的所有值都只能出现一次，即必须唯一，值可以为空</p></li><li><p>普通索引</p><p>基本的索引类型，值可以为空，没有唯一性的限制</p></li><li><p>全文索引</p><p>全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建。</p></li><li><p>组合索引</p><p>多列值组成一个索引，专门用于组合搜索</p></li></ol><p><strong>什么是索引？</strong></p><p><strong>索引是一种用于快速查询和检索数据的数据结构。</strong>索引就相当于目录，通过对内容建立索引形成目录，方便查找书中的内容。</p><p><strong>InnoDB支持以下几种常见索引：</strong></p><ul><li><p>B+树索引</p><p><strong>B+树索引并不能找到具体的行记录，而是找到记录所在的页，将页读入内存在通过页目录进行二分查找找到相应的记录。</strong></p></li><li><p>全文索引</p><p>MyISAM 存储引擎支持全文索引，InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><p>用<strong>于查找文本中的关键词，而不是直接比较是否相等</strong>。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p></li><li><p>自适应哈希索引</p><p>哈希索引的设计思想是<strong>数据库自适应的，不能人为干预的</strong>，InnoDB存储引擎会<strong>根据表的使用情况在B+树上自动创建一个哈希索引。</strong></p><p>哈希索引能以O(1)时间查询，但是失去了有序性：</p><ul><li><strong>无法用于排序和分组</strong></li><li><strong>只能用于精确等值查找，无法范围查找</strong></li></ul></li></ul><h3 id="1、B-树"><a href="#1、B-树" class="headerlink" title="1、B+树"></a>1、B+树</h3><blockquote><p>B+树中的B不是代表二叉（Binary），而是代表平衡（Balance），因为B+树从最早的平衡二叉树演化而来，但并不是二叉树</p></blockquote><h4 id="（1）B-的由来"><a href="#（1）B-的由来" class="headerlink" title="（1）B+的由来"></a>（1）B+的由来</h4><p>B+树是通过<strong>二叉搜索树</strong>，再由<strong>平衡二叉树</strong>，<strong>B树</strong>演化而来。</p><ul><li><p>在二叉搜索树中，左子树的键值总是小于根节点的键值，右子树的键值总是大于根节点的键值。可以通过中序遍历得到键值的排序输出，但对于同一键值序列，二叉搜索树可以有不同的构造，查找效率也不同。<strong>若想最大性能构造二叉搜索树，需要这颗二叉搜索树是平衡的。</strong></p></li><li><p>平衡二叉树（AVL树）：首先满足二叉搜索树定义，满足<strong>任何节点的两个子树的高度最大差为1</strong>。但平衡二叉树的<strong>维护具有一定的开销</strong>（插入或删除结点），不过一般多用于内存结构对象，维护开销相对较小。</p></li><li><p>B树与AVL树不同的是其属于<strong>多叉树</strong>，且所有<strong>叶子节点均在同一层</strong>，每个节点都存有索引（Key）和数据（Value）</p></li></ul><h4 id="（2）B树与B-树的区别"><a href="#（2）B树与B-树的区别" class="headerlink" title="（2）B树与B+树的区别"></a>（2）B树与B+树的区别</h4><p>B+树是B树的一种变体，不同之处在于：</p><ul><li><p>B 树的所有节点既存放键(key) 也存放数据(data)，而 <strong>B+树只有叶子节点存放 key 和 data，非叶子节点只存放 key</strong>。这使得B+树每个<strong>非叶子节点能保存的关键字增加</strong>，树的<strong>层级也就更少</strong>，查询更快。</p><blockquote><p>有k个子树的中间节点包含有k个元素，而B树中是k-1个元素</p><p><img src="/2022/05/17/mysql/image-20210605093741479.png" alt="image-20210605093741479" style="zoom:33%;"><img src="/2022/05/17/mysql/image-20210605093807819.png" alt="image-20210605093807819" style="zoom: 33%;"></p></blockquote></li><li><p>B 树的叶子节点都是独立的，而B+树的叶子节点有一条<strong>引用链指向与它相邻的叶子节点</strong>。</p></li><li><p>B 树的检索的过程相当于对范围内的<strong>每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了</strong>。而 B+树的<strong>检索效率更稳定</strong>，任何查找都是从根节点到叶子节点的过程（每次查询次数都相同），叶子节点形成了一条有序链表，<strong>全局遍历只需要遍历所有叶子节点</strong>即可。</p></li></ul><h4 id="（3）B-树的不同实现方式"><a href="#（3）B-树的不同实现方式" class="headerlink" title="（3）B+树的不同实现方式"></a>（3）B+树的不同实现方式</h4><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</p><p><strong>MyISAM 引擎中，索引文件和数据文件是分离的</strong>，<strong>B+Tree 叶节点的 data 域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p><strong>InnoDB 引擎中，其数据文件本身就是索引文件</strong>。其<strong>表数据文件本身就是按 B+Tree 组织的一个索引结构</strong>，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主键索引。这被称为“聚簇索引”，而其余的索引都作为辅助索引，<strong>辅助索引的 data 域存储相应记录主键的值而不是地址</strong>。</p><h4 id="（4）MyISAM中的索引方案"><a href="#（4）MyISAM中的索引方案" class="headerlink" title="（4）MyISAM中的索引方案"></a>（4）MyISAM中的索引方案</h4><p>虽然也是采用B+树结构，但是却将索引和数据分开存储：</p><ul><li>将表中记录按照<strong>插入顺序存储</strong>到一个<strong>数据文件</strong>中，这个文件并不划分数据页，可以<strong>通过行号快速访问</strong>到一条记录。</li><li>将索引信息存储到一个<strong>索引文件</strong>中，MyISAM会单独为主键创建一个索引，但是该索引的叶子节点并非完整行记录，而是“主键值+行号”，即<strong>先通过索引找到行号，再通过行号去访问行记录</strong>。</li></ul><h3 id="2、B-树索引"><a href="#2、B-树索引" class="headerlink" title="2、B+树索引"></a>2、B+树索引</h3><p>B+树索引的本质就是B+树在数据库中的实现，但是B+树在数据库中有一个特点是高扇出性，<strong>所以高度一般在2到4层，即查找一次需要2到4次IO</strong>。</p><h4 id="（1）聚簇索引"><a href="#（1）聚簇索引" class="headerlink" title="（1）聚簇索引"></a>（1）聚簇索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD PRIMARY KEY(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure><p>聚簇索引其实是一种<strong>数据存储方式</strong>，聚簇索引<strong>将索引和数据放在了一起</strong>，无需回表。</p><p>InnoDB中的<strong>主键索引就是聚簇索引</strong>，就是<strong>按照每张表的主键构造一棵B+树</strong>，<strong>叶子节点是数据页，存放是整张表的完整行记录数据</strong>；</p><p><strong>非叶子结点是索引页</strong>，存放的是<strong>主键值和指向数据页的偏移量</strong>。</p><blockquote><p>聚簇索引的存储不是物理上连续的，是逻辑上连续的。一是<strong>所有的页按照主键大小，通过双向链表链接</strong>；二是<strong>页中的所有记录也是通过双向链表按主键排序的</strong>。</p><p>因此聚簇索引十分适用于<strong>主键的排序查找和范围查找</strong>。</p></blockquote><h4 id="（2）辅助（二级）索引"><a href="#（2）辅助（二级）索引" class="headerlink" title="（2）辅助（二级）索引"></a>（2）辅助（二级）索引</h4><p>非聚簇索引：MYISAM就是非聚簇索引，<strong>索引和数据分离</strong>，一般需要回表操作（除非覆盖索引）。</p><p>非主键索引都是非聚簇索引，<strong>叶子节点存放的是“索引列+主键值”</strong>。然后再根据<strong>主键值通过聚簇索引</strong>来找到一个完整的行记录所在的数据页（该操作称作<strong>回表</strong>）。</p><p>常见二级索引：</p><ul><li><p><strong>普通索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>唯一索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD UNIQUE(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>联合索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name(&#x27;column1&#x27;, &#x27;column2&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>前缀索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name(column(10));</span><br></pre></td></tr></table></figure></li><li><p><strong>全文索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD FULLTEXT(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）索引的优点"><a href="#（3）索引的优点" class="headerlink" title="（3）索引的优点"></a>（3）索引的优点</h4><ul><li><p>大大加快了数据查询检索的速度。</p></li><li><p>帮助服务器<strong>避免进行排序和分组</strong>，<strong>索引是有序的</strong>，可以用于 ORDER BY 和 GROUP BY 操作。</p><blockquote><p>比如使用ORDER BY将查询结果按照某个字段排序时，若未建立索引，那么需要在额外对查询结果进行排序；</p><p>而如果建立了索引，由于索引本身就是有序的，所以直接按照索引顺序取出即可；</p></blockquote></li><li><p>将随机 I&#x2F;O 变为<strong>顺序 I&#x2F;O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</p></li></ul><h3 id="3、B-树索引的使用"><a href="#3、B-树索引的使用" class="headerlink" title="3、B+树索引的使用"></a>3、B+树索引的使用</h3><h4 id="（1）索引的缺点"><a href="#（1）索引的缺点" class="headerlink" title="（1）索引的缺点"></a>（1）索引的缺点</h4><ul><li><p><strong>空间上的代价</strong></p><p><strong>每建立一个索引都要为它建立一棵B+树</strong>，B+树的每个节点都是一个16KB大小的数据页，<strong>占用物理存储空间</strong>。</p></li><li><p><strong>时间上的代价</strong></p><p><strong>创建索引和维护索引都需要耗费时间</strong>。每次对表中的数据进行增删改操作，都要去维护表对应的每个B+树索引</p></li></ul><h4 id="（2）回表与覆盖索引"><a href="#（2）回表与覆盖索引" class="headerlink" title="（2）回表与覆盖索引"></a>（2）回表与覆盖索引</h4><p>使用二级索引查询时，以范围查询为例，一般根据二级索引查询的记录在磁盘中的存储都是连续的、集中的分布在一个页或几个页中，可以很快读出来，一般称为<strong>顺序IO</strong>；但是这些记录对应的主键值都是分散的，可能分布在很多个不同的数据页中，需要对磁盘进行离散读，称为<strong>随机IO</strong>。</p><p>所以根据二级索引查询一般有如下特点：</p><ul><li>会用到两个B+树索引，一个二级索引，一个聚簇索引</li><li>访问二级索引使用顺序IO，访问聚簇索引使用随机IO</li></ul><p>需要回表的记录越多，使用二级索引的性能就越低，甚至不如用全局扫描。<strong>查询优化器会根据统计数据来估算两种方式的性能开销决定采用索引还是全局扫描。</strong></p><p>为了<strong>避免回表</strong>操作带来的性能开销，最好在查询字段中就只包含索引列，这样就不用回表去聚簇索引中查询了，所以把<strong>只需要用到索引列的查询方式称为覆盖索引</strong>。</p><p>使用覆盖索引的一个好处是，二级索引不含所有记录信息，其大小远小于聚簇索引，可以减少大量的IO操作。</p><h4 id="（3）索引适用条件"><a href="#（3）索引适用条件" class="headerlink" title="（3）索引适用条件"></a>（3）索引适用条件</h4><ul><li><p><strong>全值匹配</strong></p><p>如果查询语句的<strong>搜索条件中的列和索引列一致</strong>的话，这种情况就称为全值匹配</p></li><li><p><strong>匹配最左边的列</strong></p><p>其实查询语句的<strong>搜索条件</strong>中也可以不用包含全部联合索引中的列，<strong>只包含左边的就行</strong>。</p><p>因为<code>B+</code>树的数据页和记录先是按照联合索引最左边的列值排序的，在左边列值相同时，才会用右边的列值排序。</p><p>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</p></li><li><p><strong>匹配列前缀</strong></p><p>B+树中对字符串列的排序规则一般是<strong>逐个比较字符的大小</strong>，类似于联合索引的排序方式，排序好的字符串列一般有下特点：</p><ul><li><p>先按照字符串的第一个字符进行排序。</p></li><li><p>如果第一个字符相同再按照第二个字符进行排序。</p></li><li><p>如果第二个字符相同再按照第三个字符进行排序，依此类推。</p></li></ul><p>也就是说这些字符串的前n个字符，也就是<strong>前缀都是排好序</strong>的，所以对于字符串类型的索引列来说，我们<strong>只匹配它的前缀也是可以快速定位记录</strong>的，比方说我们想查询名字以<code>&#39;As&#39;</code>开头的记录，那就可以这么写查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#x27;As%&#x27;;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，如果<strong>只给出后缀或者中间</strong>的某个字符串则无法定位，只能全局扫描，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#x27;%As%&#x27;;</span><br></pre></td></tr></table></figure><p>如果有时不得不按照后缀查询，那可以将表中数据逆序存储，这就可以将后缀转为前缀了。</p></li><li><p><strong>匹配范围值</strong></p><p>因为B+树中的记录都是按照索引列的值升序排列好的，索引对于范围查找速度特别快。</p></li><li><p><strong>用于排序、分组</strong></p><p>比如ORDER  BY子句用到索引列的话，那么直接按照索引顺序取就好了，不用再将查询结果进行额外的排序操作；</p></li></ul><h4 id="（4）创建索引注意事项"><a href="#（4）创建索引注意事项" class="headerlink" title="（4）创建索引注意事项"></a>（4）创建索引注意事项</h4><ul><li>对于<strong>非常小的表</strong>、大部分情况下<strong>全表扫描</strong>比建立索引更高效；对于<strong>中到大型的表</strong>，<strong>索引</strong>就非常有效；但是对于<strong>特大型的表</strong>，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用<strong>分区技术</strong>。</li></ul><ul><li><p>只为<strong>经常用于查询、排序、分组的列</strong>创建索引，索引的字段尽量不含NULL</p></li><li><p><strong>考虑列的选择性</strong></p><p>即某列中不重复数据的个数与总数的比值，选择性越大，每个记录的区分度越高，查询效率也越高，最好为具有高选择性的列建立索引。</p></li><li><p><strong>索引列的数据类型（数据能表示的范围）尽量小</strong></p><p>数据类型越小，在查询是进行比较操作则越快；占用存储空间更小，数据页可以存放更多的记录，减少磁盘IO，而且可放在内存缓冲区的数据页也更多，加快读写效率</p></li><li><p><strong>频繁更新的列应慎重建立索引</strong></p><p>因为更新操作，需要对索引进行维护，成本很高。</p></li><li><p><strong>使用覆盖索引</strong></p><p>避免回表的性能开销</p></li><li><p><strong>使用联合索引</strong></p><p>在使用多个列作为查询条件时，比单列索引效果好，节约存储空间</p></li><li><p><strong>使用前缀索引</strong></p><p>即只对字符串（例如BLOB、TAXT和VARCHAR）的前几个字符进行索引，既<strong>节省存储空间</strong>（二级索引叶子节点不用再存储完整的字符串值了），又<strong>减少了字符串比较时间</strong>（不用将每个字符都一一比较了）</p></li><li><p><strong>使用自增主键</strong></p><p>让存储引擎自行生成递增主键，每插入一条记录，都是追加操作，不涉及挪动其他记录，也不会触发页面分裂，而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。而且自增主键相对节约存储空间。</p></li><li><p><strong>索引列单独出现</strong></p><p>如果是索引列以某个表达式或者函数调用方式出现，会造成无法命中索引</p></li><li><p><strong>删除冗余、重复、长期未用的索引</strong></p></li></ul><h4 id="（5）扩展知识–Cardinality值"><a href="#（5）扩展知识–Cardinality值" class="headerlink" title="（5）扩展知识–Cardinality值"></a>（5）扩展知识–Cardinality值</h4><p>这是索引中一个非常关键的值，表示索引中唯一值的数目的估计值，查询优化器会根据这个值来判断是否使用这个索引，但该值并非实时更新，只是一个大概的值</p><p>并不是所有在查询条件中出现的列都需要建立索引，一般经验是，在<strong>访问表中很少一部分时使用索引才有意义</strong>。对于性别字段、地区字段、类别字段，它们的可取范围很小，称为低选择性。</p><p>例如按性别查询，每次查询结果都包含了50%的数据，此时添加索引就是没必要的。相反，如果某个字段取值范围很广，几乎无重复，即属于<strong>高选择性，则使用索引非常合适。</strong></p><p>而查看索引是否具有高选择性就可以通过SHOW INDEX结果中的列Cardinality值来观察。</p><p>数据库对于该值的统计都是通过采样的方法来完成的</p><h2 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h2><h3 id="1、认识事务"><a href="#1、认识事务" class="headerlink" title="1、认识事务"></a>1、认识事务</h3><h4 id="（1）什么是事务？"><a href="#（1）什么是事务？" class="headerlink" title="（1）什么是事务？"></a>（1）什么是事务？</h4><p><strong>事务是一个不可分割的数据库操作序列</strong>，<strong>是逻辑上的一组操作</strong>，<strong>要么都执行，要么都不执行</strong>。</p><h4 id="（2）事务的ACID特性"><a href="#（2）事务的ACID特性" class="headerlink" title="（2）事务的ACID特性"></a>（2）事务的ACID特性</h4><p>InnoDB存储引擎支持的事务是完全满足ACID特性的，其他引擎并不一定（例如NDB Cluster不满足D，Oracle默认事务隔离级别READ COMMITTED，不满足I）</p><ul><li><p><strong>A（Atomicity），原子性</strong></p><p><strong>事务是不可分割的最小执行单位</strong>，事务中的所有操作要么全都完成，要么全都不做。</p></li><li><p><strong>C（Consistency），一致性</strong></p><p>一致性保证将数据库从一种一致的状态转变为另一种一致的状态。<strong>执行事务前后，数据库的完整性约束未被破坏</strong>。</p></li><li><p><strong>I（Isolation），隔离性</strong></p><p>也称并发控制。简而言之，<strong>多个用户并发访问数据库时，一个用户的事务不被其他用户事务干扰，彼此独立</strong>）</p></li><li><p><strong>D（durablity），持久性</strong></p><p><strong>事务一旦提交，其结果就是永久性的</strong>。即使发生宕机，数据库也能将其恢复。保证事务系统的高可靠性。</p></li></ul><h4 id="（3）事务的类型"><a href="#（3）事务的类型" class="headerlink" title="（3）事务的类型"></a>（3）事务的类型</h4><ul><li><p><strong>扁平事务</strong></p><p>最简单，最频繁使用的事务，所有操作处于同一层次，其间操作是原子的，要么都执行，要么都回滚。</p><p>主要限制是不能提交或回滚事务的某一部分，或分几个步骤提交。</p></li><li><p><strong>带保存点的扁平事务</strong></p><p>允许在事务执行过程中回滚到同一事务中较早的一个状态。</p><p>保存点用来通知系统应记住事务当前状态，保存点有易失性，而非持久的，系统宕机后会丢失。</p><blockquote><p>定义保存点的语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure><p>回滚到某个保存点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO 保存点名称</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>链事务</strong></p><p>保存点模式的一种变种。提交事务时将必要的上下文隐式传给下一要开始的个事务，即提交事务操作与下一个事务操作合并为一个原子操作，下个事务可以看到上一个事务的结果，好像在一个事务中进行一样</p></li><li><p><strong>嵌套事务</strong></p><p>一个层级结构框架，由一个顶层事务控制着各个层次的事务，如同一棵树一般；InnoDB引擎并不支持。</p><blockquote><p>嵌套事务是由若干事务组成的一棵树，处在叶子节点的是扁平事务，根节点的事务称为顶层事务，在其他称作子事务。子事务既可以提交也可以回滚，但是任何子事务都必须要顶层事务提交后才真正的提交。</p><p>树中任意一个事务的回滚都会引起它的所有子事务的回滚，故子事务只有ACI，没有D特性。</p><p>可以发现，实际工作是由叶子节点完成的，高层事务只负责逻辑控制。</p><p>虽然可以用保存点技术模拟嵌套事务，但是在锁的持有方面还是有所不同的，用户无法选择哪些锁需要被子事务继承，哪些需要被父事务保留，即无论有多少保存点，所有被锁住的对象都可以被得到访问，所以要实现事务间的并行性，需要真正支持的嵌套事务</p></blockquote></li><li><p><strong>分布式事务</strong></p><p>通常是在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</p><blockquote><p>假设一个用户在ATM机进行银行的转账操作，例如持卡人从招商银行的储蓄卡转账10000元到工商银行的储蓄卡。在这种情况下，可以将ATM机视为节点A，招商银行的后台数据库视为节点B，工商银行的后台数据库视为节点C，这个转账的操作可以分解为以下的步骤：<br>1，节点A发出转账命令；<br>2，节点B执行储蓄卡中的余额值减去10000；<br>3，节点C执行储蓄卡中的余额值加上10000；<br>4，节点A通知用户操作完成或者节点A通过用户操作失败。</p><p>这里需要使用分布式事务，因为节点A不能通过调用一台数据库就完成操作。其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的事务操作又都是扁平的。对于分布式事务，其同样需要满足ACID特性，要么都发送，要么都失效。对于上述的例子，如果2,3步中任何一个操作失败，都会导致整个分布式事务回滚。若非这样，结果会很严重。</p></blockquote></li></ul><p>对于InnoDB存储引擎来说，上面五种只有嵌套事务并不原生支持，因此，<strong>对有并行事务需求的用户来说，MySQL数据库或InnoDB存储引擎就显得无能为力了</strong>。然而用户仍可以通过带有保存点的事务模拟串行的嵌套事务。</p><h4 id="（4）MySQL中事务的用法"><a href="#（4）MySQL中事务的用法" class="headerlink" title="（4）MySQL中事务的用法"></a>（4）MySQL中事务的用法</h4><ul><li><p>开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN|START TRANSACTION</span><br></pre></td></tr></table></figure></li><li><p>提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li><li><p>手动回滚</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure></li><li><p>创建保存点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT identifier</span><br></pre></td></tr></table></figure></li><li><p>回滚到保存点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO identifier</span><br></pre></td></tr></table></figure></li><li><p>设置事务的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET TRANASCTION</span><br></pre></td></tr></table></figure></li><li><p>自动提交</p><p>默认情况下，若不使用BEGIN|START TRANACTION显式的开启事务，那么<strong>每一条语句都算是一个独立的事务，执行完语句立马自动执行COMMIT，这称为事务的自动提交</strong></p></li><li><p>隐式提交</p><p>因为某些特殊语句而导致事务提交的情况称为隐式提交</p><ul><li><p>定义或修改数据库对象的数据定义语言（Data definition language，DDL），所谓数据库对象就是数据库、表、视图等，当我们使用CREATE、ALTER、DROP等语句时，就会隐式提交前边语句所属的事务。</p></li><li><p>隐式使用或修改mysql数据库中的表</p></li><li><p>事务控制或关于锁定的事务</p></li><li><p>……</p></li></ul></li></ul><h4 id="（5）对事务操作的统计"><a href="#（5）对事务操作的统计" class="headerlink" title="（5）对事务操作的统计"></a>（5）对事务操作的统计</h4><p>InnoDB引擎需要在考虑每秒请求数（Question Per Second，QPS）的同时，应该关注每秒事务处理的能力（Transaction Per Second，TPS）。</p><h3 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h3><p>事务的隔离性由锁来实现。持久性由重做日志（redo log）实现。undo log用来帮助事务回滚和MVCC的功能。redo日志基本上是顺序写的，undo log是需要进行随机读写的。</p><h4 id="（1）redo-log"><a href="#（1）redo-log" class="headerlink" title="（1）redo log"></a>（1）redo log</h4><p>redo log再第一章已经介绍过了，这里主要以补充为主。</p><p><strong>什么是redo log</strong></p><p>我们进行的增删查改操作均是在Buffer Pool中进行的，可是如果事务提交后，内存断电导致数据丢失，如何保证事务的持久性呢？一个简单做法是，在事务提交时就将该事务所修改的所有页面都刷新到磁盘，但是这种方法，一方面直接刷新一个完整的数据页太浪费了，毕竟有时仅更改了页面中很少的地方；另一方面该事务所修改的页面可能并不相邻，刷盘需要随机IO。</p><p>为了解决这个问题我们只需要把页面修改的内容记录一下就好，在事务提交时，将其刷到磁盘，但系统崩溃需要恢复时，用其恢复即可。redo日志是顺序写入磁盘的，每执行一条语句，可能产生若干日志，根据产生顺序写入磁盘，即顺序IO</p><p><strong>Mini-Transaction概念</strong></p><p>把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，例如向某个索引对应的<code>B+</code>树中插入一条记录的过程即是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志。</p><img src="/2022/05/17/mysql/image-20210619133229473.png" alt="image-20210619133229473" style="zoom:67%;"><p><strong>fsync操作</strong></p><p>redo log分为两部分：一是内存中的重做日志缓冲（ redo log buffer），是易失的；而是重做日志文件（redo log file），是持久的。</p><p><strong>为了确保每次日志都真正写入到重做日志文件中了</strong>，在每次将重做日志缓冲写入重做日志文件后<strong>，InnoDB引擎都要调用一次fsync操作</strong>。</p><p>fsync的效率取决于磁盘性能，因此磁盘性能也决定了事务提交的性能，也就是数据库的性能。</p><blockquote><p>应用程序向磁盘写入文件时其实是先写到操作系统的文件系统缓存，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的fsync函数。</p><p>如果不进行该操作，当操作系统宕机时，重启数据库后会损失未从文件系统缓存刷新到重做日志文件中的那部分事务。而如果仅数据库宕机的话，并不会有损失。</p></blockquote><p><strong>redo log buffer刷盘时机</strong></p><ul><li>master thread每隔一秒会刷盘一次</li><li>当redo log buffer空间不足一半时</li><li>事务提交时</li><li>log checkpoint时</li></ul><p><strong>LSN（Log Sequence Number）</strong></p><p>其代表的是日志序列号，表示事务写入重做日志的字节的总量。</p><blockquote><p>例如，当前重做日志的LSN为1100，若事务T1写入100字节的重做日志，那么LSN变为1100，T2写入200字节重做日志，LSN变为1300。LSN越小，说明重做日志产生的越早。</p></blockquote><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。全局变量<code>buf_next_to_write</code>，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p><img src="/2022/05/17/mysql/image-20210619141022772.png" alt="image-20210619141022772" style="zoom:67%;"><p>我们前边说<code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，全局变量<code>flushed_to_disk_lsn</code>表示刷新到磁盘中的<code>redo</code>日志量，当该值与lsn相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中</p><p>LSN不仅存在于重做日志文件中，还存在于每个页中，表示该页最后刷新时LSN的大小，用来判断页是否需要进行恢复操作。</p><p><strong>恢复</strong></p><p>checkpoint表示已经刷新到磁盘页上的LSN，因此恢复时只需要恢复checkpoint开始的日志部分，即恢复大于checkpoint LSN的日志。</p><h4 id="（2）undo-log"><a href="#（2）undo-log" class="headerlink" title="（2）undo log"></a>（2）undo log</h4><ul><li><p>为了<strong>保证事务的原子性，需要支持回滚操作</strong>，所以每当我们要进行增删改操作时，需要留一手——将回滚时需要的东西记下来，这就需要undo log。undo log存放数据库内部的一个特殊段——undo段，其位于共享表空间。</p></li><li><p><strong>undo log是逻辑日志，只是将数据库逻辑地恢复到原来地样子，使所有的修改都被逻辑地取消</strong>，但是数据结构和页本身回滚后可能大不相同，因为在多用户并发系统中，可能有多个事务同时对同一页中地记录做修改，<strong>所以一个事务的回滚并不能将页回滚到事务开始前的样子，因为这样会影响其他事务正在进行的工作。</strong></p></li><li><p>当将插入事务回滚时，表空间的大小并不会因此而收缩。<strong>回滚时，实际上做的是与之前相反的操作，对于每个INSERT，相应的都有一个DELETE来抵消掉。</strong></p></li><li><p>除了回滚操作，另一个作用就是<strong>MVCC。当用户读取一行记录时，若该记录已被其他事务占用，当前事务可通过undo读取之前的行版本信息，以实现非锁定读取。</strong></p></li><li><p>最后，undo log的产生也会产生redo log，因为undo log也需要持久化保护。</p></li><li><p><strong>事务提交时</strong>，InnoDB引擎会做两件事：</p><ul><li>将<strong>undo log放入链表中，是否最终删除由purge线程来判断操作</strong></li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul><p><strong>事务提交后，并不能马上删除undo log和其所在的页，因为可能还有其他事务需要通过undo log来得到行记录之前的版本</strong></p></li><li><p>undo log格式</p><ul><li><p>insert undo log</p><p><strong>因为insert操作的记录只对本事务可见，这是事务隔离性的要求，所以该undo log可以在事务提交后直接删除，无需purge操作</strong></p></li><li><p>update undo log</p><p><strong>针对delete操作和update操作产生。该undo log可能需要支持MVCC机制，所以不能直接删除，提交时放入链表，候purge发落</strong></p></li></ul></li></ul><h4 id="（3）purge"><a href="#（3）purge" class="headerlink" title="（3）purge"></a>（3）purge</h4><p>执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位。</p><p>而purge用于最终完成delete和update操作。因为InnoDB支持MVCC，事务提交时不能立即进行处理，因为其他事务可能也正在应用同一行记录。所以需要保存记录之前的版本。当该记录不被任何其他事务引用时，方可被后台purge进程真正删除。</p><h3 id="3、事务的隔离级别"><a href="#3、事务的隔离级别" class="headerlink" title="3、事务的隔离级别"></a>3、事务的隔离级别</h3><blockquote><p><code>MySQL</code>是一个<code>客户端／服务器</code>架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（<code>Session</code>）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。</p><p>事务有个特性称为<code>隔离性</code>，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这种串行化方式性能较差，我们既想保持事务的<code>隔离性</code>，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，所以隔离性和性能要有所取舍。</p></blockquote><h4 id="（1）事务并发执行时会遇到的问题"><a href="#（1）事务并发执行时会遇到的问题" class="headerlink" title="（1）事务并发执行时会遇到的问题"></a>（1）事务并发执行时会遇到的问题</h4><ul><li><p><strong>脏写（dirty write）</strong></p><p>如果一个事务修改了另一个未提交事务修改过的数据，即发生了脏写</p></li><li><p><strong>脏读（dirty read）</strong></p><p>如果一个事务读取了另一个未提交事务修改过的数据，即发生了脏读</p></li><li><p><strong>不可重复读（non-repeatable read）</strong></p><p>如果一个事务只能读到已提交的事务修改过的数据，而且其他事务每对该数据进行修改并提交后，该事务都能查询到最新值，即发生了不可重复读</p></li><li><p><strong>幻读（plantom read）</strong></p><p>如果一个事务先根据某些条件查询出一些记录后，之后另一个事务又插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读。</p><blockquote><p>幻读强调的是一个事务按照某个相同条件多次读取记录时，后读时读到了之前没读到的记录。对于先前已读到，后读又未读到的情况相当于对每一条记录都发生了不可重复读现象。</p></blockquote></li></ul><h4 id="（2）SQL标准中的隔离级别"><a href="#（2）SQL标准中的隔离级别" class="headerlink" title="（2）SQL标准中的隔离级别"></a>（2）SQL标准中的隔离级别</h4><ul><li><p><strong>READ UNCOMMITTED：未提交读</strong></p><p>一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p><strong>READ COMMITTED：已提交读</strong></p><p>一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p><strong>REPEATABLE READ：可重复读</strong></p><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，除非是自己修改的数据。</p></li><li><p><strong>SERIALIZABLE：可串行化</strong></p><p>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，所有事务必须逐个<strong>串行执行</strong>。</p></li></ul><p>由于脏写问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p><strong>举例：</strong></p><p>下面是按照时间顺序执行两个事务的行为：</p><img src="/2022/05/17/mysql/image-20210620093451941.png" alt="image-20210620093451941" style="zoom:50%;"><ul><li>若隔离级别是“未提交读”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</li><li>若隔离级别是“已读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li></ul><p>在实现上，数据库里面会<strong>创建一个视图</strong>，访问的时候以视图的逻辑结果为准。在“<strong>可重复读</strong>”隔离级别下，这个视图是在<strong>事务启动时</strong>创建的，整个事务存在期间都用这个视图。在“<strong>已提交读</strong>”隔离级别下，这个视图是在<strong>每个SQL语句开始执行</strong>的时候创建的。</p><p>这里需要注意的是，“<strong>未提交读</strong>”隔离级别下<strong>直接返回记录上的最新值，没有视图</strong>概念；而“<strong>串行化</strong>”隔离级别下直接用<strong>加锁</strong>的方式来避免并行访问。</p><blockquote><p>每个隔离级别都有它自己的使用场景，根据业务情况来定。那什么时候需要“<strong>可重复读”的场景</strong>呢？</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p></blockquote><h4 id="（3）MySQL中支持的四种隔离级别"><a href="#（3）MySQL中支持的四种隔离级别" class="headerlink" title="（3）MySQL中支持的四种隔离级别"></a>（3）MySQL中支持的四种隔离级别</h4><p>不同的数据库厂商对<code>SQL标准</code>中规定的四种隔离级别支持不一样，比方说<code>Oracle</code>就只支持<code>READ COMMITTED</code>和<code>SERIALIZABLE</code>隔离级别。</p><p>MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，<strong>MySQL在REPEATABLE READ隔离级别下，使用Next-Key Lock锁的算法，是可以禁止幻读问题的发生的，即达到SQL标准中的SERIALIZABLE级别</strong></p><p><code>MySQL</code>的默认隔离级别为<code>REPEATABLE READ</code>，我们可以手动修改一下事务的隔离级别。</p><p>我们可以通过下边的语句修改事务的隔离级别：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure><p>其中的<code>level</code>可选值有4个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">level: &#123;</span><br><span class="line">     REPEATABLE READ</span><br><span class="line">   | READ COMMITTED</span><br><span class="line">   | READ UNCOMMITTED</span><br><span class="line">   | SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、MVCC"><a href="#4、MVCC" class="headerlink" title="4、MVCC"></a>4、MVCC</h3><h4 id="（1）版本链"><a href="#（1）版本链" class="headerlink" title="（1）版本链"></a>（1）版本链</h4><p>在可重复读隔离级别下，<strong>事务在启动的时候就“拍了个快照”</strong>。注意，这个快照是基于整库的。实际上，我们并不需要拷贝出整个数据库的数据。我们先来看看<strong>这个快照是怎么实现的？</strong></p><p>InnoDB里面<strong>每个事务有一个唯一的事务ID</strong>，叫作trx_id（transaction id）。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>而<strong>每行数据也都是有多个版本的</strong>。<strong>每次事务更新数据的时候，都会生成一个新的数据版本，并且把trx_id赋值给这个数据版本的事务ID</strong>，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>即<strong>数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id</strong>。下图就是一个记录被多个事务连续更新后的状态。</p><img src="/2022/05/17/mysql/image-20210623092105620.png" alt="image-20210623092105620" style="zoom:67%;"><p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p><p>之前说过，语句更新会生成undo log吗？那么，<strong>undo log在哪呢？</strong></p><p>实际上，图中的三个虚线箭头，就是undo log；而V1、V2、<strong>V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的</strong>。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p><blockquote><p>实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它对MVCC没什么用，它没有历史版本。它占用的Undo Log Segment也会被系统回收。</p></blockquote><h4 id="（2）ReadView"><a href="#（2）ReadView" class="headerlink" title="（2）ReadView"></a>（2）ReadView</h4><blockquote><p>前面已说过，对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好；对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，使用加锁方式来访问记录即可；</p></blockquote><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，<strong>都必须保证读到已经提交了的事务修改过的记录</strong>，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的。</strong></p><blockquote><p>在MySQL里，有两个“视图”的概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li><li>另一个是InnoDB在实现MVCC时用到的<strong>一致性读视图</strong>，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”</p></blockquote><p>为此，提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含4个比较重要的内容：</p><ul><li><p><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中<strong>活跃（启动还未提交）的读写事务的<code>事务id</code>列表</strong>。</p></li><li><p><code>min_trx_id</code>（低水位）：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是**<code>m_ids</code>中的最小值**。</p></li><li><p><code>max_trx_id</code>（高水位）：表示生成<code>ReadView</code>时系统中<strong>应该分配给下一个事务的<code>id</code>值</strong>，即已经创建过的事务ID的最大值加1</p></li><li><p><code>creator_trx_id</code>：表示<strong>生成该<code>ReadView</code>的事务</strong>的<code>事务id</code>。</p><img src="/2022/05/17/mysql/image-20210623090557325.png" alt="image-20210623090557325" style="zoom: 67%;"></li></ul><p></p><p>有了这个<code>ReadView</code>，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li><p>如果被访问版本的<code>trx_id</code><strong>等于<code>creator_trx_id</code><strong>值，表明当前事务</strong>在访问它自己修改过的记录</strong>，该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>落在<strong>绿色部分</strong>，表明<strong>生成该版本的事务</strong>在当前事务生成<code>ReadView</code><strong>前已提交</strong>，该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>落在<strong>红色部分</strong>，表明<strong>生成该版本的事务</strong>在当前事务生成<code>ReadView</code><strong>后才开启</strong>，该版本不可被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>落在<strong>黄色部分</strong>，若其<strong>在<code>m_ids</code>列表中</strong>，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的<strong>尚未提交</strong>，该版本不可以被访问；<strong>若不在，说明创建<code>ReadView</code>时生成该版本的事务</strong>已经被提交，该版本可以被访问。</p></li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。</p><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们<strong>生成ReadView的时机不同</strong>：</p><ul><li>READ COMMITTED：该隔离级别的事务，在每次语句执行前都会生成一个独立的ReadView。</li><li>REPEATABLE READ：该隔离级别的事务，只需在事务真正开始时生成一个ReadView，之后事务里的其他查询不会再重复生成。</li></ul><h4 id="（3）实例"><a href="#（3）实例" class="headerlink" title="（3）实例"></a>（3）实例</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure><img src="/2022/05/17/mysql/image-20210623094909325.png" alt="image-20210623094909325" style="zoom:67%;"><p>如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1</p></blockquote><p><strong>Case1:</strong></p><p>这里，我们不妨做如下假设：</p><ol><li>事务A开始前，系统里面只有一个活跃事务ID是99；</li><li>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的row trx_id是90。</li></ol><p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。</p><p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p><img src="/2022/05/17/mysql/image-20210623094956694.png" alt="image-20210623094956694" style="zoom: 50%;"><p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p><p>第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p><p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p><p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p><p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p>现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：</p><ul><li>(1,3)还没提交，属于情况1，不可见；</li><li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li><li>(1,1)是在视图数组创建之前提交的，可见。</li></ul><p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来轻松很多。</p><p><strong>Case2:</strong></p><p>事务B的update语句，如果按照一致性读，好像结果不对？事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p><p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p><p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，<strong>select语句如果加锁，也是当前读。</strong></p><p>所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或 for update，<strong>也都可以读到版本号是101的数据，返回的k的值是3</strong>。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select k from t where id=1 lock in share mode;</span><br><span class="line">mysql&gt; select k from t where id=1 for update;</span><br></pre></td></tr></table></figure><p><strong>Case3:</strong></p><p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p><img src="/2022/05/17/mysql/image-20210623100749573.png" alt="image-20210623100749573" style="zoom:67%;"><p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p><p>这时候，根据“<strong>两阶段锁协议</strong>”。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p><p>到这里，我们把一致性读、当前读和行锁就串起来了。</p><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><h4 id="（4）小结"><a href="#（4）小结" class="headerlink" title="（4）小结"></a>（4）小结</h4><p><strong>MVCC</strong>（Multi-Version Concurrency Control ，<strong>多版本并发控制</strong>）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务<strong>在执行普通的查询操作时访问记录的版本链的过程</strong>，可以<strong>实现事务的并发执行，从而提升系统性能</strong>。</p><p>MVCC，<strong>就是通过生成一个<code>ReadView</code>，然后通过<code>ReadView</code>找到符合条件的行记录版本</strong>（历史版本是由<code>undo日志</code>构建的），其实就像是在<strong>生成<code>ReadView</code>的那个时刻</strong>拍了一个<strong>快照</strong>，<strong>查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，在生成<code>ReadView</code>之前未提交的事务或者之后才开启的事务所做的更改是看不到的</strong>。</p><p>解决了脏读、不可重复读、幻读的问题。</p><p>以“REPEATABLE READ”为例概括下事务隔离的实现：</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><img src="/2022/05/17/mysql/image-20210620104225122.png" alt="image-20210620104225122" style="zoom: 67%;"><p>当前值是4，但是在查询这条记录的时候，<strong>不同时刻启动的事务会有不同的read-view</strong>。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p><p><strong>回滚日志总不能一直保留，具体什么时候可以删除呢？</strong></p><p>就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p><strong>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务？</strong></p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h3 id="5、不好的事务习惯"><a href="#5、不好的事务习惯" class="headerlink" title="5、不好的事务习惯"></a>5、不好的事务习惯</h3><h4 id="（1）在循环中提交"><a href="#（1）在循环中提交" class="headerlink" title="（1）在循环中提交"></a>（1）在循环中提交</h4><p>当发生错误时，数据库会停留在一个未知的位置。例如，用户需要插入10000条用户记录，在第5000条时，发生了错误，这时前面的记录都已经提交，并存在数据库中了，此时该如何处理？</p><p>另一个问题是性能问题，每次提交都要写一次重做日志，相比于将所有操作放在一个事务中进行，无疑增加了大量的性能损耗。</p><h4 id="（2）使用自动提交"><a href="#（2）使用自动提交" class="headerlink" title="（2）使用自动提交"></a>（2）使用自动提交</h4><p>编写应用程序开发时，最好把事物的控制权交给开发人员，即在程序端进行事务的开始和结束。</p><h4 id="（3）使用自动回滚"><a href="#（3）使用自动回滚" class="headerlink" title="（3）使用自动回滚"></a>（3）使用自动回滚</h4><p>对于开发人员来说，重要的不是知道发生了错误，而是发生了什么样的错误，因此自动回滚存在这样一个问题。</p><h2 id="七、锁"><a href="#七、锁" class="headerlink" title="七、锁"></a>七、锁</h2><h3 id="1、并发事务带来的问题"><a href="#1、并发事务带来的问题" class="headerlink" title="1、并发事务带来的问题"></a>1、并发事务带来的问题</h3><p>并发事务访问相同记录情况有三：</p><h4 id="（1）读-读"><a href="#（1）读-读" class="headerlink" title="（1）读 - 读"></a>（1）<strong>读 - 读</strong></h4><p>没问题，允许发生</p><h4 id="（2）写-写"><a href="#（2）写-写" class="headerlink" title="（2）写 - 写"></a>（2）写 - 写</h4><p>可能发生脏写，不允许。多个未提交事务相继修改同一记录时，是要排队执行，通过锁实现。所谓锁其实是一种内存中的结构，当事务要对该记录做改动时，首先检查有无与该记录关联的锁结构，没有则添加一个。</p><img src="/2022/05/17/mysql/image-20210621080748105.png" alt="image-20210621080748105" style="zoom: 50%;"><p>上述简化锁结构：</p><ul><li><p>trx信息：表示该锁是哪个事务生成的</p></li><li><p>is_waiting：表示当前事务是否在等待</p></li></ul><p>当事务T1加锁成功后（is_waiting为false），事务可以正常执行；当T2也想改动该记录时，发现已有锁结构与之关联，于是也生成一个锁结构（is_waiting为true，表示当前事务需要等待），加锁失败。T1提交后，会把其锁结构释放掉，把T2对应线程唤醒，继续执行。</p><img src="/2022/05/17/mysql/image-20210621081250690.png" alt="image-20210621081250690" style="zoom:50%;"><h4 id="（3）读-写"><a href="#（3）读-写" class="headerlink" title="（3）读 - 写"></a>（3）<strong>读 - 写</strong></h4><p>可能发生脏读、不可重复读、幻读。</p><h4 id="（4）如何解决读-写带来的问题"><a href="#（4）如何解决读-写带来的问题" class="headerlink" title="（4）如何解决读-写带来的问题"></a>（4）如何解决读-写带来的问题</h4><ul><li><p><strong>方案一：读操作利用MVCC，写操作加锁</strong></p><p>MVCC前面已介绍过，<strong>就是通过生成一个<code>ReadView</code>，然后通过<code>ReadView</code>找到符合条件的记录版本</strong>（历史版本是由<code>undo日志</code>构建的），其实就像是在<strong>生成<code>ReadView</code>的那个时刻</strong>做了一次时间静止（就像用相机拍了一个<strong>快照</strong>），<strong>查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，在生成<code>ReadView</code>之前未提交的事务或者之后才开启的事务所做的更改是看不到的</strong>。而<strong>写操作针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用<code>MVCC</code>时，<code>读-写</code>操作并不冲突。</strong></p></li><li><p><strong>方案二：读写操作均加锁</strong></p><p>如果我们的一些<strong>业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本</strong>。比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在<strong>读取记录的时候也就需要对其进行<code>加锁</code>操作</strong>，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p><blockquote><ul><li><p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果<strong>另一个事务在写记录的时候就给这条记录加锁（写加锁），那么当前事务就无法继续读取该记录</strong>了，所以也就不会有脏读问题的产生了。</p></li><li><p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在<strong>当前事务读取记录时就给该记录加锁（读加锁），那么另一个事务就无法修改该记录</strong>，自然也不会发生不可重复读了。</p></li><li><p>幻读的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把<strong>新插入的那些记录称之为幻影记录</strong>。加锁的方式解决幻读问题就麻烦了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候并不知道给哪条记录加锁，这个下面会讲。</p></li></ul></blockquote><p>显然，采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。但具体还需看业务场景</p></li></ul><h3 id="2、锁的理论知识"><a href="#2、锁的理论知识" class="headerlink" title="2、锁的理论知识"></a>2、锁的理论知识</h3><h4 id="（1）一致性读"><a href="#（1）一致性读" class="headerlink" title="（1）一致性读"></a>（1）一致性读</h4><p><strong>事务利用MVCC进行的读取操作称为一致性读，也称快照读</strong>，所有<strong>普通的SELECT语</strong>句（plain SELECT）在 READ COMMITED 和 REPEATABLE READ隔离级别下都算是一致性读。<strong>一致性读不会对表中任何记录进行加锁，其他事务可以自由对表中记录做改动。</strong></p><h4 id="（2）锁定读"><a href="#（2）锁定读" class="headerlink" title="（2）锁定读"></a>（2）锁定读</h4><blockquote><p>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。</p></blockquote><p><strong>也称当前读，读取的是最新版本，使用加锁方式，既要满足读-读操作不受影响，也要使写-写、读-写情况中的操作相互阻塞</strong>，所以设计了两种锁：</p><ul><li>共享锁（Shared Locks，S锁）。事务读取一条记录时，需要先获取该记录的S锁。</li><li>独占锁（Exclusive Locks，X锁）。事务改动一条记录前，需先获取该记录的X锁。</li></ul><p>S锁只和S锁兼容，X锁与任意锁都不兼容。</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>S</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">兼容</td></tr></tbody></table><p><strong>锁定读的语句：</strong></p><p>有时想在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此设计了两种特殊的SELECT语句：</p><ul><li>对读取的记录加S锁</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><ul><li>对读取的记录加X锁</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure><h4 id="（3）写操作"><a href="#（3）写操作" class="headerlink" title="（3）写操作"></a>（3）写操作</h4><p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p><ul><li><p><code>DELETE</code>：</p><p>对一条记录做<code>DELETE</code>操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取一下这条记录的<code>X锁</code>，然后再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p><code>UPDATE</code>：</p><p>在对一条记录做<code>UPDATE</code>操作时分为三种情况：</p><ul><li><p>如果未修改该记录的主键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p>如果未修改该记录的主键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p></li><li><p>如果修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</p></li></ul></li><li><p><code>INSERT</code>：</p><p>一般情况下，新插入一条记录的操作并不加锁，<code>InnoDB</code>存储引擎通过一种称之为<code>隐式锁</code>来保护这条新插入的记录在本事务提交前不被别的事务访问。</p></li></ul><h4 id="（4）多粒度锁"><a href="#（4）多粒度锁" class="headerlink" title="（4）多粒度锁"></a>（4）多粒度锁</h4><p>我们前边提到的<code>锁</code>都是针对记录的，称之为<code>行级锁</code>或者<code>行锁</code>，细粒度锁；其实一个事务也可以在<code>表</code>级别进行加锁，称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，粗粒度锁。给表加的锁也可以分为<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>）。</p><p><strong>InnoDB支持多粒度锁定，即允许事务在行级和表级上的锁同时存在</strong>，为了支持该操作，InnoDB还提供了一种额外的加锁方式，称为意向锁，其是表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁类型：</p><ul><li><strong>意向共享锁</strong>（Intention Shared Lock）：事务想要获得一张表中某几行的共享锁。（当事务准备在某条记录上加S锁时，需要先在表级别上加个IS锁）</li><li><strong>意向独占锁</strong>（Intention Exclusive Lock）：事务想要获得一张表中某几行的独占锁。（当事务准备在某条记录上加X锁时，需要先在表级别上加个IX锁）</li></ul><p><strong>总结：</strong></p><p>IS、IX锁是表级锁，它们的提出仅仅<strong>为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录</strong>，也就是说其实IS锁之间均是互相兼容的。IS锁与X锁不兼容，IX锁与S锁、X锁均不兼容。</p><p>​       </p><p>​     </p><h3 id="3、MySQL中的行锁和表锁"><a href="#3、MySQL中的行锁和表锁" class="headerlink" title="3、MySQL中的行锁和表锁"></a>3、MySQL中的行锁和表锁</h3><h4 id="（1）其他存储引擎中的锁"><a href="#（1）其他存储引擎中的锁" class="headerlink" title="（1）其他存储引擎中的锁"></a>（1）其他存储引擎中的锁</h4><p>针对MyISAM、MEMORY、MERGE这些存储引擎来说，<strong>只支持表级锁</strong>，而且这些引擎<strong>也不支持事务</strong>，所以使用这些存储引擎的锁一般都是<strong>针对当前会话</strong>来说。</p><p>由于使用这些存储引擎的表在<strong>同一时刻只允许一个会话对表进行写操作，所以这些存储引擎最好用在只读或大部分都是读操作，或单用户（即单会话）的情景下。</strong></p><p>此外，在MyISAM中有个Concurrent Inserts的特性，<strong>支持在对MyISAM表读取时同时插入记录，可以提升一些插入速度。</strong></p><h4 id="（2）InnoDB存储引擎中的表级锁"><a href="#（2）InnoDB存储引擎中的表级锁" class="headerlink" title="（2）InnoDB存储引擎中的表级锁"></a>（2）InnoDB存储引擎中的表级锁</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。</p><ul><li><p><strong>表级的S锁和X锁</strong></p><p>鸡肋，基本不用</p></li><li><p><strong>表级的IS锁和IX锁</strong></p><p>当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>，X锁类似。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p></li><li><p><strong>表级的AUTO-INC锁</strong></p><p>略</p></li></ul><h4 id="（3）InnoDB存储引擎中的行级锁"><a href="#（3）InnoDB存储引擎中的行级锁" class="headerlink" title="（3）InnoDB存储引擎中的行级锁"></a>（3）InnoDB存储引擎中的行级锁</h4><blockquote><p><strong>InnoDB的行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。</strong></p></blockquote><ul><li><p><strong>Record Locks</strong></p><p>记录锁，仅仅是把一条记录锁上。官方名称是：LOCK_REC_NOT_GAP 。</p></li><li><p><strong>Gap Locks</strong></p><p>间隙锁，锁定一个范围，但不包括记录本身</p><p>MySQL在REPEATABLE READ隔离级别下是可以<strong>解决幻读</strong>问题的。</p><blockquote><p><strong>在RR的隔离级别下，Innodb使用MVCC和next-key locks解决幻读，MVCC解决的是一致性读读（快照读）的幻读，next-key locks解决的是当前读（锁定读）情况下的幻读。</strong></p></blockquote><p><strong>除了用MVCC方案解决，也可用加锁方案解决</strong>，但<strong>问题在于事务在第一次读取时，幻影记录尚不存在，无法对其上锁</strong>。因此提出一种Gap Locks锁，官方名称LOCK_GAP。</p><img src="/2022/05/17/mysql/image-20210621104917562.png" alt="image-20210621104917562" style="zoom:50%;"><p>如图，给number为8的记录加了gap锁，意味着不允许别的事务在8前面的间隙插入新纪录，即number为（3，8）这个区间的新纪录不允许立即插入。</p><p>如果对一条记录加了gap锁，并不妨碍其他事务对该记录加record锁或gap锁。</p></li><li><p><strong>Next - Key Locks</strong></p><p>有时<strong>既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新纪录</strong>，所以设计了一种Next- Key Locks，官称LOCK_ORDINARY。</p><img src="/2022/05/17/mysql/image-20210621105636494.png" alt="image-20210621105636494" style="zoom:50%;"><p>本质就是一个record锁和一个gap锁的合体，它<strong>既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙</strong>。</p></li><li><p><strong>Inert Intention Locks</strong></p><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>，后边就不强调了），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。InnoDB引擎规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待，于是命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，可以称为<code>插入意向锁</code>。</p></li><li><p><strong>隐式锁</strong></p><p>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态</p></li></ul><h4 id="（4）InnoDB锁的内存结构"><a href="#（4）InnoDB锁的内存结构" class="headerlink" title="（4）InnoDB锁的内存结构"></a>（4）InnoDB锁的内存结构</h4><p>为了节约成本，一个事务在对不同记录加锁时，若符合以下条件，那么这些记录的锁就可以被放到同一个锁结构中。</p><ul><li><p>在同一个事务中进行加锁操作</p></li><li><p>被加锁的记录在同一个页面中</p></li><li><p>加锁的类型是一样的</p></li><li><p>等待状态是一样的</p><img src="/2022/05/17/mysql/image-20210623080034901.png" alt="image-20210623080034901" style="zoom:67%;"></li></ul><p></p><h4 id="（5）两阶段锁协议"><a href="#（5）两阶段锁协议" class="headerlink" title="（5）两阶段锁协议"></a>（5）两阶段锁协议</h4><p>在InnoDB事务中，<strong>行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等事务提交才释放，这即两阶段锁协议</strong>。</p><p>针对该协议，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><blockquote><p>例如：假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。这个业务需要涉及到以下操作：</p><ol><li>从顾客A账户余额中扣除电影票价；</li><li>给影院B的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，如何安排这三个语句在事务中的顺序呢？</p></blockquote><p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地<strong>减少了事务之间的锁等待，提升了并发度。</strong></p><h4 id="（6）死锁和死锁检测"><a href="#（6）死锁和死锁检测" class="headerlink" title="（6）死锁和死锁检测"></a>（6）死锁和死锁检测</h4><p>当并发系统中<strong>不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时</strong>，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><img src="/2022/05/17/mysql/image-20210623082020263.png" alt="image-20210623082020263" style="zoom: 50%;"><p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>策略一：直接进入<strong>等待，直到超时</strong>。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>策略二：<strong>发起死锁检测</strong>，发现死锁后，主动<strong>回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>一般采用第二种策略。但主动死锁检测也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><blockquote><p>如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p></blockquote><p>由这种热点行更新导致的性能问题的症结在于，死锁检测要耗费大量的CPU资源。</p><ul><li><p><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p></li><li><p><strong>另一个思路是控制并发度。</strong>如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。客户端做并发控制不太现实，因为客户端太多。即使每个客户端并发数控制得很低，所有客户端汇集起来也很高。因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现</p></li><li><p>除此之外，还可以从设计上优化这个问题呢，可以考虑通过<strong>将一行改成逻辑上的多行来减少锁冲突</strong>。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p></li></ul><h2 id="八、补充"><a href="#八、补充" class="headerlink" title="八、补充"></a>八、补充</h2><h3 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h3><p>一条查询语句在经过MySQL的<strong>优化器</strong>后会生成一个<strong>执行计划</strong>。这个计划展示了具体的查询方式，比如多表连接的顺序是什么、使用哪个索引来进行查询等；可以使用<strong>Explain语句</strong>来查看某个语句的具体执行计划。</p><p>Explain语句输出的列有：</p><table><thead><tr><th align="center">列名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>id</code></td><td align="left">在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td></tr><tr><td align="center"><code>select_type</code></td><td align="left"><strong>每个SELECT关键字对应的那个查询的类型，有简单查询、联合查询、子查询</strong></td></tr><tr><td align="center"><code>table</code></td><td align="left">表名</td></tr><tr><td align="center"><code>partitions</code></td><td align="left">匹配的分区信息</td></tr><tr><td align="center"><code>type</code></td><td align="left"><strong>针对单表的访问方法</strong></td></tr><tr><td align="center"><code>possible_keys</code></td><td align="left"><strong>可能用到的索引</strong></td></tr><tr><td align="center"><code>key</code></td><td align="left"><strong>实际上使用的索引</strong></td></tr><tr><td align="center"><code>key_len</code></td><td align="left">实际使用到的索引长度</td></tr><tr><td align="center"><code>ref</code></td><td align="left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td align="center"><code>rows</code></td><td align="left"><strong>估算的返回结果集记录数目</strong></td></tr><tr><td align="center"><code>filtered</code></td><td align="left">某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td align="center"><code>Extra</code></td><td align="left">一些额外的信息</td></tr></tbody></table><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的<strong>table列代表着该表的表名</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>select_type：</strong></p><p><img src="/2022/05/17/mysql/image-20210829174405432.png" alt="image-20210829174405432"></p><p><strong>type：</strong></p><ul><li>const：通过主键索引或唯一键索引来定位一条记录的访问方法</li><li>ref：使用某个普通的二级索引列与常数值等值比较的访问方法</li><li>range：利用索引值进行范围匹配的访问方法</li><li>index：</li><li>all：全表扫描，对于InnoDB表来说就是直接扫描聚簇索引</li></ul><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL中通过慢查询日志用来记录响应时间超过阈值的SQL语句。</p><p>主要有三个重要的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%query%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>slow_query_log：OFF，是否开启慢查询日志，默认是关闭的，因为开启会带来些许性能损耗；</li><li>long_query_time：10，定义阈值，默认是10s，响应时间超过10秒的语句就被定义为慢语句，记录到慢查询日志中；</li><li>slow_query_log_file：&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow**.**log，定义慢查询日志所在的位置；</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global slow_query_log = ON;</span><br><span class="line">set global slow_query_time = 1;</span><br></pre></td></tr></table></figure><p>这种方法只对当前数据库生效，MySQL重启后则会失效；如果要永久生效，必须修改配置文假案my.cnf</p><p>可以使用<strong>日志分析工具mysqldumpslow来查看慢查询日志</strong>；</p><p>可以通过 <strong>show processlist来查看正在进行的慢查询SQL</strong>，show processlist 显示哪些线程正在运行</p><p><img src="/2022/05/17/mysql/image-20210829172810676.png" alt="image-20210829172810676"></p><p>定位到慢查询SQL后，首先分析语句，看是否读取了额外的不必要的列，然后使用<strong>Explain命令分析SQL的执行计划</strong>并进行相应的优化：</p><ul><li>如果是因为没走索引，可以考虑<strong>建立合适的索引</strong>；</li><li>优化器可以选择了错误的索引导致效率低下，可以修改SQL语句逻辑<strong>引导优化器选择正确的索引</strong>，或者<strong>强制使用</strong>（force index）合适的索引</li><li>如果因为数据库表太大，即使走了索引也依然很慢，可以考虑分表；</li></ul><h3 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h3><h4 id="SQL约束有哪些"><a href="#SQL约束有哪些" class="headerlink" title="SQL约束有哪些"></a>SQL约束有哪些</h4><ul><li>非空约束：NOT NULL，约束字段内容不能为空；</li><li>唯一约束：UNIQUE，约束字段内容不能重复，一个表可以有多个唯一约束；</li><li>主键约束：PRIMARY KEY，约束字段为主键，主键值唯一，一个表只能有一个；</li><li>外键约束：</li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h4 id="delete、drop和truncate的区别"><a href="#delete、drop和truncate的区别" class="headerlink" title="delete、drop和truncate的区别"></a><strong>delete、drop和truncate的区别</strong></h4><ul><li>delete<strong>删除表的全部或者部分数据行</strong>，表结构还在，删除速度比较慢，需要逐行删除，可以回滚；</li><li>truncate<strong>删除表中的全部数据</strong>，表结构还在，删除速度比较快，不可回滚；</li><li>drop<strong>从数据库中删除整张表</strong>，所有的数据行、索引等都会被删除，删除速度最快，不可回滚；</li></ul><p>truncate和drop都属于DDL（数据库定义语言），而delete属于属于DML（数据库操作语言）</p><ul><li><strong>DML，数据库操作语言</strong>，包括常用的增删改查等常用操作，只涉及对表中数据的操作；</li><li><strong>DDL，数据库定义语言</strong>，会涉及到对表的定义结构的修改，开发人员较少使用，更多由DBA（数据库管理员）使用；</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> msyql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 日志</title>
      <link href="/2022/05/17/springboot%E6%97%A5%E5%BF%97/"/>
      <url>/2022/05/17/springboot%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot-日志"><a href="#SpringBoot-日志" class="headerlink" title="SpringBoot 日志"></a>SpringBoot 日志</h3><h4 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h4><p>JUL、JCL、jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志的抽象层</th><th>日志的实现</th></tr></thead><tbody><tr><td><del>JCL(jakarta commons logging)</del>     SLF4J(Simple Logging Facade for Java)    <del>jboss-logging</del></td><td>Log4j  JUL(java.util.logging)  Log4j2   Logback</td></tr></tbody></table><p>日志门面：SLF4J;</p><p>日志实现：Logback</p><p>SpringBoot:底层是Spring框架，Spring框架默认的是JCL</p><p>SpringBoot选用的是SLF4J和Logback</p><h4 id="2-SLF4J使用"><a href="#2-SLF4J使用" class="headerlink" title="2.SLF4J使用"></a>2.SLF4J使用</h4><h5 id="1-如何在系统中使用SLF4J"><a href="#1-如何在系统中使用SLF4J" class="headerlink" title="1.如何在系统中使用SLF4J"></a>1.如何在系统中使用SLF4J</h5><p>以后开发的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里的方法。</p><p>给系统里面导入SLF4J的jar和logback的jar。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/springboot%E6%97%A5%E5%BF%97/slf5j.png" alt="slf5j"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志框架自己本身的配置文件。</strong></p><h5 id="2-遗留问题"><a href="#2-遗留问题" class="headerlink" title="2. 遗留问题"></a>2. 遗留问题</h5><p>a系统使用（slf4j+logback）:Spring(commons-logging),Hibernate(jboss-logging),Mybatis,xxx</p><p>统一日志记录，即使是别的框架和我仪器统一使用slf4j进行输出。</p><p><img src="/2022/05/17/springboot%E6%97%A5%E5%BF%97/legacy.png" alt="legacy"></p><blockquote><p>如何让系统中所有的日志都统一到slf4j:</p><ol><li>将系统中其他日志框架先排除出去；</li><li>用中间包替换原有的日志框架；</li><li>导入slf4j其他的实现。</li></ol></blockquote><h4 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot使用它来启动日志：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/springboot%E6%97%A5%E5%BF%97/image-20211013220417367-1634133859595.png" alt="image-20211013220417367"></p><p>总结：</p><ul><li><p>SpringBoot底层也是使用slf4j+logback的方式记录日志</p></li><li><p>SpringBoot也把其他的日志都替换成了slf4j;</p></li><li><p>中间的替换包</p></li><li><p>如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除调。</p><ul><li><img src="/2022/05/17/springboot%E6%97%A5%E5%BF%97/image-20211013221847468-1634134728410.png" alt="image-20211013221847468"></li></ul><p><strong>现在的 版本已经没有移除这一属性了</strong></p></li></ul><p><strong>SpringBoot能自动适配所有的日志，而且顶层使用slf4j+logback的方式记录日志，引入其他日志框架的时候，只需要把这个框架依赖的日志框架排除掉。</strong></p><h4 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h4><h5 id="1-默认配置"><a href="#1-默认配置" class="headerlink" title="1.默认配置"></a>1.默认配置</h5><p>SpringBoot默认帮我们配置好了日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootLoggingApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//记录器</span></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//日志的级别：</span></span><br><span class="line">        <span class="comment">//由低到高：trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">        <span class="comment">//可以调整输出的日志级别：日志就只会在这个级别及以后的高级别生效</span></span><br><span class="line">        logger.trace(<span class="string">&quot;这是trace日志...&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;这是debug日志...&quot;</span>);</span><br><span class="line">        <span class="comment">//spring boot默认是info级别的,没有指定级别的就用SpringBoot默认的级别：root级别</span></span><br><span class="line">        logger.info(<span class="string">&quot;这是info日志...&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;这是warn日志...&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;这是error日志...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">日志输出格式：</span></span><br><span class="line"><span class="attr">%d表示日期时间，</span></span><br><span class="line"><span class="attr">%thread表示线程名，</span></span><br><span class="line"><span class="attr">%-5level：级别从左到右显示5个字符宽度，</span></span><br><span class="line"><span class="attr">%logger&#123;50&#125;</span>:<span class="string">logger名字最长显示50个字符，否则按照句点分割</span></span><br><span class="line"><span class="attr">%msg</span>:<span class="string">日志消息</span></span><br><span class="line"><span class="attr">%n</span>:<span class="string">换行符</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level.com.neu</span> = <span class="string">trace</span></span><br><span class="line"><span class="comment">#logging.file.path = D:/logs</span></span><br><span class="line"><span class="attr">logging.file.name</span>= <span class="string">iqc.log</span></span><br><span class="line"><span class="comment"># 在控制台输出的日志的格式</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>= <span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>= <span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level ===%logger&#123;50&#125; === %msg%n</span></span><br></pre></td></tr></table></figure><h5 id="2-指定配置"><a href="#2-指定配置" class="headerlink" title="2.指定配置"></a>2.指定配置</h5><p>给类路径下放上每个日志框架自己的配置文件即可，；SpringBoot就使用自己默认的配置了。</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml:直接就被日志框架识别了</p><p>logback-spring.xml:日志框架就不直接加载日志的配置项，由SpringBoot加载，可以使用SpringBoot的高级<strong>Profile</strong>功能。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line">    可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h4><p>可以按照slf4j日志适配图，进行相关的切换。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为log4j2</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在类路径下添加：log4j2-spring.xml文件</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx简单使用</title>
      <link href="/2022/05/11/nginx%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/11/nginx%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Nginx版本区别"><a href="#1-Nginx版本区别" class="headerlink" title="1.Nginx版本区别"></a>1.Nginx版本区别</h3><ul><li>Nginx开源版  <a href="http://nginx.org/">http://nginx.org/</a></li><li>Nginx plus 商业版   <a href="https://www.nginx.com/">https://www.nginx.com</a></li><li>openresty  <a href="http://openresty.org/cn/">http://openresty.org/cn/</a></li><li>Tengine <a href="http://tengine.taobao.org/">http://tengine.taobao.org</a></li></ul><h3 id="2-源码编译安装"><a href="#2-源码编译安装" class="headerlink" title="2.源码编译安装"></a>2.源码编译安装</h3><ol><li>解压文件：tar zxvf nginx-1.21.6.tar.gz</li><li>切换目录：cd nginx-1.21.6</li><li>安装：.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx   <em># –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx 指安装路径是&#x2F;usr&#x2F;local&#x2F;nginx</em></li><li>编译：make</li><li>编译安装：make install</li></ol><h3 id="3-启动与停止"><a href="#3-启动与停止" class="headerlink" title="3. 启动与停止"></a>3. 启动与停止</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./nginx    <span class="comment"># 启动</span></span><br><span class="line">./nginx -s stop <span class="comment">#快速停止</span></span><br><span class="line">./nginx -s quit <span class="comment">#优雅关闭，在退出前完成已经接受的连接请求</span></span><br><span class="line">./nginx -s reload <span class="comment">#重新加载配置</span></span><br></pre></td></tr></table></figure><h3 id="4-安装遇到的问题及解决"><a href="#4-安装遇到的问题及解决" class="headerlink" title="4.安装遇到的问题及解决"></a>4.安装遇到的问题及解决</h3><ul><li>问题1</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">checking <span class="keyword">for</span> OS</span><br><span class="line">+ Linux 3.10.0-693.el7.x86_64 x86_64</span><br><span class="line">checking <span class="keyword">for</span> C compiler ... not found</span><br><span class="line">./configure: error: C compiler cc is not found</span><br></pre></td></tr></table></figure><ul><li>解决1</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc</span><br></pre></td></tr></table></figure><ul><li><p>问题2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either <span class="built_in">disable</span> the module by using --without-http_rewrite_module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the <span class="built_in">source</span> with nginx by using --with-pcre=&lt;path&gt; option.</span><br></pre></td></tr></table></figure></li><li><p>解决2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure></li><li><p>问题3</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either <span class="built_in">disable</span> the module by using --without-http_gzip_module</span><br><span class="line">option, or install the zlib library into the system, or build the zlib library</span><br><span class="line">statically from the <span class="built_in">source</span> with nginx by using --with-zlib=&lt;path&gt; option.</span><br></pre></td></tr></table></figure></li><li><p>解决3</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-安装成系统服务"><a href="#5-安装成系统服务" class="headerlink" title="5.安装成系统服务"></a>5.安装成系统服务</h3><ul><li><p>创建服务脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure></li><li><p>服务脚本内容</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><img src="/2022/05/11/nginx%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/ngxin%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9" alt="image-20220511100443102"></p></li><li><p>重新加载系统服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><blockquote><p>注意：启动服务之前，把之前通过nginx命令运行起来的服务先关掉，即 nginx -s top</p><p>如果忘记关了，通过  **ps -ef | grep nginx ** 命令查看运行端口，通过 <strong>kill -9 port</strong> 命令杀死进程，之后再运行下面服务启动命令即可</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure></li><li><p>查看服务是否启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p>出现：<strong>active（running）</strong>则服务启动</p></li><li><p>设置为开机自启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashMap</title>
      <link href="/2021/08/17/hashMap/"/>
      <url>/2021/08/17/hashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><ol><li><p>hashmap的table散列表在<strong>第一次</strong>put操作的时候才初始化（延迟、懒初始化），因为如果创建出来不用就给他创建了内存，就浪费了</p></li><li><p>路由寻址算法（找在散列表中的位置）：(tab.length - 1) &amp; hash</p></li><li><p>jdk1.8 尾插法将元素追加到链表尾部</p></li><li><p>为什么要扩容？</p><ol><li><p>为了解决哈希冲突导致的链化影响查询效率的问题，扩容回缓解该问题。</p></li><li><p>第一次放数据put的时候会调用resize方法，此时oldCap &#x3D;&#x3D; null;</p></li><li><p>扩容之前的table数组大小<strong>已经达到最大阈值</strong>，就不扩容了，且将扩容条件设置为int最大值</p></li><li><p>正常时扩容时，**newCap &#x3D; oldCap &lt;&lt; 1**；就是扩容一倍；此时还要求扩容之前的容量 &gt;&#x3D; 16;</p></li><li><p>第一次添加数据生成散列表时：</p><ol><li>new HashMap(initCap,loadFactor)；new HashMap(initCap)；new HashMap(map)且map有值时：这三种创建的方式都会给传一个oldThr,此时newCap &#x3D; oldThr</li><li>通过new HashMap()创建时，什么都不给传，此时的数组大小则为默认16</li></ol></li><li><p>newThr（扩容之后，下次再次出发扩容的条件）为零时(创建的时候传进来就是0或者扩容前容量小于16)，通过newCap * loadFactor计算得到 newThr</p></li><li><p>扩容的过程：</p><ol><li><p>根据计算处的newCap创建一个更大的数组</p></li><li><p>当扩容之前有数据时：</p><ol><li><p>取出每个链表的头节点或红黑树的根节点</p></li><li><p>当前节点只有一个节点，在新数组的位置并放入索引（hash &amp; (newCap - 1)）</p></li><li><p>当是<strong>红黑树</strong>的时候</p></li><li><p>当时链表的时候</p><ol><li><p>例如索引<strong>15</strong>位置的链表数据，15 &#x3D; hash &amp; (16 - 1) 也就是说，所有在15位置上的元素的hash值的最后四位是<strong>1111</strong>，那么当扩容到32位之后，重新计算元素的索引时，他只有两个位置<strong>15、31</strong>，因为其后四位的hash值为1111，前一位的hash值为<strong>0|1</strong>，那么只能落在这两个位置上。</p><blockquote><p>扩容的时候一个链表拆成了两个链表：<strong>高位链表和低位链表</strong></p><p>拆分的方式：**hash &amp; oldCap &#x3D;&#x3D; 0 **</p><p>​如：**…. 1  1111&amp;    16(1 0000)    &#x3D;    1**，则加到高位链表，否则加入地位</p></blockquote></li><li></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="1-HashMap与ConcurrentHashMap"><a href="#1-HashMap与ConcurrentHashMap" class="headerlink" title="1.HashMap与ConcurrentHashMap"></a>1.HashMap与ConcurrentHashMap</h2><p><strong>HashMap与ConcurrentHashMap的实现原理是怎样的？ConcurrentHashMap如何保证线程安全？</strong></p><ul><li>HashMap线程是不安全的，现象<ul><li>多线程的put可能导致元素的丢失</li><li>put和get并发时，可能导致get为null</li></ul></li><li>多线程条件环境下要使用线程安全的HashMap<ul><li>Collections.synchronizedMap:全局锁，性能有问题</li><li>HashTable:全局锁，性能问题</li><li>ConcurrentHashMap:分段锁技术</li></ul></li></ul><p><strong>ConcurrentHashMap</strong></p><p>分段锁：锁的时候不锁整个hash表，而是只锁一部分  </p><p>ConcurrentHashMap中维护了Segment数组，每个Segment可以看作一个HashMap,他继承了ReentrantLock,就是一个锁。</p><p>Segment通过HashEntry数组维护其内部的hash表，每个HashEntry就代表了map中的一个K-V,用HashEntry可以组成一个链表结构。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Segment是ConcurrentHashMap的静态内部类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">     * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">     * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The per-segment table. Elements are accessed via</span></span><br><span class="line"><span class="comment">         * entryAt/setEntryAt providing volatile semantics.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="comment">     * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/17/hashMap/image-20210620101756408.png" alt="image-20210620101756408"></p><p>由ConcurrentHashMap的结构图，只要hash值足够分散，每次put的时候就会put到不同的segment中取，而segment本身就是一个锁，put的时候，当前segment会把自己锁住，其他线程无法操作这个segment,但不会影响其他segment的操作。这就是分段锁的好处。</p><p><strong>put方法</strong>:最终会调用segment的put方法，将元素put到HashEntry数组中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key的hash定位出一个segment，如果指定index的segment还没初始化，则调用ensureSegment方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 调用segment的put方法</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为segment本身就是一个锁</span></span><br><span class="line">    <span class="comment">// 这里调用tryLock尝试获取锁</span></span><br><span class="line">    <span class="comment">// 如果获取成功，那么其他线程都无法再修改这个segment</span></span><br><span class="line">    <span class="comment">// 如果获取失败，会调用scanAndLockForPut方法根据key和hash尝试找到这个node，如果不存在，则创建一个node并返回，如果存在则返回null</span></span><br><span class="line">    <span class="comment">// 查看scanAndLockForPut源码会发现他在查找的过程中会尝试获取锁，在多核CPU环境下，会尝试64次tryLock()，如果64次还没获取到，会直接调用lock()</span></span><br><span class="line">    <span class="comment">// 也就是说这一步一定会获取到锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/17/hashMap/image-20210620101905054.png" alt="image-20210620101905054"></p><p>[未完]</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> hashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> hashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程、并发、锁</title>
      <link href="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/"/>
      <url>/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1.线程与进程"></a>1.线程与进程</h2><ul><li><p>进程</p><p>进程是资源分配的基本单位。</p></li><li><p>线程</p><p>线程是独立调度的基本单位。</p></li><li><p>区别：</p><ol><li><p><strong>拥有资源</strong>：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源</p></li><li><p><strong>调度</strong>：线程是独立调度的基本单位，在统一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。</p></li><li><p><strong>系统开销</strong>：由于创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换时，涉及当前执行进程CPU环境的保存即新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p></li><li><p><strong>通信方面</strong>：线程间的通信可以通过直接读写同一进程种的数据进行通信，但是进程通信需要借助<strong>IPC</strong>.</p><p><strong>进程通信方式</strong>：管道，FIFO,消息队列，信号量，共享内存，套接字。</p></li></ol></li></ul><h2 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h2><ol><li><p>new一个Thread类，给Thread传一个Runnable接口。Runnable接口可以是直接在括号里创建一个匿名内部类，重写<strong>run</strong>方法；或者传入一个类，这个类实现了Runnable接口，并重写了<strong>run</strong>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入匿名内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入实现Runnable接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>new 一个集成了Thread类的类，并调用**start()**方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>run()和start()方法</p><p>1.直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。</p><p>2.必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法.</p><p><strong>区别</strong>：</p><p>1.每个线程都是通过某个特定的Thread对象的 <code>run()</code>来完成其操作的，方法<code>run()</code>称为线程体。</p><p>2.<code>start()</code>方法来启动一个线程，真正实现了多线程运行。这时无需等待<code>run()</code>方法体代码执行完毕，可以直接继续下面的代码；这是此线程时处于就绪状态，并没有运行。然后通过此Thread类调用<code>run()</code>来完成器运行状态，<code>run()</code>称为线程体，包含了要执行的这个线程的内容。<code>run()</code>方法运行结束，此线程终止。</p></blockquote></li></ol><h2 id="3-线程状态和进程状态"><a href="#3-线程状态和进程状态" class="headerlink" title="3.线程状态和进程状态"></a>3.线程状态和进程状态</h2><p>1.线程状态</p><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>线程终止的原因有：</p><ul><li><p>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</p></li><li><p>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</p></li><li><p>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</p></li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();<span class="comment">//主线程调用t.join()，等待t线程结束后再运行；可以给方法传一个时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805094438679.png" alt="image-20210805094438679"></p><p>2.进程状态</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/ProcessState.png" alt="img"></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="4-守护线程和中断线程"><a href="#4-守护线程和中断线程" class="headerlink" title="4.守护线程和中断线程"></a>4.守护线程和中断线程</h2><p>1.守护线程</p><p>守护线程是为其他线程服务的线程；所有非守护线程都执行完毕后，虚拟机退出；守护线程不能持有需要关闭的资源（如打开文件等）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>2.中断线程</p><p><strong>方法1</strong>：中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，线程的中断 interrupt 只是改变了线程的中断状态，⾄于这个中断状态改变后带来的结果，那是⽆法确 定的，有时它更是让停⽌中的线程继续执⾏的唯⼀⼿段。不但不是让线程停⽌运⾏，反⽽是继续执⾏线程的⼿段。</p><p>在⼀个线程对象上调⽤ interrupt() ⽅法，真正有影响的是 wait、join、sleep ⽅法，当然这 3 个⽅法包括它们的重 载⽅法。请注意：上⾯这三个⽅法都会抛出 InterruptedException。</p><p>1、对于 wait 中的等待 notify、notifyAll 唤醒的线程，其实这个线程已经“暂停”执⾏，因为它正在某⼀对象的休息 室中，这时如果它的中断状态被改变，那么它就会抛出异常。这个 InterruptedException 异常不是线程抛出的， ⽽是 wait ⽅法，也就是对象的 wait ⽅法内部会不断检查在此对象上休息的线程的状态，如果发现哪个线程的状态 被置为已中断，则会抛出 InterruptedException，意思就是这个线程不能再等待了，其意义就等同于唤醒它了，然 后执⾏ catch 中的代码。</p><p> 2、 对于 sleep 中的线程，如果你调⽤了 Thread.sleep(⼀年)；现在你后悔了，想让它早些醒过来，调⽤ interrupt() ⽅法就是唯⼀⼿段，只有改变它的中断状态，让它从 sleep 中将控制权转到处理异常的 catch 语句中， 然后再由 catch 中的处理转换到正常的逻辑。同样，对于 join 中的线程你也可以这样处理</p><p><strong>方法2</strong>：另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><h2 id="5-线程同步"><a href="#5-线程同步" class="headerlink" title="5.线程同步"></a>5.线程同步</h2><blockquote><p>1.使⽤ Synchronized 关键字； 2. wait 和 notify； 3. 使⽤特殊域变量 volatile 实现线程同步； 4. 使⽤可重⼊锁实现线程同步； 5. 使⽤阻塞队列实现线程同步； 6. 使⽤信号量 Semaphore。</p></blockquote><h3 id="Synchronized-关键字；"><a href="#Synchronized-关键字；" class="headerlink" title="Synchronized 关键字；"></a>Synchronized 关键字；</h3><p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p><p>JVM规范定义了几种原子操作（不需要<code>synchronized</code>）：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p><p>避免死锁的方法是多线程获取锁的顺序要一致。</p></blockquote><ol><li><p>wait 和 notify； </p><blockquote><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul></blockquote><p><code>synchronized</code>并没有解决多线程协调的问题;</p><p><strong>wait</strong>:让线程进入wait状态</p><p><code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p><p>因此，只能在锁对象上调用<code>wait()</code>方法。因为在<code>getTask()</code>中，我们获得了<code>this</code>锁，因此，只能在<code>this</code>对象上调用<code>wait()</code>方法：</p><p><strong>notify</strong>:唤醒线程</p><p>如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？答案是在相同的锁对象上调用<code>notify()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们重点关注<code>addTask()</code>方法，内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p><p>但是，注意到<code>wait()</code>方法返回时需要<em>重新</em>获得<code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行<code>addTask()</code>的线程结束此方法后，才能释放<code>this</code>锁，随后，这3个线程中只能有一个获取到<code>this</code>锁，剩下两个将继续等待。</p><p>再注意到我们在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p></li><li><p>使⽤特殊域变量 volatile 实现线程同步；</p></li></ol><h3 id="使⽤可重⼊锁实现线程同步；"><a href="#使⽤可重⼊锁实现线程同步；" class="headerlink" title="使⽤可重⼊锁实现线程同步；"></a>使⽤可重⼊锁实现线程同步；</h3><blockquote><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p><p>可以使用<code>tryLock()</code>尝试获取锁。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。<br>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p><code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用<code>ReentrantLock</code>我们怎么编写<code>wait</code>和<code>notify</code>的功能呢？</p><p>答案是使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见，使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul></blockquote><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><blockquote><p> <code>ReentrantLock</code>保证了<strong>只有一个</strong>线程可以执行临界区代码：但是有些时候，这种保护有点过头。实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p><p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p><ul><li><p>只允许一个线程写入（其他线程既不能写入也不能读取）；</p></li><li><p>没有写入时，多个线程允许同时读（提高性能）。</p></li></ul><p>使用<code>ReadWriteLock</code>可以提高读取效率：</p><ul><li><code>ReadWriteLock</code>只允许一个线程写入；</li><li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li><li><code>ReadWriteLock</code>适合读多写少的场景。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rlock</span> <span class="operator">=</span> rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wlock</span> <span class="operator">=</span> rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><p>Java的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p><blockquote><p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p><strong>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS是指，在这个操作中，如果<code>AtomicInteger</code>的当前值是<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>。如果<code>AtomicInteger</code>的当前值不是<code>prev</code>，就什么也不干，返回<code>false</code>。通过CAS操作并配合<code>do ... while</code>循环，即使其他线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。</p><h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h2><blockquote><p>说下对线程池的理解？为什么要使⽤线程池？</p></blockquote><p>线程池提供了⼀种限制和管理资源（包括执⾏⼀个任务）的⽅式。每个线程池还维护⼀些基本统计信息，例如：已 完成任务的数量。</p><p> 使⽤线程池的好处 </p><p>1、降低资源消耗：通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗; </p><p>2、 提⾼响应速度：当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏; </p><p>3、 提⾼线程的可管理性：线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性， 使⽤线程池可以进⾏统⼀的分配，调优和监控。</p><blockquote><p>如何创建线程池？</p></blockquote><p>⽅式⼀：通过 ThreadPoolExecutor 的构造⽅法实现：</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805104922110.png" alt="image-20210805104922110"></p><p>⽅式⼆：通过 Executor 框架的⼯具类 Executors 来实现：</p><p>1、FixedThreadPool：该⽅法返回⼀个固定线程数量的线程池。该线程池中的线程数量始终不变。当有⼀个新的 任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任务会被暂存在⼀个任务队列中，待有线程空 闲时，便处理在任务队列中的任务。</p><p> 2、 SingleThreadExecutor：⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到该线程池，任务会被 保存在⼀个任务队列中，待线程空闲，按先进先出的顺序执⾏队列中的任务。 </p><p>3、CachedThreadPool：该⽅法返回⼀个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但 若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有新的任务提交，则会创建新的线 程处理任务。所有线程在当前任务执⾏完毕后，将返回线程池进⾏复⽤。</p><blockquote><p>Executors 创建线程池对象的弊端如下：</p></blockquote><p>FixedThreadPool 和 SingleThreadExecutor ：允许请求的队列⻓度为 Integer.MAX_VALUE，可能堆积⼤量的请 求，从⽽导致 OOM。</p><p>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建⼤量线程，从⽽导致 OOM</p><blockquote><p>创建线程池的参数有哪些？ </p></blockquote><p>1、 corePoolSize（线程池的基本⼤⼩）：当提交⼀个任务到线程池时，如果当前 poolSize &lt; corePoolSize 时，线 程池会创建⼀个线程来执⾏任务，即使其他空闲的基本线程能够执⾏新任务也会创建线程，等到需要执⾏的任务数 ⼤于线程池基本⼤⼩时就不再创建。如果调⽤了线程池的prestartAllCoreThreads() ⽅法，线程池会提前创建并启 动所有基本线程。 </p><p>2、 maximumPoolSize（线程池最⼤数量）：线程池允许创建的最⼤线程数。如果队列满了，并且已创建的线程 数⼩于最⼤线程数，则线程池会再创建新的线程执⾏任务。值得注意的是，如果使⽤了⽆界的任务队列这个参数就 没什么效果。</p><p>3、 keepAliveTime（线程活动保持时间）：线程池的⼯作线程空闲后，保持存活的时间。所以，如果任务很多， 并且每个任务执⾏的时间⽐较短，可以调⼤时间，提⾼线程的利⽤率。 </p><p>4、 TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、⼩时（HOURS）、分钟（MINUTES）、 毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之⼀毫秒）和纳秒（NANOSECONDS，千分之⼀微 秒）。 </p><p>5、workQueue（任务队列）：⽤于保存等待执⾏的任务的阻塞队列。 可以选择以下⼏个阻塞队列：</p><p>   1）、 ArrayBlockingQueue：是⼀个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进⾏ 排序。 </p><p>​    2）、LinkedBlockingQueue：⼀个基于链表结构的阻塞队列，此队列按 FIFO 排序元素，吞吐量通常要⾼于 ArrayBlockingQueue。静态⼯⼚⽅法 Executors.newFixedThreadPool() 使⽤了这个队列。</p><p>​    3）、SynchronousQueue：⼀个不存储元素的阻塞队列。每个插⼊操作必须等到另⼀个线程调⽤移除操作，否则 插⼊操作⼀直处于阻塞状态，吞吐量通常要⾼于 LinkedBlockingQueue，静态⼯⼚⽅法 Executors.newCachedThreadPool 使⽤了这个队列。 </p><p>   4）、 PriorityBlockingQueue：⼀个具有优先级的⽆限阻塞队列。</p><p>6、 threadFactory：⽤于设置创建线程的⼯⼚，可以通过线程⼯⼚给每个创建出来的线程设置更有意义的名字。    7.、RejectExecutionHandler（饱和策略）：队列和线程池都满了，说明线程池处于饱和状态，那么必须采取⼀种 策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示⽆法处理新任务时抛出异常。</p><blockquote><p> 饱和策略： 在 JDK1.5 中 Java 线程池框架提供了以下 4 种策略： </p></blockquote><ol><li>AbortPolicy：直接抛出异常。 <strong>&#x2F;&#x2F;银行满了，还有人进来，不处理这个人的，抛出异常</strong></li><li>CallerRunsPolicy：只⽤调⽤者所在线程来运⾏任务。 <strong>&#x2F;&#x2F;哪来的去哪里</strong></li><li>DiscardOldestPolicy：丢弃队列⾥最近的⼀个任务，并执⾏当前任务。**&#x2F;&#x2F;队列满了，尝试去和最早的竞争，也不会抛出异常**</li><li>DiscardPolicy：不处理，丢弃掉。 当然，也可以根据应⽤场景需要来实现RejectedExecutionHandler 接⼝⾃定义策略。如记录⽇志或持久化存储不 能处理的任务。<strong>队列满了，丢掉任务，不会抛出异常</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质 ThreadPoolExecutor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  //核心线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,//最大核心线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,//超时了没有人调用就是释放</span></span><br><span class="line"><span class="params">                              TimeUnit unit,//超时单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,//线程工厂：创建线程的，一般不用动</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略&#123;</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-接口Callable"><a href="#7-接口Callable" class="headerlink" title="7.接口Callable"></a>7.接口Callable</h2><ol><li>多线程的第三种创建方式</li><li>可以有返回值，可以抛出异常。</li><li>方法不同，run()&#x2F;call()</li></ol><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210623105117161-1624416678610.png" alt="image-20210623105117161"></p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210623105306057-1624416787146.png" alt="image-20210623105306057"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//new Thread(new MyThread()).start();//传统的多线程方式  类实现Runnable(功能有限，没有返回值)</span></span><br><span class="line">        <span class="comment">//使用Callable接口</span></span><br><span class="line">        <span class="comment">//怎么启动Callable,因为Thread只能接收Runnable类型</span></span><br><span class="line">        <span class="comment">//Runnable的实现类有FutureTask,FutureTask可以接收Callable和Runnable的构造参数，所以能够启动Callable的线程。</span></span><br><span class="line">        <span class="comment">//1.new Thread(new Runnable()).start();</span></span><br><span class="line">        <span class="comment">//2.new Thread(new FutureTask&lt;V&gt;(Callable)).start();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>().start();<span class="comment">//怎么启动</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(myThread); <span class="comment">//适配类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> (String) futureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li>有缓存</li><li>结果可能需要等待，会阻塞</li></ol><h2 id="8-ForkJoin"><a href="#8-ForkJoin" class="headerlink" title="8.ForkJoin"></a>8.ForkJoin</h2><blockquote><p>什么是ForkJoin</p></blockquote><p>   在JDK1.7中出现，并行执行任务！提高效率</p><p>​    类似于分治算法。</p><p>Fork&#x2F;Join 并⾏计算框架主要解决的是分治任务。分治的核⼼思想是“分⽽治之”：将⼀个⼤的任务拆分成⼩的⼦任务 的结果聚合起来从⽽得到最终结果。 Fork&#x2F;Join 并⾏计算框架的核⼼组件是 ForkJoinPool。ForkJoinPool ⽀持任务窃取机制，能够让所有的线程的⼯作 量基本均衡，不会出现有的线程很忙，⽽有的线程很闲的情况，所以性能很好。 ForkJoinPool 中的任务队列采⽤的是双端队列，⼯作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消 费，这样能避免很多不必要的数据竞争。</p><blockquote><p> ForkJoin特点：工作窃取</p></blockquote><p>   这个里边维护的都是双端队列。</p><blockquote><p> ForkJoin操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何使用forkjoin</span></span><br><span class="line"><span class="comment"> * 1.forkJoinPool通过它来执行</span></span><br><span class="line"><span class="comment"> * 2.计算任务forkJoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * 3.计算类要继承ForkJoinTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> start,<span class="type">long</span> end)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end - start)&gt;temp)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//forkJion</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;<span class="comment">//中间值</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            task1.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle+<span class="number">1</span>, middle);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join()+task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">10_0000_0000</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;, 时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0</span>, <span class="number">10_0000_0000</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">//提交任务</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;, 时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stream并行流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0</span>,<span class="number">10_0000_0000</span>).parallel().reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;, 时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9.ThreadLocal"></a>9.ThreadLocal</h2><p>观察<code>process()</code>方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？</p><p><code>process()</code>方法需要传递的状态就是<code>User</code>实例。有的童鞋会想，简单地传入<code>User</code>就可以了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    checkPermission(user);</span><br><span class="line">    doWork(user);</span><br><span class="line">    saveStatus(user);</span><br><span class="line">    sendResponse(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是往往一个方法又会调用其他很多方法，这样会导致<code>User</code>传递到所有地方，而且有些时候，如果调用链有无法修改源码的第三方库，<code>User</code>对象就传不进去了。</p><blockquote><p> Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p><p><code>ThreadLocal</code> 提供 get 和 set ⽅法，为每⼀个使⽤这个变量的线程都保存有⼀份独⽴的副本</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processUser</span><span class="params">(user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);<span class="comment">//典型使用</span></span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1.synchronized"></a>1.synchronized</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的⽅法或 者代码块在任意时刻只能有⼀个线程执⾏。</p><p> 另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的 操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线 程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转 换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 JDK6 之后 Java 官⽅对从 JVM 层⾯对synchronized 较⼤优化，所以现在的 synchronized 锁效率也优化得很不错 了。JDK6 对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术 来减少锁操作的开销。 synchronized 关键字底层原理属于 JVM 层⾯</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805113152795.png" alt="image-20210805113152795"></p><p>通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：⾸先切换到类的对应⽬录执⾏ javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执⾏ javap -c -s -v -l SynchronizedDemo.class</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805113111230.png" alt="image-20210805113111230"></p><p>从上⾯我们可以看出：synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p><p> 当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。monitor 对象存在于每个 Java 对象 的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因。当计 数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执⾏ monitorexit 指令后，将锁计数器 设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805113219428.png" alt="image-20210805113219428"></p><p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，JVM 通过该 ACC_SYNCHRONIZED 访问标志 来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤</p><h2 id="2-JDK1-6-之后synchronized-优化"><a href="#2-JDK1-6-之后synchronized-优化" class="headerlink" title="2.JDK1.6 之后synchronized 优化"></a>2.JDK1.6 之后synchronized 优化</h2><p>JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。 </p><p>锁主要存在四种状态，依次是：⽆锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，它们会随着竞争的激烈⽽ 逐渐升级。注意锁可以升级不可降级，这种策略是为了提⾼获得锁和释放锁的效率。</p><ul><li>偏向锁</li></ul><p>  引⼊偏向锁的⽬的和引⼊轻量级锁的⽬的很像，它们都是为了没有多线程竞争的前提下，减少传统的重量级锁使⽤ 操作系统互斥量产⽣的性能消耗。但是不同是：轻量级锁在⽆竞争的情况下使⽤ CAS 操作去代替使⽤互斥量。⽽ 偏向锁在⽆竞争的情况下会把整个同步都消除掉。</p><p>   偏向锁的“偏”就是偏⼼的偏，它的意思是会偏向于第⼀个获得它的线程，如果在接下来的执⾏中，该锁没有被其他 线程获取，那么持有偏向锁的线程就不需要进⾏同步。 </p><p>  但是对于锁竞争⽐较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此 这种场合下不应该使⽤偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会⽴即膨胀为重量级锁，⽽ 是先升级为轻量级锁。 </p><ul><li><p>轻量级锁 </p><p>倘若偏向锁失败，虚拟机并不会⽴即升级为重量级锁，它还会尝试使⽤⼀种称为轻量级锁的优化⼿段(JDK1.6 之后 加⼊的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使⽤操作 系统互斥量产⽣的性能消耗，因为使⽤轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都⽤到了 CAS 操作。 </p><p>轻量级锁能够提升程序同步性能的依据是“对于绝⼤部分锁，在整个同步周期内都是不存在竞争的”，这是⼀个经验 数据。如果没有竞争，轻量级锁使⽤ CAS 操作避免了使⽤互斥操作的开销。但如果存在锁竞争，除了互斥量开销 外，还会额外发⽣ CAS 操作，因此在有锁竞争的情况下，轻量级锁⽐传统的重量级锁更慢！如果锁竞争激烈，那 么轻量级将很快膨胀为重量级锁</p></li><li><p>⾃旋锁和⾃适应⾃旋 </p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层⾯挂起，还会进⾏⼀项称为⾃旋锁的优化⼿段。</p><p> 互斥同步对性能最⼤的影响就是阻塞的实现，因为挂起线程&#x2F;恢复线程的操作都需要转⼊内核态中完成（⽤户态转 换到内核态会耗费时间）。</p><p> ⼀般线程持有锁的时间都不是太⻓，所以仅仅为了这⼀点时间去挂起线程&#x2F;恢复线程是得不偿失的。所以，虚拟机 的开发团队就这样去考虑：“我们能不能让后⾯来的请求获取锁的线程等待⼀会⽽不被挂起呢？看看持有锁的线程 是否很快就会释放锁”。为了让⼀个线程等待，我们只需要让线程执⾏⼀个忙循环（⾃旋），这项技术就叫做⾃旋</p><blockquote><p>百度百科对⾃旋锁的解释：何谓⾃旋锁？它是为实现保护共享资源⽽提出⼀种锁机制。其实，⾃旋锁与互斥 锁⽐较类似，它们都是为了解决对某项资源的互斥使⽤。⽆论是互斥锁，还是⾃旋锁，在任何时刻，最多只 能有⼀个保持者，也就说，在任何时刻最多只能有⼀个执⾏单元获得锁。但是两者在调度机制上略有不同。 对于互斥锁，如果资源已经被占⽤，资源申请者只能进⼊睡眠状态。但是⾃旋锁不会引起调⽤者睡眠，如果 ⾃旋锁已经被别的执⾏单元保持，调⽤者就⼀直循环在那⾥看是否该⾃旋锁的保持者已经释放了锁，”⾃ 旋”⼀词就是因此⽽得名 </p></blockquote><p>⾃旋锁在 JDK1.6 之前其实就已经引⼊了，不过是默认关闭的，需要通过 –XX:+UseSpinning 参数来开启。JDK1.6 及 1.6 之后，就改为默认开启的了。需要注意的是：⾃旋等待不能完全替代阻塞，因为它还是要占⽤处理器时间。 如果锁被占⽤的时间短，那么效果当然就很好了。反之，⾃旋等待的时间必须要有限度。如果⾃旋超过了限定次数 任然没有获得锁，就应该挂起线程。⾃旋次数的默认值是 10 次，⽤户可以修改 –XX:PreBlockSpin 来更改。 </p><p>另外，在 JDK1.6 中引⼊了⾃适应的⾃旋锁。⾃适应的⾃旋锁带来的改进就是：⾃旋的时间不在固定了，⽽是和前 ⼀次同⼀个锁上的⾃旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。</p></li><li><p>锁消除 </p><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运⾏时，如果检测到那些共享数据不可能存在竞争，那么 就执⾏锁消除。锁消除可以节省毫⽆意义的请求锁的时间。 </p></li><li><p>锁粗化 </p><p>原则上，我们在编写代码的时候，总是推荐将同步块的作⽤范围限制得尽量⼩。只在共享数据的实际作⽤域才进⾏ 同步，这样是为了使得需要同步的操作数量尽可能变⼩，如果存在锁竞争，那等待线程也能尽快拿到锁。 </p><p>⼤部分情况下，上⾯的原则都是没有问题的，但是如果⼀系列的连续操作都对同⼀个对象反复加锁和解锁，那么会 带来很多不必要的性能消耗</p></li></ul><h2 id="3-volatile"><a href="#3-volatile" class="headerlink" title="3.volatile"></a>3.volatile</h2><p>volatile 关键字是⽤来保证有序性和可⻅性的。这跟 Java 内存模型有关。我们所写的代码，不⼀定是按照我们⾃⼰ 书写的顺序来执⾏的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流⽔线阻塞，提⾼ CPU 的执 ⾏效率。这就需要有⼀定的顺序和规则来保证，不然程序员⾃⼰写的代码都不知道对不对了，所以有 happens-before 规则，其中有条就是 volatile 变量规则：对⼀个变量的写操作先⾏发⽣于后⾯对这个变量的读操作、有序性 实现的是通过插⼊内存屏障来保证的。 </p><p>被 volatile 修饰的共享变量，就具有了以下两点特性： 1 . 保证了不同线程对该变量操作的内存可⻅性; 2 . 禁⽌指令重排序</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210725112623270.png" alt="image-20210725112623270"></p><h2 id="4-synchronized-和volatile"><a href="#4-synchronized-和volatile" class="headerlink" title="4.synchronized 和volatile"></a>4.synchronized 和volatile</h2><ul><li>volatile 本质是在告诉 JVM当前变量在寄存器（⼯作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile 仅能使⽤在变量级别；synchronized 则可以使⽤在变量、⽅法、和类级别的。</li><li>volatile 仅能实现变量的修改可⻅性，不能保证原⼦性；⽽ synchronized 则可以保证变量的修改可⻅性和原 ⼦性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化</li></ul><h2 id="5-JMM"><a href="#5-JMM" class="headerlink" title="5.JMM"></a>5.JMM</h2><blockquote><p>Volatile理解：是Java虚拟机提供的<strong>轻量级的同步机制</strong></p></blockquote><pre><code>1.  保证可见性   2.  不保证原子性    3.  禁止指令重排</code></pre><blockquote><p>JMM: java 内存模型，不存在的东西，概念，约定。</p></blockquote><p>关于JMM的同步约定：</p><ol><li>线程解锁前：必须把共享变量&#x3D;&#x3D;立刻&#x3D;&#x3D;刷回内存</li><li>线程加锁前：必须读取主存中的最新值到工作内存中。</li><li>加锁和解锁是同一把锁。</li></ol><p>线程：<strong>工作内存</strong>，<strong>主内存</strong></p><p>8种操作</p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210624110402520-1624503843536.png" alt="image-20210624110402520"></p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210624110715196.png" alt="image-20210624110715196"></p><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p><p><strong>问题</strong>：程序不知道主内存种的值已经被改了</p><h2 id="6-synchronized和ReenTrantLock"><a href="#6-synchronized和ReenTrantLock" class="headerlink" title="6.synchronized和ReenTrantLock"></a>6.synchronized和ReenTrantLock</h2><p>1、synchronized 是和 for、while ⼀样的关键字，ReentrantLock 是类，这是⼆者的本质区别。既然 ReentrantLock 是类，那么它就提供了⽐ synchronized 更多更灵活的特性：等待可中断、可实现公平锁、可实现 选择性通知（锁可以绑定多个条件）、性能已不是选择标准。 </p><p>2、 synchronized 依赖于 JVM ⽽ ReenTrantLock 依赖于 API。synchronized 是依赖于 JVM 实现的，JDK1.6 为 synchronized 关键字进⾏了很多优化，但是这些优化都是在虚拟机层⾯实现的，并没有直接暴露给我们。 ReenTrantLock 是 JDK 层⾯实现的（也就是 API 层⾯，需要 lock() 和 unlock ⽅法配合 try&#x2F;finally 语句块来完 成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h2 id="7-ReenTrantReadWriteLock"><a href="#7-ReenTrantReadWriteLock" class="headerlink" title="7.ReenTrantReadWriteLock"></a>7.ReenTrantReadWriteLock</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805114753391.png" alt="image-20210805114753391"></p><h2 id="8-悲观锁、乐观锁"><a href="#8-悲观锁、乐观锁" class="headerlink" title="8.悲观锁、乐观锁"></a>8.悲观锁、乐观锁</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805114818829.png" alt="image-20210805114818829"></p><h2 id="9-乐观锁实现方式"><a href="#9-乐观锁实现方式" class="headerlink" title="9.乐观锁实现方式"></a>9.乐观锁实现方式</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805114848883.png" alt="image-20210805114848883"></p><h2 id="10-乐观锁缺点"><a href="#10-乐观锁缺点" class="headerlink" title="10.乐观锁缺点"></a>10.乐观锁缺点</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805114912105.png" alt="image-20210805114912105"></p><h2 id="11-CAS和synchronized使用区别"><a href="#11-CAS和synchronized使用区别" class="headerlink" title="11.CAS和synchronized使用区别"></a>11.CAS和synchronized使用区别</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805114944009.png" alt="image-20210805114944009"></p><h2 id="12-atomic原理"><a href="#12-atomic原理" class="headerlink" title="12.atomic原理"></a>12.atomic原理</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805115020118.png" alt="image-20210805115020118"></p><h2 id="13-AQS"><a href="#13-AQS" class="headerlink" title="13.AQS"></a>13.AQS</h2><p>AQS 的全称为：AbstractQueuedSynchronizer，这个类在 java.util.concurrent.locks 包下⾯。</p><p>AQS 是⼀个⽤来构 建锁和同步器的框架，使⽤ AQS 能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，⽐如：我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等 皆是基于 AQS 的。当然，我们⾃⼰也能利⽤ AQS ⾮常轻松容易地构造出符合我们⾃⼰需求的同步器。</p><blockquote><p>原理</p><p>AQS 核⼼思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源 设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个 机制 AQS 是⽤ CLH 队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p></blockquote><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805115133736.png" alt="image-20210805115133736"></p><p>AQS 使⽤⼀个 int 成员变量 (state) 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。AQS 使⽤ CAS 对该同步状态进⾏原⼦操作实现对其值的修改</p><h2 id="14-AQS资源共享模式"><a href="#14-AQS资源共享模式" class="headerlink" title="14.AQS资源共享模式"></a>14.AQS资源共享模式</h2><ul><li>Exclusive（独占）：只有⼀个线程能执⾏，如：ReentrantLock，⼜可分为公平锁和⾮公平锁：</li><li>Share（共享）：多个线程可同时执⾏，如：CountDownLatch、Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock。</li></ul><h2 id="15-AQS底层模板方法模式"><a href="#15-AQS底层模板方法模式" class="headerlink" title="15.AQS底层模板方法模式"></a>15.AQS底层模板方法模式</h2><p>使⽤者继承 AbstractQueuedSynchronizer 并重写指定的⽅法。将 AQS 组合在⾃定义同步组件的实现中，并调⽤ 其模板⽅法，⽽这些模板⽅法会调⽤使⽤者重写的⽅法。 </p><ol><li>isHeldExclusively() ：该线程是否正在独占资源。只有⽤到 condition 才需要去实现它。 </li><li>tryAcquire(int) ：独占⽅式。尝试获取资源，成功则返回 true，失败则返回 false。 </li><li>tryRelease(int) ：独占⽅式。尝试释放资源，成功则返回 true，失败则返回 false。</li><li>tryAcquireShared(int) ：共享⽅式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可⽤资源；正 数表示成功，且有剩余资源。 </li><li>tryReleaseShared(int) ：共享⽅式。尝试释放资源，成功则返回 true，失败则返回 false。</li></ol><h2 id="16-Semaphore"><a href="#16-Semaphore" class="headerlink" title="16.Semaphore"></a>16.Semaphore</h2><p>synchronized 和 ReentrantLock 都是⼀次只允许⼀个线程访问某个资源，Semaphore (信号量)可以指定多个线程 同时访问某个资源。 </p><p>执⾏ acquire ⽅法阻塞，直到有⼀个许可证可以获得然后拿⾛⼀个许可证；每个 release ⽅法增加⼀个许可证，这 可能会释放⼀个阻塞的 acquire ⽅法。然⽽，其实并没有实际的许可证这个对象，Semaphore 只是维持了⼀个可 获得许可证的数量。Semaphore 经常⽤于限制获取某种资源的线程数量。当然⼀次也可以⼀次拿取和释放多个许 可证，不过⼀般没有必要这样做。除了 acquire⽅法（阻塞）之外，另⼀个⽐较常⽤的与之对应的⽅法是 tryAcquire ⽅法，该⽅法如果获取不到许可就⽴即返回 false</p><h2 id="17-阻塞队列"><a href="#17-阻塞队列" class="headerlink" title="17.阻塞队列"></a>17.阻塞队列</h2><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805115510512.png" alt="image-20210805115510512"></p><p><img src="/2021/07/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%94%81/image-20210805115520396.png" alt="image-20210805115520396"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>(内容来自胡科大教书匠)</strong></p><h1 id="图示说明"><a href="#图示说明" class="headerlink" title="图示说明"></a>图示说明</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103344.png" alt="image-20201007143815954" style="zoom: 50%;">代表着主机</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103558.png" alt="image-20201007144130208" style="zoom:50%;"> 代表服务器</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103603.png" alt="image-20201007143904153" style="zoom:50%;"> 代表着路由器</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103608.png" alt="image-20201007143936128" style="zoom:50%;">代表着网络</p><h1 id="1-1、计算机网络在信息时代的作用"><a href="#1-1、计算机网络在信息时代的作用" class="headerlink" title="1.1、计算机网络在信息时代的作用"></a>1.1、计算机网络在信息时代的作用</h1><ul><li>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></li><li>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</li></ul><h2 id="我国互联网发展状况"><a href="#我国互联网发展状况" class="headerlink" title="我国互联网发展状况"></a>我国互联网发展状况</h2><p><a href="http://www.cnnic.net.cn/">中国互联网络信息中心CNNIC</a></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103619.png" alt="image-20201006160618748"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103648.png" alt="image-20201006160645887"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103659.png" alt="image-20201006160715764"></p><hr><h1 id="1-2、因特网概述"><a href="#1-2、因特网概述" class="headerlink" title="1.2、因特网概述"></a>1.2、因特网概述</h1><h2 id="1、网络、互连网（互联网）和因特网"><a href="#1、网络、互连网（互联网）和因特网" class="headerlink" title="1、网络、互连网（互联网）和因特网"></a>1、网络、互连网（互联网）和因特网</h2><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103711.png" alt="image-20201006163406232" style="zoom: 50%;"><p>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103716.png" alt="image-20201006163857236" style="zoom:50%;"><p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103720.png" alt="image-20201006164114523" style="zoom:50%;"><blockquote><p><strong>internet与Internet的区别</strong></p><ul><li><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</li></ul><p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103731.png" alt="image-20201010233227407"></p><h2 id="2、因特网发展的三个阶段"><a href="#2、因特网发展的三个阶段" class="headerlink" title="2、因特网发展的三个阶段"></a>2、因特网发展的三个阶段</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103739.png" alt="image-20201006164655173"></p><p><strong>因特网服务提供者<code>ISP</code>(<code>I</code>nternet <code>S</code>ervice <code>P</code>rovider)</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103744.png" alt="image-20201006165117756" style="zoom:67%;"><blockquote><p>普通用户是如何接入到因特网的呢？</p><p>答：<strong>通过ISP接入因特网</strong></p><p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p><p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p></blockquote><p><strong>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103801.png" alt="image-20201006165738879" style="zoom:67%;"><p><strong>基于ISP的三层结构的因特网</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103810.png" alt="image-20201006170140504" style="zoom:67%;"><blockquote><p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p></blockquote><h2 id="3、因特网的标准化工作"><a href="#3、因特网的标准化工作" class="headerlink" title="3、因特网的标准化工作"></a>3、因特网的标准化工作</h2><ul><li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li><li>因特网在指定其标准上的一个很大的特点是<strong>面向公众。</strong><ul><li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><strong>因特网协会ISOC</strong>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ul><li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li><li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103816.png" alt="image-20201006170959060" style="zoom:67%;"><ul><li><p>制订因特网的正式标准要经过一下<strong>4个阶段</strong>：</p><p>1、因特网草案（在这个阶段还不是RFC文档）</p><p>2、建议标准（从这个阶段开始就成为RFC文档）</p><p>3、草案标准</p><p>4、因特网标准</p></li></ul><h2 id="4、因特网的组成"><a href="#4、因特网的组成" class="headerlink" title="4、因特网的组成"></a>4、因特网的组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p></li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103822.png" alt="image-20201006180725282" style="zoom:67%;"><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li><p>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</p></li><li><p>大的端系统则可以是一台非常昂贵的大型计算机。</p></li><li><p>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</p></li></ol></blockquote><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong> </p><p>端系统之间的通信方式通常可划分为两大类：</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103829.png" alt="image-20201010234145371"></p><p><strong>客户-服务器方式：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><hr><h1 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h1><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><h2 id="1、电路交换（Circuit-Switching）"><a href="#1、电路交换（Circuit-Switching）" class="headerlink" title="1、电路交换（Circuit Switching）"></a>1、电路交换（Circuit Switching）</h2><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103836.png" alt="image-20201006182240000" style="zoom:67%;"><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103840.png" alt="image-20201006182634249" style="zoom:50%;"><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103845.png" alt="image-20201006183020317" style="zoom:67%;"><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h2 id="2、分组交换（Packet-Switching）"><a href="#2、分组交换（Packet-Switching）" class="headerlink" title="2、分组交换（Packet Switching）"></a>2、分组交换（Packet Switching）</h2><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103852.png" alt="image-20201006183312843" style="zoom:67%;"><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li>缓存分组</li><li>转发分组</li><li>简称为“分组转发”</li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口<strong>转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3、报文交换（Message-Switching）"><a href="#3、报文交换（Message-Switching）" class="headerlink" title="3、报文交换（Message Switching）"></a>3、报文交换（Message Switching）</h2><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><blockquote><p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p></blockquote><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103900.png" alt="image-20201006184451671" style="zoom:67%;"><p>分析：</p><p>电路交换：</p><ul><li><p>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</p></li><li><p>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</p></li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103949.png" alt="image-20201006185601460"></p><hr><h1 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>计算机网络的精确定义并未统一</li><li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。<ul><li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li>集合：是指至少需要两台计算机；</li></ul></li><li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li>总线型网络</li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016103958.png" alt="image-20201007005149993" style="zoom: 67%;"><ul><li>星型网络</li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104005.png" alt="image-20201007005203129" style="zoom:67%;"><ul><li>环形网络</li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104009.png" alt="image-20201007005212345" style="zoom:67%;"><ul><li>网状型网络</li></ul><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104015.png" alt="image-20201007005249137" style="zoom:67%;"><hr><h1 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104021.png" alt="image-20201007012419698"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104026.png" alt="image-20201007012439769"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104031.png" alt="image-20201007012943970"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104038.png" alt="image-20201007013119621"></p><blockquote><p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li>发送时延</li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比 特算起，到该帧的最后一个比特发送完毕所需的时间。</p><ul><li>传播时延</li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><ul><li>处理时延</li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li>排队时延</li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104045.png" alt="image-20201007014139333"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104050.png" alt="image-20201007015401505"></p><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104057.png" alt="image-20201007115317347"></p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104104.png" alt="image-20201007115647631"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><p>  <img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104110.png" alt="image-20201012164544306"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104116.png" alt="image-20201007132900210"></p><hr><h1 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h1><h2 id="1、常见的计算机网络体系结构"><a href="#1、常见的计算机网络体系结构" class="headerlink" title="1、常见的计算机网络体系结构"></a>1、常见的计算机网络体系结构</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104122.png" alt="image-20201007133848212"></p><blockquote><p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104127.png" alt="image-20201007135220030"></p><blockquote><p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>只不过路由器一般只包含网络接口层和网际层。</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104135.png" alt="image-20201007135518050"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p></blockquote><blockquote><p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104142.png" alt="image-20201007141110338"></p><blockquote><p>教学时把TCP&#x2F;IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p></blockquote><h2 id="2、计算机网络体系结构分层的必要性"><a href="#2、计算机网络体系结构分层的必要性" class="headerlink" title="2、计算机网络体系结构分层的必要性"></a>2、计算机网络体系结构分层的必要性</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104151.png" alt="image-20201007141318411"></p><p><strong>物理层问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104156.png" alt="image-20201007141806675"></p><blockquote><p>这图说明</p><ul><li>第一，严格来说，传输媒体并不属于物理层</li><li>计算机传输的信号，并不是图示的方波信号</li></ul><p>这样举例只是让初学者容易理解</p></blockquote><p><strong>数据链路层问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104204.png" alt="image-20201007142049812"></p><p><strong>网络层问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104211.png" alt="image-20201007142408792"></p><p><strong>运输层问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104216.png" alt="image-20201007142631029"></p><blockquote><p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p></blockquote><p><strong>应用层问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104224.png" alt="image-20201007142755720"></p><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104231.png" alt="image-20201007204006284"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104235.png" alt="image-20201007143138937"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104241.png" alt="image-20201007195641140"></p><h2 id="3、计算机网络体系结构分层思想举例"><a href="#3、计算机网络体系结构分层思想举例" class="headerlink" title="3、计算机网络体系结构分层思想举例"></a>3、计算机网络体系结构分层思想举例</h2><p>例子：主机的浏览器如何与Web服务器进行通信</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104246.png" alt="image-20201007144900565"></p><p><strong>解析：</strong></p><p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104254.png" alt="image-20201007145242020"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104300.png" alt="image-20201007145441370"></p><blockquote><p>第一步：</p><ul><li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li><li>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</li></ul></blockquote><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104304.png" alt="image-20201007145720661" style="zoom:200%;"><blockquote><p>第二步：</p><ul><li><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li><li><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li><li><strong>运输层</strong>将T<strong>CP报文段</strong>交付给<strong>网络层</strong>处理</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104309.png" alt="image-20201007150234909"></p><blockquote><p>第三步：</p><ul><li><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li><li><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</li><li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104314.png" alt="image-20201007150723365"></p><blockquote><p>第四步：</p><ul><li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong>     （图示右边为首部，左边为尾部） </li><li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li><li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li><li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104319.png" alt="image-20201007151342502"></p><blockquote><p>第五步：</p><ul><li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li><li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104325.png" alt="image-20201007151900254"></p><blockquote><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul></blockquote><p><strong>2、路由器转发</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104331.png" alt="image-20201007152029458" style="zoom:50%;"><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104337.png" alt="image-20201007152138961" style="zoom:50%;"><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104350.png" alt="image-20201007152627778" style="zoom:50%;"><blockquote><p>在路由器中</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></li><li><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li></ul></blockquote><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104356.png" alt="image-20201007152650863" style="zoom:50%;"><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104400.png" alt="image-20201007152812431" style="zoom:50%;"><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104404.png" alt="image-20201007153714840" style="zoom:50%;"><blockquote><p>在路由器中</p><ul><li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li><li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li><li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li><li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></li></ul></blockquote><p><strong>3、接收方接收</strong></p><blockquote><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在Web 服务器上</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li><li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li><li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li><li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li></ul><p><strong>发回响应报文的步骤和之前过程类似</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104410.png" alt="image-20201007155051275"></p><h2 id="4、计算机网络体系结构中的专用术语"><a href="#4、计算机网络体系结构中的专用术语" class="headerlink" title="4、计算机网络体系结构中的专用术语"></a>4、计算机网络体系结构中的专用术语</h2><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104417.png" alt="image-20201007155444920"></p><p><strong>协议</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104423.png" alt="image-20201007155545934"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><strong>服务</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104434.png" alt="image-20201007160246561"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104757.png" alt="image-20201016104750288"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20201016104806.png" alt="image-20201007162620250"></p><h1 id="2-1、物理层的基本概念"><a href="#2-1、物理层的基本概念" class="headerlink" title="2.1、物理层的基本概念"></a>2.1、物理层的基本概念</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008130211749.png" alt="image-20201008130211749"></p><hr><h1 id="2-2、物理层下面的传输媒体"><a href="#2-2、物理层下面的传输媒体" class="headerlink" title="2.2、物理层下面的传输媒体"></a>2.2、物理层下面的传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008132050917.png" alt="image-20201008132050917"></p><p><strong>双绞线</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008132225715.png" alt="image-20201008132225715"></p><p><strong>光纤</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008132403903.png" alt="image-20201008132403903"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011001240573.png" alt="image-20201011001240573"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><strong>电力线</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008132709015.png" alt="image-20201008132709015"></p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><p>非导引型传输媒体是指自由空间。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008132857833.png" alt="image-20201008132857833"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008132943176.png" alt="image-20201008132943176"></p><p><strong>无线电波</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008133135659.png" alt="image-20201008133135659"></p><p><strong>微波</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008133317293.png" alt="image-20201008133317293"></p><p><strong>红外线</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008133421986.png" alt="image-20201008133421986"></p><p><strong>可见光</strong></p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008133718810.png" alt="image-20201008133718810"></p><hr><h1 id="2-3、传输方式"><a href="#2-3、传输方式" class="headerlink" title="2.3、传输方式"></a>2.3、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008135603009.png" alt="image-20201008135603009"></p><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008140209430.png" alt="image-20201008140209430"></p><blockquote><p><strong>同步传输</strong>：</p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以要使收发双发时钟保持同步</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008140850958.png" alt="image-20201008140850958"></p><blockquote><p><strong>异步传输</strong>：</p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul></blockquote><h2 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h2><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008141345239.png" alt="image-20201008141345239"></p><p><strong>双向交替通信</strong>：</p><p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008141921924.png" alt="image-20201008141921924"></p><p><strong>双向同时通信</strong>：</p><p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008142037846.png" alt="image-20201008142037846"></p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h1 id="2-4、编码与调制"><a href="#2-4、编码与调制" class="headerlink" title="2.4、编码与调制"></a>2.4、编码与调制</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008144616896.png" alt="image-20201008144616896"></p><blockquote><p><strong>常用术语</strong></p><ul><li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li><li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。</p></li></ul></blockquote><p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008145747263.png" alt="image-20201008145747263"></p><h2 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h2><blockquote><p><strong>信道的几个基本概念</strong></p><ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li></ul></blockquote><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008145304974.png" alt="image-20201008145304974"></p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008145329540.png" alt="image-20201008145329540"></p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><strong>不归零编码</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008150058039.png" alt="image-20201008150058039"></p><blockquote><ul><li><p>正电平表示比特1&#x2F;0</p></li><li><p>负电平表示比特0&#x2F;1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008150528228.png" alt="image-20201008150528228"></p><blockquote><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008195033189.png" alt="image-20201008195033189"></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008151347028.png" alt="image-20201008151347028" style="zoom:67%;"><blockquote><p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008195148727.png" alt="image-20201008195148727"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li>负跳变表示比特1&#x2F;0</li><li>正跳变表示比特0&#x2F;1</li><li>码元中间时刻的跳变即表示时钟，又表示数据</li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008195235561.png" alt="image-20201008195235561"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong><ul><li>变化表示比特1&#x2F;0</li><li>不变化表示比特0&#x2F;1</li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008153522501.png" alt="image-20201008153522501"></p><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><p><strong>基本调制方法</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008155429044.png" alt="image-20201008155429044"></p><blockquote><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p>但是使用基本调制方法，1个码元只能包含1个比特信息</p></blockquote><p><strong>混合调制</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008155804617.png" alt="image-20201008155804617"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008155835940.png" alt="image-20201008155835940"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008155955169.png" alt="image-20201008155955169"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008160133748.png" alt="image-20201008160133748"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008160208060.png" alt="image-20201008160208060"></p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p><h1 id="2-5、信道的极限容量"><a href="#2-5、信道的极限容量" class="headerlink" title="2.5、信道的极限容量"></a>2.5、信道的极限容量</h1><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201010204336400.png" alt="image-20201010204336400"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201010204818976.png" alt="image-20201010204818976"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201010204928756.png" alt="image-20201010204928756"></p><p>奈氏准则和香农公式对比：</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201010205029346.png" alt="image-20201010205029346"></p><h1 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h1><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h2 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h2><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011001949479.png" alt="image-20201011001949479"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011002236208.png" alt="image-20201011002236208"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011002540041.png" alt="image-20201011002540041"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011002842704.png" alt="image-20201011002842704"></p><p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011002953703.png" alt="image-20201011002953703"></p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011003214653.png" alt="image-20201011003214653"></p><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用 CDM  (Code Division Multiplexing)</p><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h1 id="3-1、数据链路层概述"><a href="#3-1、数据链路层概述" class="headerlink" title="3.1、数据链路层概述"></a>3.1、数据链路层概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011102531462.png" alt="image-20201011102531462"></p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014004326549.png" alt="image-20201014004326549"></p><p><strong>从层次上来看数据的流动</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011102618878.png" alt="image-20201011102618878"></p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011102653161.png" alt="image-20201011102653161"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011102733584.png" alt="image-20201011102733584"></p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014004459744.png" alt="image-20201014004459744"></p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><h2 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011103650253.png" alt="image-20201011103650253"></p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011103917512.png" alt="image-20201011103917512"></p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011105314053.png" alt="image-20201011105314053"></p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011105824466.png" alt="image-20201011105824466"></p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011110017415.png" alt="image-20201011110017415"></p><p>还有数据碰撞问题</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011110129994.png" alt="image-20201011110129994"></p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p><p>在无线局域网中仍然使用的是共享信道技术</p></blockquote><hr><h1 id="3-2、封装成帧"><a href="#3-2、封装成帧" class="headerlink" title="3.2、封装成帧"></a>3.2、封装成帧</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li><strong>帧头和帧尾中包含有重要的控制信息</strong></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011110851301.png" alt="image-20201011110851301"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011111334052.png" alt="image-20201011111334052"></p><p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011111729324.png" alt="image-20201011111729324"></p><blockquote><p>前导码</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011112450187.png" alt="image-20201011112450187"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote><p><strong>透明</strong></p><p>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011113207944.png" alt="image-20201011113207944"></p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011113804721.png" alt="image-20201011113804721"></p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ul><p><strong>帧的数据部分长度</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011115008209.png" alt="image-20201011115008209"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011115049672.png" alt="image-20201011115049672"></p><hr><h1 id="3-3、差错检测"><a href="#3-3、差错检测" class="headerlink" title="3.3、差错检测"></a>3.3、差错检测</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011133757804.png" alt="image-20201011133757804"></p><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011234428217.png" alt="image-20201011234428217"></p><h2 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011234605045.png" alt="image-20201011234605045"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011234701845.png" alt="image-20201011234701845"></p><p><strong>例题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011235128869.png" alt="image-20201011235128869"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011235325022.png" alt="image-20201011235325022"></p><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201011235726437.png" alt="image-20201011235726437"></p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h1 id="3-4、可靠传输"><a href="#3-4、可靠传输" class="headerlink" title="3.4、可靠传输"></a>3.4、可靠传输</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>下面是比特差错</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012153605893.png" alt="image-20201012153605893"></p><p><strong>其他传输差错</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012153811724.png" alt="image-20201012153811724"></p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012154910921.png" alt="image-20201012154910921"></p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012155300937.png" alt="image-20201012155300937"></p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012160026362.png" alt="image-20201012160026362"></p><h2 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h2><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><h3 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h3><p><strong>确认与否认</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012162009780.png" alt="image-20201012162009780" style="zoom:67%;"><p><strong>超时重传</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012162112151.png" alt="image-20201012162112151" style="zoom:67%;"><p><strong>确认丢失</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012162318298.png" alt="image-20201012162318298" style="zoom:67%;"><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012162348428.png" alt="image-20201012162348428" style="zoom:67%;"><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012162815885.png" alt="image-20201012162815885" style="zoom:67%;"><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012164008780.png" alt="image-20201012164008780"></p><h3 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h3><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012164924635.png" alt="image-20201012164924635"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012181005719.png" alt="image-20201012181005719"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012181047665.png" alt="image-20201012181047665"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><h2 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h2><h3 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h3><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012190027828.png" alt="image-20201012190027828"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012190632086.png" alt="image-20201012190632086"></p><h3 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h3><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012191936466.png" alt="image-20201012191936466"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012192932035.png" alt="image-20201012192932035"></p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012193212419.png" alt="image-20201012193212419"></p><h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012194304696.png" alt="image-20201012194304696"></p><blockquote><p>累计确认</p><p>优点:</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h3><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012195440780.png" alt="image-20201012195440780"></p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012195629368.png" alt="image-20201012195629368"></p><p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012195836902.png" alt="image-20201012195836902"></p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012200120166.png" alt="image-20201012200120166"></p><p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012200454557.png" alt="image-20201012200454557"></p><p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012201109774.png" alt="image-20201012201109774"></p><p>习题</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012202419107.png" alt="image-20201012202419107"></p><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012202222138.png" alt="image-20201012202222138"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h2 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012203638722.png" alt="image-20201012203638722"></p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">具体流程请看视频</a></p><p><strong>习题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012205250996.png" alt="image-20201012205250996"></p><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012204742870.png" alt="image-20201012204742870"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012205133924.png" alt="image-20201012205133924"></p><hr><h1 id="3-5、点对点协议PPP"><a href="#3-5、点对点协议PPP" class="headerlink" title="3.5、点对点协议PPP"></a>3.5、点对点协议PPP</h1><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012210844629.png" alt="image-20201012210844629"></p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012211423528.png" alt="image-20201012211423528"></p><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>必须规定特殊的字符作为帧定界符</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012211826281.png" alt="image-20201012211826281"></p><h2 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h2><p> 必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012212148803.png" alt="image-20201012212148803"></p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012212255550.png" alt="image-20201012212255550"></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012212558654.png" alt="image-20201012212558654"></p><h2 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h2><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li><li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201012213021860.png" alt="image-20201012213021860"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h1 id="3-6、媒体接入控制（介质访问控制）——广播信道"><a href="#3-6、媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="3.6、媒体接入控制（介质访问控制）——广播信道"></a>3.6、媒体接入控制（介质访问控制）——广播信道</h1><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013201521915.png" alt="image-20201013201521915"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013201533445.png" alt="image-20201013201533445"></p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013201133903.png" alt="image-20201013201133903"></p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013152007335.png" alt="image-20201013152007335"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013152453425.png" alt="image-20201013152453425"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>信道复用</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013153642544.png" alt="image-20201013153642544"></p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013153947668.png" alt="image-20201013153947668"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013154142540.png" alt="image-20201013154142540"></p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013202218132.png" alt="image-20201013202218132"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p> 光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013203126625.png" alt="image-20201013203126625"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013203324709.png" alt="image-20201013203324709"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013203459640.png" alt="image-20201013203459640"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013203819578.png" alt="image-20201013203819578"></p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h2 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h2><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013211620687.png" alt="image-20201013211620687"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013213102777.png" alt="image-20201013213102777"></p><h3 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h3><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013215400688.png" alt="image-20201013215400688"></p><h3 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h3><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013215530979.png" alt="image-20201013215530979"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h3 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h3><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013221240514.png" alt="image-20201013221240514"></p><blockquote><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013221834942.png" alt="image-20201013221834942"></p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h3 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013221705893.png" alt="image-20201013221705893"></p><h3 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013223235305.png" alt="image-20201013223235305"></p><h3 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013224051932.png" alt="image-20201013224051932"></p><h3 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013225400777.png" alt="image-20201013225400777"></p><h3 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013230717856.png" alt="image-20201013230717856"></p><h3 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013231430295.png" alt="image-20201013231430295"></p><h3 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201013231703302.png" alt="image-20201013231703302"></p><h3 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h3><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CS协议</strong></p></blockquote><h2 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h2><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p><h3 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014192811760.png" alt="image-20201014192811760"></p><h3 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014200149717.png" alt="image-20201014200149717"></p><h3 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014200833233.png" alt="image-20201014200833233"></p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014201511741.png" alt="image-20201014201511741"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014201927680.png" alt="image-20201014201927680"></p><h3 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014202213766.png" alt="image-20201014202213766"></p><p><strong>退避算法的示例</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014202819851.png" alt="image-20201014202819851"></p><h3 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014203119710.png" alt="image-20201014203119710"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014203506878.png" alt="image-20201014203506878"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014203859033.png" alt="image-20201014203859033"></p><hr><h1 id="3-7、MAC地址、IP地址以及ARP协议"><a href="#3-7、MAC地址、IP地址以及ARP协议" class="headerlink" title="3.7、MAC地址、IP地址以及ARP协议"></a>3.7、MAC地址、IP地址以及ARP协议</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014222831663.png" alt="image-20201014222831663"></p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014223659993.png" alt="image-20201014223659993"></p><h3 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014224732019.png" alt="image-20201014224732019"></p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h3 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014225358570.png" alt="image-20201014225358570"></p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li></ul><p><strong>网络接口标识符</strong></p><ul><li>由获得OUI的厂商自行随意分配</li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014230248959.png" alt="image-20201014230248959"></p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p></blockquote><h3 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014230625182.png" alt="image-20201014230625182"></p><h3 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014230822305.png" alt="image-20201014230822305"></p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014231244655.png" alt="image-20201014231244655"></p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h3 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014231754669.png" alt="image-20201014231754669"></p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014232132424.png" alt="image-20201014232132424"></p><blockquote><p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h3 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201014232714791.png" alt="image-20201014232714791"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015001243584.png" alt="image-20201015001243584"></p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015001535528.png" alt="image-20201015001535528"></p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015002054876.png" alt="image-20201015002054876"></p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p></blockquote><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015104441580.png" alt="image-20201015104441580"></p><h3 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015104913755.png" alt="image-20201015104913755"></p><h3 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h3><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015105455043.png" alt="image-20201015105455043"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210103212224961.png" alt="image-20210103212224961"></p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP（地址解析协议）</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015113826197.png" alt="image-20201015113826197"></p><p>ARP高速缓存表</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015114052206.png" alt="image-20201015114052206"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015114444263.png" alt="image-20201015114444263"></p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015114811501.png" alt="image-20201015114811501"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015115212170.png" alt="image-20201015115212170"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015115236673.png" alt="image-20201015115236673"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015115252972.png" alt="image-20201015115252972"></p><p>动态与静态的区别</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015115831543.png" alt="image-20201015115831543"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015120108028.png" alt="image-20201015120108028"></p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015120707150.png" alt="image-20201015120707150"></p><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p></blockquote><hr><h1 id="3-8、集线器与交换机的区别"><a href="#3-8、集线器与交换机的区别" class="headerlink" title="3.8、集线器与交换机的区别"></a>3.8、集线器与交换机的区别</h1><h2 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015144628691.png" alt="image-20201015144628691"></p><blockquote><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li><li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li><li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li></ul></blockquote><h3 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h3><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015145732275.png" alt="image-20201015145732275"></p><blockquote><ul><li><strong>优点</strong><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><strong>缺点</strong><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li></ol></li></ul></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h2 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015150620067.png" alt="image-20201015150620067"></p><blockquote><p><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li></ul><p><strong>交换机</strong></p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul></blockquote><h3 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015152232158.png" alt="image-20201015152232158"></p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015152858146.png" alt="image-20201015152858146"></p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015153907268.png" alt="image-20201015153907268"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015154523036.png" alt="image-20201015154523036"></p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015155408692.png" alt="image-20201015155408692"></p><p><strong>广播</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015155440402.png" alt="image-20201015155440402"></p><p><strong>多个单播</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015155526386.png" alt="image-20201015155526386"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015155706698.png" alt="image-20201015155706698"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015160146482.png" alt="image-20201015160146482"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015160526999.png" alt="image-20201015160526999"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h1 id="3-9、以太网交换机自学习和转发帧的流程"><a href="#3-9、以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9、以太网交换机自学习和转发帧的流程"></a>3.9、以太网交换机自学习和转发帧的流程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015161015165.png" alt="image-20201015161015165"></p><h2 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h2><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015161458528.png" alt="image-20201015161458528"></p><blockquote><ol><li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li><li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li><li>主机B发现是给自己的帧，接受该帧</li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015162310922.png" alt="image-20201015162310922"></p><blockquote><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015162622462.png" alt="image-20201015162622462"></p><blockquote><ol><li>E 向 A发送一帧</li><li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li><li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li><li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li><li>主机 A 发现目的地址是它，就接受该帧</li></ol></blockquote><p><strong>G -&gt; A</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015163157140.png" alt="image-20201015163157140"></p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li>主机 G 发送给 主机 A 一个帧</li><li>主机 A 和 交换机接口 1都能接收到</li><li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li><li>交换机 1收到该帧后，首先进行登记工作</li><li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li><li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015164210543.png" alt="image-20201015164210543"></p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015170656500.png" alt="image-20201015170656500"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015170739679.png" alt="image-20201015170739679"></p><hr><h1 id="3-10、以太网交换机的生成树协议STP"><a href="#3-10、以太网交换机的生成树协议STP" class="headerlink" title="3.10、以太网交换机的生成树协议STP"></a>3.10、以太网交换机的生成树协议STP</h1><h2 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015171453001.png" alt="image-20201015171453001"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015171515481.png" alt="image-20201015171515481"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015171900775.png" alt="image-20201015171900775"></p><h2 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015172204419.png" alt="image-20201015172204419"></p><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015202257756.png" alt="image-20201015202257756"></p><hr><h1 id="3-11、虚拟局域网VLAN"><a href="#3-11、虚拟局域网VLAN" class="headerlink" title="3.11、虚拟局域网VLAN"></a>3.11、虚拟局域网VLAN</h1><h2 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h2><p><strong>广播风暴</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015202859124.png" alt="image-20201015202859124"></p><p><strong>分割广播域的方法</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015203113654.png" alt="image-20201015203113654"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015203559548.png" alt="image-20201015203559548"></p><blockquote><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul></blockquote><h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015204639599.png" alt="image-20201015204639599"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015204749141.png" alt="image-20201015204749141"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015205311757.png" alt="image-20201015205311757"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015205947636.png" alt="image-20201015205947636"></p><p><strong>小例题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015210417695.png" alt="image-20201015210417695"></p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015211031361.png" alt="image-20201015211031361"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015211349531.png" alt="image-20201015211349531"></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201015211512622.png" alt="image-20201015211512622"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol></blockquote><h1 id="4-1、网络层概述"><a href="#4-1、网络层概述" class="headerlink" title="4.1、网络层概述"></a>4.1、网络层概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017134630948.png" alt="image-20201017134630948"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017135644630.png" alt="image-20201017135644630"></p><ul><li>路由选择问题</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017135710478.png" alt="image-20201017135710478"></p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017135914985.png" alt="image-20201017135914985"></p><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li><li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li></ul></blockquote></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017142545630.png" alt="image-20201017142545630"></p><blockquote><p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017140623851.png" alt="image-20201017140623851"></p><hr><h1 id="4-2、网络层提供的两种服务"><a href="#4-2、网络层提供的两种服务" class="headerlink" title="4.2、网络层提供的两种服务"></a>4.2、网络层提供的两种服务</h1><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li></ul><h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017141425892.png" alt="image-20201017141425892"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li><li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li></ul></blockquote><h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017141851030.png" alt="image-20201017141851030"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li><li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></blockquote><h2 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h2><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h1 id="4-3、IPv4"><a href="#4-3、IPv4" class="headerlink" title="4.3、IPv4"></a>4.3、IPv4</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017143206060.png" alt="image-20201017143206060"></p><h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017144317166.png" alt="image-20201017144317166"></p><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul><p><strong>A类地址</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017145210533.png" alt="image-20201017145210533"></p><p><strong>B类地址</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017145508001.png" alt="image-20201017145508001"></p><p><strong>C类地址</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017150204774.png" alt="image-20201017150204774"></p><p><strong>练习</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017150543386.png" alt="image-20201017150543386"></p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><strong>IP 地址的指派范围</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017152911541.png" alt="image-20201017152911541"></p><p><strong>一般不使用的特殊的 IP 地址</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017152959586.png" alt="image-20201017152959586"></p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ul><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><h3 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h3><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li>IP 地址空间的利用率有时很低。 </li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li><li>两级的 IP 地址不够灵活。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017154645198.png" alt="image-20201017154645198"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017154852896.png" alt="image-20201017154852896"></p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017155026814.png" alt="image-20201017155026814"></p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li><li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li><li>划分子网已成为互联网的正式标准协议。</li></ul></blockquote><h3 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h3><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017155930011.png" alt="image-20201017155930011"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017160116239.png" alt="image-20201017160116239"></p><blockquote><ul><li><strong>优点</strong><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017160252066.png" alt="image-20201017160252066"></p><blockquote><p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017161651058.png" alt="image-20201017161651058"></p><p>例子2</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017161719339.png" alt="image-20201017161719339"></p><p><strong>默认子网掩码</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017162807076.png" alt="image-20201017162807076"></p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017162938612.png" alt="image-20201017162938612"></p><blockquote><ul><li>子网掩码是一个网络或一个子网的重要属性。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><h3 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h3><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017164031532.png" alt="image-20201017164031532"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li></ul></blockquote><h3 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017165037268.png" alt="image-20201017165037268"></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017165113442.png" alt="image-20201017165113442"></p><h3 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017165615915.png" alt="image-20201017165615915"></p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201017170552495.png" alt="image-20201017170552495"></p><h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><h3 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018143550103.png" alt="image-20201018143550103"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018140809079.png" alt="image-20201018140809079"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018140916631.png" alt="image-20201018140916631"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018141132446.png" alt="image-20201018141132446"></p><blockquote><p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的N1</del>N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p></blockquote><h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018143632352.png" alt="image-20201018143632352"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018142333145.png" alt="image-20201018142333145"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018143344440.png" alt="image-20201018143344440"></p><hr><h1 id="4-4、IP数据报的发送和转发过程"><a href="#4-4、IP数据报的发送和转发过程" class="headerlink" title="4.4、IP数据报的发送和转发过程"></a>4.4、IP数据报的发送和转发过程</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018144335297.png" alt="image-20201018144335297"></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018151314019.png" alt="image-20201018151314019"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018150151171.png" alt="image-20201018150151171"></p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018150223497.png" alt="image-20201018150223497"></p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018145501063.png" alt="image-20201018145501063"></p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018150029179.png" alt="image-20201018150029179"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018151108989.png" alt="image-20201018151108989"></p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018151528027.png" alt="image-20201018151528027"></p><blockquote><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018151956275.png" alt="image-20201018151956275"></p><p>路由器是隔离广播域的</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018152040610.png" alt="image-20201018152040610"></p><hr><h1 id="4-5、静态路由配置及其可能产生的路由环路问题"><a href="#4-5、静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5、静态路由配置及其可能产生的路由环路问题"></a>4.5、静态路由配置及其可能产生的路由环路问题</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018155702081.png" alt="image-20201018155702081"></p><h2 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h2><p> <strong>静态路由配置</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018160349375.png" alt="image-20201018160349375"></p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018160906284.png" alt="image-20201018160906284"></p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018161440257.png" alt="image-20201018161440257"></p><blockquote><p>多条路由可选，匹配路由最具体的</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018161542579.png" alt="image-20201018161542579"></p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018162041966.png" alt="image-20201018162041966"></p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018162333671.png" alt="image-20201018162333671"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018162759562.png" alt="image-20201018162759562"></p><p>错误情况</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018163323343.png" alt="image-20201018163323343"></p><p>解决方法</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018163933715.png" alt="image-20201018163933715"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018164453398.png" alt="image-20201018164453398"></p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018164811811.png" alt="image-20201018164811811"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018164913684.png" alt="image-20201018164913684"></p><p>解决方法</p><p>添加故障的网络为黑洞路由</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018165122023.png" alt="image-20201018165122023"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018165153517.png" alt="image-20201018165153517"></p><p>假设。一段时间后故障网络恢复了</p><p>R1又自动地得出了其接口0的直连网络的路由条目</p><p>针对该网络的黑洞网络会自动失效</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018165328319.png" alt="image-20201018165328319"></p><p>如果又故障</p><p>则生效该网络的黑洞网络</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018165521938.png" alt="image-20201018165521938"></p><h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201018165709294.png" alt="image-20201018165709294"></p><hr><h1 id="4-6、路由选择协议"><a href="#4-6、路由选择协议" class="headerlink" title="4.6、路由选择协议"></a>4.6、路由选择协议</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019134827343.png" alt="image-20201019134827343"></p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019134946971.png" alt="image-20201019134946971"></p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019135122326.png" alt="image-20201019135122326"></p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019135328925.png" alt="image-20201019135328925"></p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019140009740.png" alt="image-20201019140009740"></p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019140234652.png" alt="image-20201019140234652"></p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p> 由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141149194.png" alt="image-20201019141149194" style="zoom:50%;"><p>物理层将信号转换成比特流，送交数据链路层处理</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141210774.png" alt="image-20201019141210774" style="zoom: 50%;"><p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141242246.png" alt="image-20201019141242246" style="zoom:50%;"><p>  如果送交网络层的分组是普通待转发的数据分组</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141305650.png" alt="image-20201019141305650" style="zoom:50%;"><p>   则根据分组首部中的目的地址进行查表转发</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141327380.png" alt="image-20201019141327380" style="zoom:50%;"><p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p></li><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141745375.png" alt="image-20201019141745375" style="zoom:50%;"><p>数据链路层将数据分组封装成帧，交给物理层处理</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019141838032.png" alt="image-20201019141838032" style="zoom:50%;"><p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p></li></ul><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019143040253.png" alt="image-20201019143040253"></p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p></blockquote><p> 2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019142228360.png" alt="image-20201019142228360" style="zoom:50%;"><p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019142415055.png" alt="image-20201019142415055"></p><p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019142924889.png" alt="image-20201019142924889"></p></li></ul><h2 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019144915687.png" alt="image-20201019144915687"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019145247606.png" alt="image-20201019145247606"></p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019145510947.png" alt="image-20201019145510947"></p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019145627339.png" alt="image-20201019145627339"></p><blockquote><p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019150120900.png" alt="image-20201019150120900"></p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019150412666.png" alt="image-20201019150412666"></p><p>举例2</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019150525711.png" alt="image-20201019150525711"></p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019151041492.png" alt="image-20201019151041492"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019151135255.png" alt="image-20201019151135255"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019151332767.png" alt="image-20201019151332767"></p><p>解决方法</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019151639181.png" alt="image-20201019151639181"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019152526098.png" alt="image-20201019152526098"></p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h2 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h2><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019161841695.png" alt="image-20201019161841695"></p><p><strong>问候（Hello）分组</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019161653875.png" alt="image-20201019161653875"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019162341151.png" alt="image-20201019162341151"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019162933483.png" alt="image-20201019162933483"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019163148068.png" alt="image-20201019163148068"></p><p><strong>OSPF五种分组类型</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019163250129.png" alt="image-20201019163250129"></p><p><strong>OSPF的基本工作过程</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019163746254.png" alt="image-20201019163746254"></p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019164657606.png" alt="image-20201019164657606"></p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p></li><li><p>每个区域都有一个32比特的区域标识符</p></li><li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p></li><li><p>其他区域的区域标识符不能为0且不相同</p></li><li><p>每个区域一般不应包含路由器超过200个</p></li><li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019170100568.png" alt="image-20201019170100568"></p><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019170217622.png" alt="image-20201019170217622"></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019191438399.png" alt="image-20201019191438399"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019191718506.png" alt="image-20201019191718506"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019191836397.png" alt="image-20201019191836397"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019192031087.png" alt="image-20201019192031087"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019192059962.png" alt="image-20201019192059962"></p><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019192840368.png" alt="image-20201019192840368"></p><h2 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019192800829.png" alt="image-20201019192800829"></p><hr><h1 id="4-7、IPv4数据报的首部格式"><a href="#4-7、IPv4数据报的首部格式" class="headerlink" title="4.7、IPv4数据报的首部格式"></a>4.7、IPv4数据报的首部格式</h1><h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019205931748.png" alt="image-20201019205931748"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019211719880.png" alt="image-20201019211719880"></p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019212617006.png" alt="image-20201019212617006"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019220435415.png" alt="image-20201019220435415"></p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019221021157.png" alt="image-20201019221021157"></p><p>​        现在假定分片2的IP数据报经过某个网络时还需要进行分片</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019221246870.png" alt="image-20201019221246870"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019222512112.png" alt="image-20201019222512112"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019222552444.png" alt="image-20201019222552444"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019222729797.png" alt="image-20201019222729797"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019223101434.png" alt="image-20201019223101434"></p><h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019225141559.png" alt="image-20201019225141559"></p><hr><h1 id="4-8、网际控制报文协议ICMP"><a href="#4-8、网际控制报文协议ICMP" class="headerlink" title="4.8、网际控制报文协议ICMP"></a>4.8、网际控制报文协议ICMP</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019232539898.png" alt="image-20201019232539898"></p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020001035813.png" alt="image-20201020001035813"></p><h2 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h2><h3 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019230838587.png" alt="image-20201019230838587"></p><h3 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019231022291.png" alt="image-20201019231022291"></p><h3 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019231230798.png" alt="image-20201019231230798"></p><h3 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019231355471.png" alt="image-20201019231355471"></p><h3 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019231553990.png" alt="image-20201019231553990"></p><h3 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019231733673.png" alt="image-20201019231733673"></p><h2 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h2><h3 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019233817921.png" alt="image-20201019233817921"></p><h3 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019234123026.png" alt="image-20201019234123026"></p><p><strong>tracert命令的实现原理</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019234718107.png" alt="image-20201019234718107"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019234741268.png" alt="image-20201019234741268"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019234758693.png" alt="image-20201019234758693"></p><h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019234909146.png" alt="image-20201019234909146"></p><hr><h1 id="4-9、虚拟专用网VPN与网络地址转换NAT"><a href="#4-9、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9、虚拟专用网VPN与网络地址转换NAT"></a>4.9、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h2><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019235534728.png" alt="image-20201019235534728"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019235631474.png" alt="image-20201019235631474"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201019235718010.png" alt="image-20201019235718010"></p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020000136443.png" alt="image-20201020000136443"></p><blockquote><p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p><p>私有地址只能用作本地地址而不能用作全球地址</p><p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p><strong>本地地址与全球地址</strong></p><ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020000618797.png" alt="image-20201020000618797"></p><p>部门A向部门B发送数据流程</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020001107425.png" alt="image-20201020001107425"></p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020001528569.png" alt="image-20201020001528569"></p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020001935801.png" alt="image-20201020001935801"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020002020607.png" alt="image-20201020002020607"></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020002439942.png" alt="image-20201020002439942"></p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020002734192.png" alt="image-20201020002734192"></p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020003238729.png" alt="image-20201020003238729"></p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020003411024.png" alt="image-20201020003411024"></p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020003658349.png" alt="image-20201020003658349"></p><p>这种基本转换存在一个问题</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020003733863.png" alt="image-20201020003733863"></p><p>解决方法</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020003840584.png" alt="image-20201020003840584"></p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020004159360.png" alt="image-20201020004159360"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020004312942.png" alt="image-20201020004312942"></p><h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020004447021.png" alt="image-20201020004447021"></p><h1 id="5-1、运输层概述"><a href="#5-1、运输层概述" class="headerlink" title="5.1、运输层概述"></a>5.1、运输层概述</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p><strong>进程之间的通信</strong></p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020211725185.png" alt="image-20201020211725185" style="zoom:67%;"><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020211339131.png" alt="image-20201020211339131"></p><p><strong>进程之间通信流程</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020213721054.png" alt="image-20201020213721054"></p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020220439303.png" alt="image-20201020220439303"></p><h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020220545411.png" alt="image-20201020220545411"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020222828878.png" alt="image-20201020222828878"></p><hr><h1 id="5-2、运输层端口号、复用与分用的概念"><a href="#5-2、运输层端口号、复用与分用的概念" class="headerlink" title="5.2、运输层端口号、复用与分用的概念"></a>5.2、运输层端口号、复用与分用的概念</h1><h2 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020223242364.png" alt="image-20201020223242364"></p><h2 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020223920225.png" alt="image-20201020223920225"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p></blockquote><h2 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020224521744.png" alt="image-20201020224521744"></p><h2 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h2><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020224658524.png" alt="image-20201020224658524"></p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020225830336.png" alt="image-20201020225830336"></p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020230059196.png" alt="image-20201020230059196"></p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020231032812.png" alt="image-20201020231032812"></p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020231308120.png" alt="image-20201020231308120"></p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020231935656.png" alt="image-20201020231935656"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020232517383.png" alt="image-20201020232517383"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020232132890.png" alt="image-20201020232132890"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020232548833.png" alt="image-20201020232548833"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201020232337332.png" alt="image-20201020232337332"></p><hr><h1 id="5-3、UDP和TCP的对比"><a href="#5-3、UDP和TCP的对比" class="headerlink" title="5.3、UDP和TCP的对比"></a>5.3、UDP和TCP的对比</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li></ul><p>可靠信道与不可靠信道</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021192221061.png" alt="image-20201021192221061"></p><ul><li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p></li><li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p></li><li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021193640130.png" alt="image-20201021193640130"></p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h2 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h2><p>可以发送广播</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021194104694.png" alt="image-20201021194104694" style="zoom: 50%;"><p>可以向某个多播组发送多播</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021194225567.png" alt="image-20201021194225567" style="zoom:50%;"><p>还可以发送单播</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021194341256.png" alt="image-20201021194341256" style="zoom:50%;"><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021195034383.png" alt="image-20201021195034383"></p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p> 换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021204152175.png" alt="image-20201021204152175"></p><p>UDP结构</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021205214512.png" alt="image-20201021205214512"></p><h2 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h2><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021194557102.png" alt="image-20201021194557102" style="zoom:50%;"><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021194749562.png" alt="image-20201021194749562" style="zoom:50%;"><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021195435677.png" alt="image-20201021195435677"></p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021204508839.png" alt="image-20201021204508839"></p><p>TCP结构</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021205307406.png" alt="image-20201021205307406"></p><h2 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023004653315.png" alt="image-20201023004653315"></p><hr><h1 id="5-4、TCP的流量控制"><a href="#5-4、TCP的流量控制" class="headerlink" title="5.4、TCP的流量控制"></a>5.4、TCP的流量控制</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021223432091.png" alt="image-20201021223432091"></p><p>举例</p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021231801076.png" alt="image-20201021231801076"></p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021231904707.png" alt="image-20201021231904707"></p><p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021231945653.png" alt="image-20201021231945653"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021232027721.png" alt="image-20201021232027721"></p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021232600497.png" alt="image-20201021232600497"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021232645300.png" alt="image-20201021232645300"></p><blockquote><p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></blockquote><h2 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201021234004254.png" alt="image-20201021234004254"></p><hr><h1 id="5-5、TCP的拥塞控制"><a href="#5-5、TCP的拥塞控制" class="headerlink" title="5.5、TCP的拥塞控制"></a>5.5、TCP的拥塞控制</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022141057083.png" alt="image-20201022141057083"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022142108309.png" alt="image-20201022142108309"></p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022141423443.png" alt="image-20201022141423443"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022141556134.png" alt="image-20201022141556134"></p><blockquote><p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><h4 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h4><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022145631052.png" alt="image-20201022145631052"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022144725100.png" alt="image-20201022144725100"></p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h4 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h4><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022150143886.png" alt="image-20201022150143886"></p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022145749592.png" alt="image-20201022145749592"></p><p>这个时候又回到了慢开始</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022145544163.png" alt="image-20201022145544163"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022145824004.png" alt="image-20201022145824004"></p><h4 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h4><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022150236926.png" alt="image-20201022150236926"></p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022150902709.png" alt="image-20201022150902709"></p><h4 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h4><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022151250183.png" alt="image-20201022151250183"></p><h4 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h4><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022151819265.png" alt="image-20201022151819265"></p><h4 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h4><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022152041751.png" alt="image-20201022152041751"></p><hr><h1 id="5-6、TCP超时重传时间的选择"><a href="#5-6、TCP超时重传时间的选择" class="headerlink" title="5.6、TCP超时重传时间的选择"></a>5.6、TCP超时重传时间的选择</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022152651184.png" alt="image-20201022152651184"></p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022152708875.png" alt="image-20201022152708875"></p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022153244047.png" alt="image-20201022153244047"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022153518218.png" alt="image-20201022153518218"></p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022153758413.png" alt="image-20201022153758413"></p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022154045440.png" alt="image-20201022154045440"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022154137911.png" alt="image-20201022154137911"></p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022154350745.png" alt="image-20201022154350745"></p><p><strong>总结</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022154418863.png" alt="image-20201022154418863"></p><hr><h1 id="5-7、TCP可靠传输的实现"><a href="#5-7、TCP可靠传输的实现" class="headerlink" title="5.7、TCP可靠传输的实现"></a>5.7、TCP可靠传输的实现</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022161436801.png" alt="image-20201022161436801"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022161734997.png" alt="image-20201022161734997"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022164339902.png" alt="image-20201022164339902"></p><hr><h1 id="5-8、TCP的运输连接管理"><a href="#5-8、TCP的运输连接管理" class="headerlink" title="5.8、TCP的运输连接管理"></a>5.8、TCP的运输连接管理</h1><h2 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022193215183.png" alt="image-20201022193215183"></p><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h3 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022193418673.png" alt="image-20201022193418673"></p><h3 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022194219693.png" alt="image-20201022194219693"></p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022194350899.png" alt="image-20201022194350899"></p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022194926877.png" alt="image-20201022194926877"></p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022195108616.png" alt="image-20201022195108616"></p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022195847144.png" alt="image-20201022195847144"></p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022202010182.png" alt="image-20201022202010182"></p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022202932905.png" alt="image-20201022202932905"></p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022203744174.png" alt="image-20201022203744174"></p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p><p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022204422775.png" alt="image-20201022204422775"></p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h3 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022205124204.png" alt="image-20201022205124204"></p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022210030419.png" alt="image-20201022210030419"></p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022232158631.png" alt="image-20201022232158631"></p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022233050922.png" alt="image-20201022233050922"></p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022233941557.png" alt="image-20201022233941557"></p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022234741310.png" alt="image-20201022234741310"></p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022234942562.png" alt="image-20201022234942562"></p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h3 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h3><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201022235800155.png" alt="image-20201022235800155"></p><hr><h1 id="5-9、TCP报文段的首部格式"><a href="#5-9、TCP报文段的首部格式" class="headerlink" title="5.9、TCP报文段的首部格式"></a>5.9、TCP报文段的首部格式</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023000859363.png" alt="image-20201023000859363"></p><h2 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><p>源端口和目的端口</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023005210010.png" alt="image-20201023005210010"></p><p>序号、确认号和确认标志位</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023003826059.png" alt="image-20201023003826059"></p><p>数据偏移、保留、窗口和校验和</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023004227265.png" alt="image-20201023004227265"></p><p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023005001450.png" alt="image-20201023005001450"></p><p>选项和填充</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023005132426.png" alt="image-20201023005132426"></p><h1 id="6-1、应用层概述"><a href="#6-1、应用层概述" class="headerlink" title="6.1、应用层概述"></a>6.1、应用层概述</h1><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023195112701.png" alt="image-20201023195112701"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023200511781.png" alt="image-20201023200511781"></p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023200819770.png" alt="image-20201023200819770"></p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023201028141.png" alt="image-20201023201028141"></p><p>常见的应用</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023201101024.png" alt="image-20201023201101024"></p><p>总结</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023201137047.png" alt="image-20201023201137047"></p><hr><h1 id="6-2、客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#6-2、客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="6.2、客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>6.2、客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h1><h2 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023201308269.png" alt="image-20201023201308269"></p><h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023201610088.png" alt="image-20201023201610088"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023202017683.png" alt="image-20201023202017683"></p><h2 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023202049202.png" alt="image-20201023202049202"></p><hr><h1 id="6-3、动态主机配置协议DHCP"><a href="#6-3、动态主机配置协议DHCP" class="headerlink" title="6.3、动态主机配置协议DHCP"></a>6.3、动态主机配置协议DHCP</h1><h2 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h2><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h2 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h2><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023205719672.png" alt="image-20201023205719672"></p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023210345650.png" alt="image-20201023210345650"></p><h2 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h2><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023211525686.png" alt="image-20201023211525686"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023213058543.png" alt="image-20201023213058543"></p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息：<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023214542329.png" alt="image-20201023214542329"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023215341522.png" alt="image-20201023215341522"></p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023215652859.png" alt="image-20201023215652859"></p></blockquote><p>剩下流程图示</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023220114952.png" alt="image-20201023220114952"></p><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023221111923.png" alt="image-20201023221111923"></p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h2 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023221251022.png" alt="image-20201023221251022"></p><hr><h1 id="6-4、域名系统DNS"><a href="#6-4、域名系统DNS" class="headerlink" title="6.4、域名系统DNS"></a>6.4、域名系统DNS</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>域名相比IP地址更容易记忆</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023234832678.png" alt="image-20201023234832678"></p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023235123151.png" alt="image-20201023235123151"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023235231869.png" alt="image-20201023235231869"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023235457857.png" alt="image-20201023235457857"></p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023235617575.png" alt="image-20201023235617575"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201023235910545.png" alt="image-20201023235910545"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024000255580.png" alt="image-20201024000255580"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024000335147.png" alt="image-20201024000335147"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024000408396.png" alt="image-20201024000408396"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024002135210.png" alt="image-20201024002135210"></p><h2 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024002224354.png" alt="image-20201024002224354"></p><hr><h1 id="6-5、文件传送协议FTP"><a href="#6-5、文件传送协议FTP" class="headerlink" title="6.5、文件传送协议FTP"></a>6.5、文件传送协议FTP</h1><h2 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024132745558.png" alt="image-20201024132745558"></p><h2 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h2><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024133155327.png" alt="image-20201024133155327" style="zoom:50%;"><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024133247537.png" alt="image-20201024133247537" style="zoom:50%;"><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024133400777.png" alt="image-20201024133400777"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024133601943.png" alt="image-20201024133601943"></p><h2 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h2><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024134319922.png" alt="image-20201024134319922"></p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024134624114.png" alt="image-20201024134624114"></p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024135018620.png" alt="image-20201024135018620" style="zoom:67%;"><p>两种模式对比</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024135050743.png" alt="image-20201024135050743"></p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><h2 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024135848563.png" alt="image-20201024135848563"></p><hr><h1 id="6-6、电子邮件"><a href="#6-6、电子邮件" class="headerlink" title="6.6、电子邮件"></a>6.6、电子邮件</h1><h2 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024151757221.png" alt="image-20201024151757221"></p><h2 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024152052056.png" alt="image-20201024152052056"></p><h2 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024152628966.png" alt="image-20201024152628966"></p><h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024153425016.png" alt="image-20201024153425016"></p><h2 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024153736033.png" alt="image-20201024153736033"></p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024154039565.png" alt="image-20201024154039565"></p><h2 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024154744175.png" alt="image-20201024154744175"></p><hr><h1 id="6-7、万维网WWW"><a href="#6-7、万维网WWW" class="headerlink" title="6.7、万维网WWW"></a>6.7、万维网WWW</h1><h2 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h2><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024170819303.png" alt="image-20201024170819303"></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024171432743.png" alt="image-20201024171432743"></p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024170923530.png" alt="image-20201024170923530"></p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024171058583.png" alt="image-20201024171058583"></p><p><strong>万维网的文档</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024171724030.png" alt="image-20201024171724030"></p><h2 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h2><h3 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024222457800.png" alt="image-20201024222457800"></p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024222825888.png" alt="image-20201024222825888"></p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p><strong>HTTP请求报文格式</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024224828528.png" alt="image-20201024224828528"></p><p><strong>HTTP响应报文格式</strong></p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024224920638.png" alt="image-20201024224920638"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024224945200.png" alt="image-20201024224945200"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024224632514.png" alt="image-20201024224632514"></p><p>如果该请求有缓存</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024224720124.png" alt="image-20201024224720124"></p><p>如果该请求没有缓存</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024225013288.png" alt="image-20201024225013288"></p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024225504869.png" alt="image-20201024225504869"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024225846863.png" alt="image-20201024225846863"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024230242550.png" alt="image-20201024230242550"></p><h2 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201024231143505.png" alt="image-20201024231143505"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试题</title>
      <link href="/2020/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95100%E9%A2%98/"/>
      <url>/2020/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95100%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络面试100题"><a href="#计算机网络面试100题" class="headerlink" title="计算机网络面试100题"></a>计算机网络面试100题</h2><h3 id="1、OSI-的七层模型分别是？各自的功能是什么？"><a href="#1、OSI-的七层模型分别是？各自的功能是什么？" class="headerlink" title="1、OSI 的七层模型分别是？各自的功能是什么？"></a>1、OSI 的七层模型分别是？各自的功能是什么？</h3><h5 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h5><ul><li><p>物理层：底层数据传输，如网线；网卡标准。 </p></li><li><p>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</p></li><li><p>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</p></li><li><p>传输层：端到端传输数据的基本功能；如 TCP、UDP。</p></li><li><p>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</p></li><li><p>表示层：数据格式标识，基本压缩加密功能。</p></li><li><p>应用层：各种应用软件，包括 Web 应用。</p></li></ul><p>说明：</p><ul><li>在四层，既传输层数据被称作<strong>段</strong>（Segments）；</li><li>三层网络层数据被称做<strong>包</strong>（Packages）；</li><li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li><li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>网络七层模型是一个标准，而非实现。</li><li>网络四层模型是一个实现的应用模型。</li><li>网络四层模型由七层模型简化合并而来。</li></ul><h3 id="2、说一下一次完整的HTTP请求过程包括哪些内容？"><a href="#2、说一下一次完整的HTTP请求过程包括哪些内容？" class="headerlink" title="2、说一下一次完整的HTTP请求过程包括哪些内容？"></a>2、说一下一次完整的HTTP请求过程包括哪些内容？</h3><h4 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a>第一种回答</h4><ul><li>建立起客户机和服务器连接。</li><li>建立连接后，客户机发送一个请求给服务器。</li><li>服务器收到请求给予响应信息。</li><li>客户端浏览器将返回的内容解析并呈现，断开连接。</li></ul><h4 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a>第二种回答</h4><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户。</p><h3 id="3、你知道DNS是什么？"><a href="#3、你知道DNS是什么？" class="headerlink" title="3、你知道DNS是什么？"></a>3、你知道DNS是什么？</h3><p><strong>官方解释</strong>：DNS（Domain Name System，域名系统），因特网上作为<strong>域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><p><strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。</a></p><h3 id="4、DNS的工作原理？"><a href="#4、DNS的工作原理？" class="headerlink" title="4、DNS的工作原理？"></a>4、DNS的工作原理？</h3><p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/QQ%E6%88%AA%E5%9B%BE20210317172225.png"><br>过程：<br>总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。<br>一、主机向本地域名服务器的查询一般都是采用递归查询。<br>二、本地域名服务器向根域名服务器的查询的迭代查询。<br>1)当用户输入域名时，浏览器先检查自己的缓存中是否 这个域名映射的ip地址，有解析结束。<br>2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。<br>3）若无命中，则请求本地域名服务器解析（ LDNS）。<br>4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。<br>5） 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址<br>6） Name Server根据映射关系表找到目标ip，返回给LDNS<br>7） LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</p><h3 id="5、为什么域名解析用UDP协议？"><a href="#5、为什么域名解析用UDP协议？" class="headerlink" title="5、为什么域名解析用UDP协议？"></a>5、为什么域名解析用UDP协议？</h3><p>因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。</p><p>而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。</p><p>不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。</p><h3 id="6、为什么区域传送用TCP协议？"><a href="#6、为什么区域传送用TCP协议？" class="headerlink" title="6、为什么区域传送用TCP协议？"></a>6、为什么区域传送用TCP协议？</h3><p>因为TCP协议可靠性好啊！</p><p>你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！</p><h3 id="7、HTTP长连接和短连接的区别"><a href="#7、HTTP长连接和短连接的区别" class="headerlink" title="7、HTTP长连接和短连接的区别"></a>7、HTTP长连接和短连接的区别</h3><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。</p><h3 id="8、什么是TCP粘包-x2F-拆包？发生的原因？"><a href="#8、什么是TCP粘包-x2F-拆包？发生的原因？" class="headerlink" title="8、什么是TCP粘包&#x2F;拆包？发生的原因？"></a>8、什么是TCP粘包&#x2F;拆包？发生的原因？</h3><p>一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.</p><p>2、进行MSS大小的TCP分段。( MSS&#x3D;TCP报文段长度-TCP首部长度)</p><p>3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1、消息定长。</p><p>2、在包尾部增加回车或者空格符等特殊字符进行分割3. 将消息分为消息头和消息尾。4. 使用其它复杂的协议，如RTMP协议等。</p><h3 id="9、为什么服务器会缓存这一项功能-如何实现的？"><a href="#9、为什么服务器会缓存这一项功能-如何实现的？" class="headerlink" title="9、为什么服务器会缓存这一项功能?如何实现的？"></a>9、为什么服务器会缓存这一项功能?如何实现的？</h3><p><strong>原因</strong></p><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><p><strong>实现方法</strong></p><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h3 id="10、HTTP请求方法你知道多少？"><a href="#10、HTTP请求方法你知道多少？" class="headerlink" title="10、HTTP请求方法你知道多少？"></a>10、HTTP请求方法你知道多少？</h3><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th align="left">序  号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h3 id="11、GET-和-POST-的区别，你知道哪些？"><a href="#11、GET-和-POST-的区别，你知道哪些？" class="headerlink" title="11、GET 和 POST 的区别，你知道哪些？"></a>11、GET 和 POST 的区别，你知道哪些？</h3><ol><li><p>get是获取数据，post是修改数据</p></li><li><p>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）</p></li><li><p>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</p></li><li><p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p></li><li><p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p></li><li><p>本质区别：GET是幂等的，而POST不是幂等的</p><blockquote><p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p></blockquote></li></ol><p>正因为它们有这样的区别，所以不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</p><h3 id="12、一个TCP连接可以对应几个HTTP请求？"><a href="#12、一个TCP连接可以对应几个HTTP请求？" class="headerlink" title="12、一个TCP连接可以对应几个HTTP请求？"></a>12、一个TCP连接可以对应几个HTTP请求？</h3><p>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</p><h3 id="13、一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"><a href="#13、一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？" class="headerlink" title="13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"></a>13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</h3><p>HTTP&#x2F;1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p><p>在 HTTP&#x2F;1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p><p>那么在 HTTP&#x2F;1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p><ul><li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li><li>和服务器建立多个 TCP 连接。</li></ul><h3 id="14、浏览器对同一-Host-建立-TCP-连接到数量有没有限制？"><a href="#14、浏览器对同一-Host-建立-TCP-连接到数量有没有限制？" class="headerlink" title="14、浏览器对同一 Host 建立 TCP 连接到数量有没有限制？"></a>14、浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</h3><p>假设我们还处在 HTTP&#x2F;1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p><strong>有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</strong></p><p>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</p><p>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP&#x2F;1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p><h3 id="15、在浏览器中输入url地址后显示主页的过程"><a href="#15、在浏览器中输入url地址后显示主页的过程" class="headerlink" title="15、在浏览器中输入url地址后显示主页的过程?"></a>15、在浏览器中输入url地址后显示主页的过程?</h3><blockquote><ul><li>根据域名，进行DNS域名解析；</li><li>拿到解析的IP地址，建立TCP连接；</li><li>向IP地址，发送HTTP请求；</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭TCP连接；</li><li>浏览器解析HTML；</li><li>浏览器布局渲染；</li></ul></blockquote><h3 id="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"><a href="#16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？" class="headerlink" title="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"></a>16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h3><h4 id="第一种回答-1"><a href="#第一种回答-1" class="headerlink" title="第一种回答"></a>第一种回答</h4><p>1、查浏览器缓存，看看有没有已经缓存好的，如果没有</p><p> 2 、检查本机host文件，</p><p>3、调用API，Linux下Scoket函数 gethostbyname</p><p>4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议</p><p> 6、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球好像一共有13台根服务器）</p><p>7、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，</p><p>8、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，</p><p>9、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，</p><p>10、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，</p><p>11、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。</p><p>12、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页</p><h4 id="第二种回答-1"><a href="#第二种回答-1" class="headerlink" title="第二种回答"></a>第二种回答</h4><p>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns）。</p><p>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询。</p><p>gethostbyname<code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 [不同的操作系统有所不同](https://en.wikipedia.org/wiki/Hosts_(file)#Location_in_the_file_system)</code> </p><p><code>如果 </code>gethostbyname<code>没有这个域名的缓存记录，也没有在</code>hosts&#96; 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</p><p>查询本地 DNS 服务器</p><p>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</p><p>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</p><blockquote><p> 参考：<a href="https://www.zhihu.com/question/34873227/answer/518086565">https://www.zhihu.com/question/34873227/answer/518086565</a> </p></blockquote><h3 id="17、谈谈DNS解析过程，具体一点"><a href="#17、谈谈DNS解析过程，具体一点" class="headerlink" title="17、谈谈DNS解析过程，具体一点"></a>17、谈谈DNS解析过程，具体一点</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103//QQ%E6%88%AA%E5%9B%BE20210317104045.png"></p><ul><li>请求一旦发起，若是chrome浏览器，先在浏览器找之前<strong>有没有缓存过的域名所对应的ip地址</strong>，有的话，直接跳过dns解析了，若是没有，就会<strong>找硬盘的hosts文件</strong>，看看有没有，有的话，直接找到hosts文件里面的ip</li><li>如果本地的hosts文件没有能的到对应的ip地址，浏览器会发出一个<strong>dns请求到本地dns服务器</strong>，<strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</li><li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归的方式进行查询</strong>。如果没有，本地DNS服务器还要向<strong>DNS根服务器</strong>进行查询。</li><li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li><li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li></ul><h3 id="18、DNS负载均衡是什么策略？"><a href="#18、DNS负载均衡是什么策略？" class="headerlink" title="18、DNS负载均衡是什么策略？"></a>18、DNS负载均衡是什么策略？</h3><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p><h3 id="19、HTTPS和HTTP的区别"><a href="#19、HTTPS和HTTP的区别" class="headerlink" title="19、HTTPS和HTTP的区别"></a>19、HTTPS和HTTP的区别</h3><p>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><blockquote><p>参考：<a href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p></blockquote><h3 id="20、什么是SSL-x2F-TLS-？"><a href="#20、什么是SSL-x2F-TLS-？" class="headerlink" title="20、什么是SSL&#x2F;TLS ？"></a>20、什么是SSL&#x2F;TLS ？</h3><p>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p><p>SSL&#x2F;TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的</p><p> 对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的，</p><h3 id="21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"><a href="#21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）" class="headerlink" title="21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"></a>21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h3><p>（1）客户端向服务器端发起SSL连接请求；<br>（2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥<br>（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端<br>（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，<br>（5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。</p><p>因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，在通过CA的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”</p><p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><h3 id="22、如何保证公钥不被篡改？"><a href="#22、如何保证公钥不被篡改？" class="headerlink" title="22、如何保证公钥不被篡改？"></a>22、如何保证公钥不被篡改？</h3><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。<br>公钥加密计算量太大，如何减少耗用的时间？<br>每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。<br>（1） 客户端向服务器端索要并验证公钥。<br>（2） 双方协商生成”对话密钥”。<br>（3） 双方采用”对话密钥”进行加密通信。上面过程的前两步，又称为”握手阶段”（handshake）。</p><h3 id="23、HTTP请求和响应报文有哪些主要字段？"><a href="#23、HTTP请求和响应报文有哪些主要字段？" class="headerlink" title="23、HTTP请求和响应报文有哪些主要字段？"></a>23、HTTP请求和响应报文有哪些主要字段？</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>简单来说：</p><ul><li>请求行：Request Line</li><li>请求头：Request Headers</li><li>请求体：Request Body</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>简单来说：</p><ul><li>状态行：Status Line</li><li>响应头：Response Headers</li><li>响应体：Response Body</li></ul><h3 id="24、Cookie是什么？"><a href="#24、Cookie是什么？" class="headerlink" title="24、Cookie是什么？"></a>24、Cookie是什么？</h3><p>HTTP 协议是<strong>无状态</strong>的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><p>新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><p>cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。</p><p>抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name&#x3D;value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。</p><h3 id="25、Cookie有什么用途？用途"><a href="#25、Cookie有什么用途？用途" class="headerlink" title="25、Cookie有什么用途？用途"></a>25、Cookie有什么用途？用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="26、Session知识大总结"><a href="#26、Session知识大总结" class="headerlink" title="26、Session知识大总结"></a>26、Session知识大总结</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ol><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ol><blockquote><p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p></blockquote><h3 id="27、Session-的工作原理是什么？"><a href="#27、Session-的工作原理是什么？" class="headerlink" title="27、Session 的工作原理是什么？"></a>27、Session 的工作原理是什么？</h3><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h3 id="28、Cookie与Session的对比"><a href="#28、Cookie与Session的对比" class="headerlink" title="28、Cookie与Session的对比"></a>28、Cookie与Session的对比</h3><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</p><ul><li><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>Cookie是客户端保持状态的方法。</p><p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p><p>除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p></li><li><p><strong>Session</strong></p><p>Session是服务器保持状态的方法。</p><p>首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p></li></ul><p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid&#x3D;xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p><h3 id="29、SQL注入攻击了解吗？"><a href="#29、SQL注入攻击了解吗？" class="headerlink" title="29、SQL注入攻击了解吗？"></a>29、SQL注入攻击了解吗？</h3><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。<br>用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’&#x3D;’1 ，如果此时使用参数构造的方式，就会出现<br>select * from user where name &#x3D; ‘lianggzone’ and password &#x3D; ‘’ or ‘1’&#x3D;‘1’<br>不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。<br>Web端<br>1）有效性检验。<br>2）限制字符串输入的长度。<br>服务端<br>1）不用拼接SQL字符串。<br>2）使用预编译的PrepareStatement。<br>3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)<br>4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</p><h3 id="30、网络的七层模型与各自的功能（图片版）"><a href="#30、网络的七层模型与各自的功能（图片版）" class="headerlink" title="30、网络的七层模型与各自的功能（图片版）"></a>30、网络的七层模型与各自的功能（图片版）</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/1566808587546.png"></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103//1566808660890.png"></p><h3 id="31、什么是RARP？工作原理"><a href="#31、什么是RARP？工作原理" class="headerlink" title="31、什么是RARP？工作原理"></a>31、什么是RARP？工作原理</h3><p>概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。<br>原理：<br>(1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。</p><p>(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。</p><p>(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。</p><h3 id="32、端口有效范围是多少到多少？"><a href="#32、端口有效范围是多少到多少？" class="headerlink" title="32、端口有效范围是多少到多少？"></a>32、端口有效范围是多少到多少？</h3><p>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）</p><p>UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</p><h3 id="33、为何需要把-TCP-x2F-IP-协议栈分成-5-层（或7层）？开放式回答。"><a href="#33、为何需要把-TCP-x2F-IP-协议栈分成-5-层（或7层）？开放式回答。" class="headerlink" title="33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？开放式回答。"></a>33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？开放式回答。</h3><p>答：ARPANET 的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。</p><p>分层的好处：</p><p>①隔层之间是独立的</p><p>②灵活性好</p><p>③结构上可以分隔开</p><p>④易于实现和维护</p><p>⑤能促进标准化工作。</p><h3 id="34、DNS查询方式有哪些？"><a href="#34、DNS查询方式有哪些？" class="headerlink" title="34、DNS查询方式有哪些？"></a>34、DNS查询方式有哪些？</h3><h5 id="递归解析"><a href="#递归解析" class="headerlink" title="递归解析"></a>递归解析</h5><p>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。<strong>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询</strong>。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p><h5 id="迭代解析"><a href="#迭代解析" class="headerlink" title="迭代解析"></a>迭代解析</h5><p>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，<strong>而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序</strong>，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p><h3 id="35、HTTP中缓存的私有和共有字段？知道吗？"><a href="#35、HTTP中缓存的私有和共有字段？知道吗？" class="headerlink" title="35、HTTP中缓存的私有和共有字段？知道吗？"></a>35、HTTP中缓存的私有和共有字段？知道吗？</h3><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><h3 id="36、GET-方法参数写法是固定的吗？"><a href="#36、GET-方法参数写法是固定的吗？" class="headerlink" title="36、GET 方法参数写法是固定的吗？"></a>36、GET 方法参数写法是固定的吗？</h3><p>在约定中，我们的参数是写在 ? 后面，用 &amp; 分割。</p><p>我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。</p><p>比如header请求头中添加token，来验证用户是否登录等权限问题。</p><p>也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。</p><h3 id="37、GET-方法的长度限制是怎么回事？"><a href="#37、GET-方法的长度限制是怎么回事？" class="headerlink" title="37、GET 方法的长度限制是怎么回事？"></a>37、GET 方法的长度限制是怎么回事？</h3><p>网络上都会提到浏览器地址栏输入的参数是有限的。</p><p>首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</p><p>浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h3 id="38、POST-方法比-GET-方法安全？"><a href="#38、POST-方法比-GET-方法安全？" class="headerlink" title="38、POST 方法比 GET 方法安全？"></a>38、POST 方法比 GET 方法安全？</h3><p>有人说POST 比 GET 安全，因为数据在地址栏上不可见。</p><p>然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</p><p>要想安全传输，就只有加密，也就是 HTTPS。</p><h3 id="39、POST-方法会产生两个-TCP-数据包？你了解吗？"><a href="#39、POST-方法会产生两个-TCP-数据包？你了解吗？" class="headerlink" title="39、POST 方法会产生两个 TCP 数据包？你了解吗？"></a>39、POST 方法会产生两个 TCP 数据包？你了解吗？</h3><p>有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。</p><p>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。</p><p>所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</p><h3 id="40、Session是什么？"><a href="#40、Session是什么？" class="headerlink" title="40、Session是什么？"></a>40、Session是什么？</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><h3 id="41、使用-Session-的过程是怎样的？"><a href="#41、使用-Session-的过程是怎样的？" class="headerlink" title="41、使用 Session 的过程是怎样的？"></a>41、使用 Session 的过程是怎样的？</h3><p>过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p><strong>注意</strong>：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="42、Session和cookie应该如何去选择（适用场景）？"><a href="#42、Session和cookie应该如何去选择（适用场景）？" class="headerlink" title="42、Session和cookie应该如何去选择（适用场景）？"></a>42、Session和cookie应该如何去选择（适用场景）？</h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="43、Cookies和Session区别是什么？"><a href="#43、Cookies和Session区别是什么？" class="headerlink" title="43、Cookies和Session区别是什么？"></a>43、Cookies和Session区别是什么？</h3><p>Cookie和Session都是客户端与服务器之间保持状态的解决方案<br>1，存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全<br>2，存储的数据类型不同<br>两者都是key-value的结构，但针对value的类型是有差异的<br>cookie：value只能是字符串类型，session：value是Object类型<br>3，存储的数据大小限制不同<br>cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制，<br>4，生命周期的控制<br>cookie的生命周期当浏览器关闭的时候，就消亡了<br>(1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，<br>(2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁</p><h3 id="44、DDos-攻击了解吗？"><a href="#44、DDos-攻击了解吗？" class="headerlink" title="44、DDos 攻击了解吗？"></a>44、DDos 攻击了解吗？</h3><p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认<br>没有彻底根治的办法，除非不使用TCP<br>DDos 预防：<br>1）限制同时打开SYN半链接的数目<br>2）缩短SYN半链接的Time out 时间<br>3）关闭不必要的服务</p><h3 id="45、MTU和MSS分别是什么？"><a href="#45、MTU和MSS分别是什么？" class="headerlink" title="45、MTU和MSS分别是什么？"></a>45、MTU和MSS分别是什么？</h3><p>MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。</p><p>MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</p><h3 id="46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）"><a href="#46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）" class="headerlink" title="46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）"></a>46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）</h3><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><ul><li>在 HTTP&#x2F;1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP&#x2F;1.0 中，max-age 指令会被忽略掉。</li></ul><h3 id="47、TCP头部中有哪些信息？"><a href="#47、TCP头部中有哪些信息？" class="headerlink" title="47、TCP头部中有哪些信息？"></a>47、TCP头部中有哪些信息？</h3><ul><li><p>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 &#x3D; ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN &#x3D; 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。</p></li><li><p>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。</p></li><li><p>首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。</p></li><li><p>标志位（6bit）：</p><ul><li><p>URG：标志紧急指针是否有效。</p></li><li><p>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</p></li><li><p>PSH：提示接收端立即从缓冲读走数据。</p></li><li><p>RST：表示要求对方重新建立连接（复位报文段）。</p></li><li><p>SYN：表示请求建立一个连接（连接报文段）。</p></li><li><p>FIN：表示关闭连接（断开报文段）。</p></li></ul></li><li><p>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</p></li><li><p>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</p></li></ul><h3 id="48、常见TCP的连接状态有哪些？"><a href="#48、常见TCP的连接状态有哪些？" class="headerlink" title="48、常见TCP的连接状态有哪些？"></a>48、常见TCP的连接状态有哪些？</h3><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li><li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li><li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li><li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li><li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li></ul><h3 id="49、网络的七层-x2F-五层模型主要的协议有哪些？"><a href="#49、网络的七层-x2F-五层模型主要的协议有哪些？" class="headerlink" title="49、网络的七层&#x2F;五层模型主要的协议有哪些？"></a>49、网络的七层&#x2F;五层模型主要的协议有哪些？</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.5/202103/net-49-1.png"></p><h3 id="50、TCP是什么？"><a href="#50、TCP是什么？" class="headerlink" title="50、TCP是什么？"></a>50、TCP是什么？</h3><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><h3 id="51、TCP头部报文字段介绍几个？各自的功能？"><a href="#51、TCP头部报文字段介绍几个？各自的功能？" class="headerlink" title="51、TCP头部报文字段介绍几个？各自的功能？"></a>51、TCP头部报文字段介绍几个？各自的功能？</h3><p>source port 和 destination port</p><blockquote><p>两者分别为「源端口号」和「目的端口号」。源端口号就是指本地端口，目的端口就是远程端口。</p></blockquote><p>可以这么理解，我们有很多软件，每个软件都对应一个端口，假如，你想和我数据交互，咱们得互相知道你我的端口号。</p><p>再来一个很官方的：</p><blockquote><p>扩展：应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。</p></blockquote><p>Sequence Number</p><blockquote><p>称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x &#x3D; ACK_y (x 的序列号 &#x3D; y 发给 x 的 ACK)。</p></blockquote><p>说白了，类似于身份证一样，而且还得发送此时此刻的所在的位置，就相当于身份证上的地址一样。</p><p>Acknowledge Number</p><blockquote><p>称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。</p></blockquote><p>TCP Flag</p><p><code>TCP</code> 首部中有 6 个标志比特，它们中的多个可同时被设置为 <code>1</code>，主要是用于操控 <code>TCP</code> 的状态机的，依次为<code>URG，ACK，PSH，RST，SYN，FIN</code>。</p><p>当然只介绍三个：</p><ol><li><strong>ACK</strong>：这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，标识接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。</li><li><strong>SYN</strong>：表示「同步序列号」，是 TCP 握手的发送的第一个数据包。用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN&#x3D;1，ACK&#x3D;0连接被响应的时候，SYN&#x3D;1，ACK&#x3D;1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。</li><li><strong>FIN</strong>：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用FIN标识一下，接收端看到这个FIN之后，哦！这是接受的最后的数据，接受完就关闭了；<strong>TCP四次分手必然问</strong>。</li></ol><p>Window size</p><blockquote><p>称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。</p></blockquote><h3 id="52、OSI-的七层模型的主要功能？"><a href="#52、OSI-的七层模型的主要功能？" class="headerlink" title="52、OSI 的七层模型的主要功能？"></a>52、OSI 的七层模型的主要功能？</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.5/202103/net-52-1.png"></p><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层<br>网络层：将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。<br>传输层：在源端与目的端之间提供可靠的透明数据传输<br>会话层：负责在网络中的两节点之间建立、维持和终止通信<br>表示层：处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密<br>应用层：为用户的应用进程提供网络通信服务</p><h3 id="53、应用层常见协议知道多少？了解几个？"><a href="#53、应用层常见协议知道多少？了解几个？" class="headerlink" title="53、应用层常见协议知道多少？了解几个？"></a>53、应用层常见协议知道多少？了解几个？</h3><table><thead><tr><th>协议</th><th>名称</th><th>默认端口</th><th>底层协议</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td><td>80</td><td>TCP</td></tr><tr><td>HTTPS</td><td>超文本传输安全协议</td><td>443</td><td>TCP</td></tr><tr><td>Telnet</td><td>远程登录服务的标准协议</td><td>23</td><td>TCP</td></tr><tr><td>FTP</td><td>文件传输协议</td><td>20传输和21连接</td><td>TCP</td></tr><tr><td>TFTP</td><td>简单文件传输协议</td><td>21</td><td>UDP</td></tr><tr><td>SMTP</td><td>简单邮件传输协议（发送用）</td><td>25</td><td>TCP</td></tr><tr><td>POP</td><td>邮局协议（接收用）</td><td>110</td><td>TCP</td></tr><tr><td>DNS</td><td>域名解析服务</td><td>53</td><td>服务器间进行域传输的时候用TCP<br>客户端查询DNS服务器时用 UDP</td></tr></tbody></table><h3 id="54、浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？"><a href="#54、浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？" class="headerlink" title="54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？"></a>54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h3><p>在 HTTP&#x2F;1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，<strong>某些服务器对 Connection: keep-alive 的 Header 进行了支持</strong>。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。</p><p><strong>持久连接</strong>：既然维持 TCP 连接好处这么多，HTTP&#x2F;1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p><h3 id="55、三次握手相关内容"><a href="#55、三次握手相关内容" class="headerlink" title="55、三次握手相关内容"></a>55、三次握手相关内容</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.1/202103/net-55-1.png"></p><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p><h4 id="第一种回答-2"><a href="#第一种回答-2" class="headerlink" title="第一种回答"></a>第一种回答</h4><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p><ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p><p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p><p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p><p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><h4 id="第二种回答-2"><a href="#第二种回答-2" class="headerlink" title="第二种回答"></a>第二种回答</h4><ul><li><strong>初始状态</strong>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li><li><strong>第一次握手</strong>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于<code>SYN_Send</code>状态。（验证了客户端的发送能力和服务端的接收能力）</li><li><strong>第二次握手</strong>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li><li><strong>第三次握手</strong>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为<code>established</code>状态。（分别站在双方的角度上思考，各自ok）</li></ul><h3 id="56、为什么需要三次握手，两次不行吗？"><a href="#56、为什么需要三次握手，两次不行吗？" class="headerlink" title="56、为什么需要三次握手，两次不行吗？"></a>56、为什么需要三次握手，两次不行吗？</h3><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><ul><li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p>试想如果是用两次握手，则会出现下面这种情况：</p><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><h3 id="57、什么是半连接队列？"><a href="#57、什么是半连接队列？" class="headerlink" title="57、什么是半连接队列？"></a>57、什么是半连接队列？</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s……</p><h3 id="58、-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#58、-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="58、 ISN(Initial Sequence Number)是固定的吗？"></a>58、 ISN(Initial Sequence Number)是固定的吗？</h3><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p><h3 id="59、-三次握手过程中可以携带数据吗？"><a href="#59、-三次握手过程中可以携带数据吗？" class="headerlink" title="59、 三次握手过程中可以携带数据吗？"></a>59、 三次握手过程中可以携带数据吗？</h3><p>其实第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p><h3 id="60、SYN攻击是什么？"><a href="#60、SYN攻击是什么？" class="headerlink" title="60、SYN攻击是什么？"></a>60、SYN攻击是什么？</h3><p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h3 id="61、-四次挥手相关内容"><a href="#61、-四次挥手相关内容" class="headerlink" title="61、 四次挥手相关内容"></a>61、 四次挥手相关内容</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.0/202103/net-61-1.png"></p><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭</strong>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><h4 id="第一种回答-3"><a href="#第一种回答-3" class="headerlink" title="第一种回答"></a>第一种回答</h4><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。 </p><h4 id="第二种回答-3"><a href="#第二种回答-3" class="headerlink" title="第二种回答"></a>第二种回答</h4><ul><li><strong>初始化状态</strong>：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</li><li><strong>第一次分手</strong>：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。</li></ul><blockquote><p>假如客户端发送的数据已经发送完毕，发送FIN &#x3D; 1 <strong>告诉服务端，客户端所有数据已经全发完了</strong>，<strong>服务端你可以关闭接收了</strong>，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN &#x3D; 1等待服务端确认释放连接状态。</p></blockquote><ul><li><strong>第二次分手</strong>：服务端接收到客户端的释放请求连接之后，<strong>知道客户端没有数据要发给自己了</strong>，<strong>然后服务端发送ACK &#x3D; 1告诉客户端收到你发给我的信息</strong>，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</li><li><strong>第三次分手</strong>：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN &#x3D; 1，<strong>用于告诉客户端，服务端的所有数据发送完毕</strong>，<strong>客户端你也可以关闭接收数据连接了</strong>。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</li><li><strong>第四次分手</strong>：此时如果客户端收到了服务端发送完的信息之后，就发送ACK &#x3D; 1，告诉服务端，客户端已经收到了你的信息。<strong>有一个 2 MSL 的延迟等待</strong>。</li></ul><h3 id="62、挥手为什么需要四次？"><a href="#62、挥手为什么需要四次？" class="headerlink" title="62、挥手为什么需要四次？"></a>62、挥手为什么需要四次？</h3><h5 id="第一种回答-4"><a href="#第一种回答-4" class="headerlink" title="第一种回答"></a>第一种回答</h5><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h5 id="第二种回答-4"><a href="#第二种回答-4" class="headerlink" title="第二种回答"></a>第二种回答</h5><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h3 id="63、2MSL等待状态？"><a href="#63、2MSL等待状态？" class="headerlink" title="63、2MSL等待状态？"></a>63、2MSL等待状态？</h3><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p><p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><h3 id="64、四次挥手释放连接时，等待2MSL的意义"><a href="#64、四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="64、四次挥手释放连接时，等待2MSL的意义?"></a>64、四次挥手释放连接时，等待2MSL的意义?</h3><blockquote><p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><h4 id="两个理由"><a href="#两个理由" class="headerlink" title="两个理由"></a>两个理由</h4><ol><li>保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li><li>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h3 id="65、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#65、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h3><h4 id="第一种回答-5"><a href="#第一种回答-5" class="headerlink" title="第一种回答"></a>第一种回答</h4><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。</p><h4 id="第二种回答-5"><a href="#第二种回答-5" class="headerlink" title="第二种回答"></a>第二种回答</h4><p>对应这样一种情况，最后客户端发送的ACK &#x3D; 1给服务端的<strong>过程中丢失</strong>了，服务端没收到，服务端怎么认为的？我已经发送完数据了，怎么客户端没回应我？是不是中途丢失了？然后服务端再次发起断开连接的请求，一个来回就是2MSL。</p><p>客户端给服务端发送的ACK &#x3D; 1丢失，<strong>服务端等待 1MSL没收到</strong>，<strong>然后重新发送消息需要1MSL</strong>。如果再次接收到服务端的消息，则<strong>重启2MSL计时器</strong>，<strong>发送确认请求</strong>。客户端只需等待2MSL，如果没有再次收到服务端的消息，就说明服务端已经接收到自己确认消息；此时双方都关闭的连接，TCP 四次分手完毕</p><h3 id="66、TCP粘包问题是什么？你会如何去解决它？"><a href="#66、TCP粘包问题是什么？你会如何去解决它？" class="headerlink" title="66、TCP粘包问题是什么？你会如何去解决它？"></a>66、TCP粘包问题是什么？你会如何去解决它？</h3><p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><ul><li>由TCP<strong>连接复用</strong>造成的粘包问题。</li><li>因为TCP默认会使用<strong>Nagle算法</strong>，此算法会导致粘包问题。<ul><li>只有上一个分组得到确认，才会发送下一个分组；</li><li>收集多个小分组，在一个确认到来时一起发送。</li></ul></li><li><strong>数据包过大</strong>造成的粘包问题。</li><li>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</li><li><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></li></ul><p><strong>解决</strong>：</p><ol><li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法</li><li>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li><li>头部标记分步接收。在TCP报文的头部加上表示数据长度。</li><li>应用层发送数据时<strong>定长</strong>发送。</li></ol><h3 id="67、OSI七层模型中表示层和会话层功能是什么？"><a href="#67、OSI七层模型中表示层和会话层功能是什么？" class="headerlink" title="67、OSI七层模型中表示层和会话层功能是什么？"></a>67、OSI七层模型中表示层和会话层功能是什么？</h3><ul><li><p>表示层：图像、视频编码解，数据加密。</p></li><li><p>会话层：建立会话，如session认证、断点续传。</p></li></ul><h3 id="68、三次握手四次挥手的变迁图"><a href="#68、三次握手四次挥手的变迁图" class="headerlink" title="68、三次握手四次挥手的变迁图"></a>68、三次握手四次挥手的变迁图</h3><p>《TCP&#x2F;IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/QQ%E6%88%AA%E5%9B%BE20210317164731.png"></p><h3 id="69、对称密钥加密的优点缺点？"><a href="#69、对称密钥加密的优点缺点？" class="headerlink" title="69、对称密钥加密的优点缺点？"></a>69、对称密钥加密的优点缺点？</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快</li><li>缺点：无法安全地将密钥传输给通信方</li></ul><h3 id="70、非对称密钥加密你了解吗？优缺点？"><a href="#70、非对称密钥加密你了解吗？优缺点？" class="headerlink" title="70、非对称密钥加密你了解吗？优缺点？"></a>70、非对称密钥加密你了解吗？优缺点？</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><h3 id="71、HTTPS是什么"><a href="#71、HTTPS是什么" class="headerlink" title="71、HTTPS是什么"></a>71、HTTPS是什么</h3><p>HTTPS 并不是新协议，而是让 <strong>HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信</strong>。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><h3 id="72、HTTP的缺点有哪些？"><a href="#72、HTTP的缺点有哪些？" class="headerlink" title="72、HTTP的缺点有哪些？"></a>72、HTTP的缺点有哪些？</h3><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><h3 id="73、HTTPS采用的加密方式有哪些？是对称还是非对称？"><a href="#73、HTTPS采用的加密方式有哪些？是对称还是非对称？" class="headerlink" title="73、HTTPS采用的加密方式有哪些？是对称还是非对称？"></a>73、HTTPS采用的加密方式有哪些？是对称还是非对称？</h3><p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输对称密钥来保证传输过程的安全性</strong>，之后使用<strong>对称密钥加密进行通信来保证通信过程的效率</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.4/202103/net-73-1.png"></p><p>确保传输安全过程（其实就是rsa原理）：</p><ol><li>Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li><li>Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li><li>Client确认数字证书有效，然后生成呀一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。</li><li>Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。</li><li>Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li></ol><h3 id="74、为什么有的时候刷新页面不需要重新建立-SSL-连接？"><a href="#74、为什么有的时候刷新页面不需要重新建立-SSL-连接？" class="headerlink" title="74、为什么有的时候刷新页面不需要重新建立 SSL 连接？"></a>74、为什么有的时候刷新页面不需要重新建立 SSL 连接？</h3><p>TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。</p><h3 id="75、SSL中的认证中的证书是什么？了解过吗？"><a href="#75、SSL中的认证中的证书是什么？了解过吗？" class="headerlink" title="75、SSL中的认证中的证书是什么？了解过吗？"></a>75、SSL中的认证中的证书是什么？了解过吗？</h3><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><h3 id="76、HTTP如何禁用缓存？如何确认缓存？"><a href="#76、HTTP如何禁用缓存？如何确认缓存？" class="headerlink" title="76、HTTP如何禁用缓存？如何确认缓存？"></a>76、HTTP如何禁用缓存？如何确认缓存？</h3><p>HTTP&#x2F;1.1 通过 Cache-Control 首部字段来控制缓存。</p><p> <strong>禁止进行缓存</strong></p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>强制确认缓存</p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><h3 id="77、GET与POST传递数据的最大长度能够达到多少呢？"><a href="#77、GET与POST传递数据的最大长度能够达到多少呢？" class="headerlink" title="77、GET与POST传递数据的最大长度能够达到多少呢？"></a>77、GET与POST传递数据的最大长度能够达到多少呢？</h3><p>get 是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。</p><p>很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。</p><p>这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。</p><p>post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</p><p>因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。</p><p>以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。这就很明白的说明了这个问题了。</p><h3 id="78、网络层常见协议？可以说一下吗？"><a href="#78、网络层常见协议？可以说一下吗？" class="headerlink" title="78、网络层常见协议？可以说一下吗？"></a>78、网络层常见协议？可以说一下吗？</h3><table><thead><tr><th>协议</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>IP</td><td>网际协议</td><td>IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</td></tr><tr><td>ICMP</td><td>超文本传输安全协议</td><td>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</td></tr><tr><td>RIP</td><td>路由信息协议</td><td>使用“跳数”(即metric)来衡量到达目标地址的路由距离</td></tr><tr><td>IGMP</td><td>Internet组管理协议</td><td>用于实现组播、广播等通信</td></tr></tbody></table><h3 id="79、TCP四大拥塞控制算法总结？（极其重要）"><a href="#79、TCP四大拥塞控制算法总结？（极其重要）" class="headerlink" title="79、TCP四大拥塞控制算法总结？（极其重要）"></a>79、TCP四大拥塞控制算法总结？（极其重要）</h3><p><strong>四大算法</strong></p><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p><p>![](<a href="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.4/202103/net-79-1">https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.4/202103/net-79-1</a> .png)</p><h4 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h4><p> 所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p><p> 慢启动算法：</p><ol><li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li><li>每当收到一个ACK，cwnd大小加一，呈线性上升。</li><li>每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。</li><li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;&#x3D; ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li></ol><h4 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h4><p> 如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p><ol><li>收到一个ACK，则cwnd &#x3D; cwnd + 1 &#x2F; cwnd</li><li>每当过了一个往返延迟时间RTT，cwnd大小加一。</li></ol><p> 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p><h4 id="拥塞发生状态时的算法"><a href="#拥塞发生状态时的算法" class="headerlink" title="拥塞发生状态时的算法"></a>拥塞发生状态时的算法</h4><p> 一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。</p><p> 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p><p> 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫<br>做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p><p> 超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：</p><ul><li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh &#x3D; cwnd &#x2F; 2.</li><li>cwnd重置为1</li><li>进入慢启动过程</li></ul><p> 最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。</p><p> 所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：</p><ul><li>cwnd大小缩小为当前的一半</li><li>ssthresh设置为缩小后的cwnd大小</li><li>然后进入快速恢复算法Fast Recovery。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/9a5ad04b171eca84e72aeca7c25048224c79219b.png"></p><h4 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h4><p> TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：</p><ul><li><p>cwnd &#x3D; cwnd + 3 <em>MSS，加3</em> MSS的原因是因为收到3个重复的ACK。</p></li><li><p>重传DACKs指定的数据包。</p></li><li><p>如果再收到DACKs，那么cwnd大小增加一。</p></li><li><p>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@1.4/202103/net-79-3.png"></p></li></ul><p> 如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将ssthresh设置当当时cwnd的一半，也就是6&#x2F;2 &#x3D; 3，cwnd设置为3 + 3 &#x3D; 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。</p><blockquote><p>《TCP 拥塞控制算法简介》：<a href="https://yq.aliyun.com/articles/691978">https://yq.aliyun.com/articles/691978</a></p></blockquote><h3 id="80、为何快速重传是选择3次ACK？"><a href="#80、为何快速重传是选择3次ACK？" class="headerlink" title="80、为何快速重传是选择3次ACK？"></a>80、为何快速重传是选择3次ACK？</h3><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p><p>两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p><p>在没有fast retransmit &#x2F; recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因</p><p>1）包checksum 出错 </p><p>2）网络拥塞 </p><p>3）网络断，包括路由重收敛，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1&#x2F;2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</p><p>于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到&gt; 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；</p><p>而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。</p><p>而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。</p><blockquote><p>《TCP快速重传为什么是三次冗余ack，这个三次是怎么定下来的？》：<a href="https://blog.csdn.net/u010202588/article/details/54563648">https://blog.csdn.net/u010202588/article/details/54563648</a></p></blockquote><h3 id="81、对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少"><a href="#81、对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少" class="headerlink" title="81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?"></a>81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h3><ul><li><p>FIN_WAIT_2：</p><ul><li><p>半关闭状态。</p></li><li><p>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</p></li></ul></li><li><p>CLOSE_WAIT状态：</p><ul><li><p>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</p></li><li><p>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。</p></li></ul></li><li><p>TIME_WAIT状态：</p><ul><li><p>又叫2MSL等待状态。</p></li><li><p>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</p></li><li><p>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</p></li></ul></li></ul><h3 id="82、你了解流量控制原理吗？"><a href="#82、你了解流量控制原理吗？" class="headerlink" title="82、你了解流量控制原理吗？"></a>82、你了解流量控制原理吗？</h3><ul><li><p>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</p></li><li><p>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。</p><ul><li><p>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</p></li><li><p>接收窗：用来标记可以接收的数据大小。</p></li></ul></li><li><p>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 &#x3D; 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 &#x3D; 未接收但准备接收部分。</p></li><li><p>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</p></li></ul><h3 id="83、建立TCP服务器的各个系统调用过程是怎样的？"><a href="#83、建立TCP服务器的各个系统调用过程是怎样的？" class="headerlink" title="83、建立TCP服务器的各个系统调用过程是怎样的？"></a>83、建立TCP服务器的各个系统调用过程是怎样的？</h3><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/1567424004017.png"></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/1567423961699.png"></p><ul><li><p>服务器：</p><ul><li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p><ul><li><p>domain：协议域，决定了socket的地址类型，IPv4为AF_INET。</p></li><li><p>type：指定socket类型，SOCK_STREAM为TCP连接。</p></li><li><p>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</p></li></ul></li><li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><ul><li><p>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</p></li><li><p>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IPv4的sockaddr地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;    <span class="comment">// 协议类型，AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;    <span class="comment">// IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addrlen：地址长度。</li></ul></li><li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p><ul><li><p>sockfd：要监听的sock描述字。</p></li><li><p>backlog：socket可以排队的最大连接数。</p></li></ul></li><li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p><ul><li><p>sockfd：服务器socket描述字。</p></li><li><p>addr：指向地址结构指针。</p></li><li><p>addrlen：协议地址长度。</p></li><li><p>注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</p></li></ul></li><li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p><ul><li><p>fd：连接描述字。</p></li><li><p>buf：缓冲区buf。</p></li><li><p>count：缓冲区长度。</p></li><li><p>注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。</p></li></ul></li><li><p>关闭socket -&gt; int close(int fd);</p><ul><li><p>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</p></li><li><p>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</p></li></ul></li></ul></li><li><p>客户机：</p><ul><li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p></li><li><p>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);</p><ul><li><p>sockfd客户端的sock描述字。</p></li><li><p>addr：服务器的地址。</p></li><li><p>addrlen：socket地址长度。</p></li></ul></li><li><p>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);</p><ul><li><p>fd、buf、count：同read中意义。</p></li><li><p>大于0表示写了部分或全部数据，小于0表示出错。</p></li></ul></li><li><p>关闭oscket -&gt; int close(int fd);</p><ul><li>fd：同服务器端fd。</li></ul></li></ul></li></ul><h3 id="84、TCP-协议如何保证可靠传输？"><a href="#84、TCP-协议如何保证可靠传输？" class="headerlink" title="84、TCP 协议如何保证可靠传输？"></a>84、TCP 协议如何保证可靠传输？</h3><h4 id="第一种回答-6"><a href="#第一种回答-6" class="headerlink" title="第一种回答"></a>第一种回答</h4><ul><li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li><li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li><li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li><li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ul><h4 id="第二种回答-6"><a href="#第二种回答-6" class="headerlink" title="第二种回答"></a>第二种回答</h4><ul><li><p>建立连接（标志位）：通信前确认通信实体存在。</p></li><li><p>序号机制（序号、确认号）：确保了数据是按序、完整到达。</p></li><li><p>数据校验（校验和）：CRC校验全部数据。</p></li><li><p>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</p></li><li><p>窗口机制（窗口）：提供流量控制，避免过量发送。</p></li><li><p>拥塞控制：同上。</p></li></ul><h4 id="第三种回答"><a href="#第三种回答" class="headerlink" title="第三种回答"></a>第三种回答</h4><p><strong>首部校验</strong><br>这个校验机制能够确保数据传输不会出错吗？ 答案是不能。</p><p><strong>原因</strong></p><p>TCP协议中规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。</p><p>这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？<strong>显然不能</strong>。</p><p>因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B&#x3D;B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。 </p><p><strong>解决方案</strong></p><p>传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题</p><blockquote><p>《TCP新手误区–数据校验的意义》：<a href="https://blog.csdn.net/bjrxyz/article/details/75194716">https://blog.csdn.net/bjrxyz/article/details/75194716</a></p></blockquote><h3 id="85、UDP是什么"><a href="#85、UDP是什么" class="headerlink" title="85、UDP是什么"></a>85、UDP是什么</h3><p>提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</p><h3 id="86、TCP和UDP的区别"><a href="#86、TCP和UDP的区别" class="headerlink" title="86、TCP和UDP的区别"></a>86、TCP和UDP的区别</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p><p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p><p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</p><p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><p>7、UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小</p><p>TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p><blockquote><p>《TCP数据段格式+UDP数据段格式详解》：<a href="https://www.cnblogs.com/love-jelly-pig/p/8471181.html">https://www.cnblogs.com/love-jelly-pig/p/8471181.html</a></p></blockquote><h3 id="87、UDP的特点有哪些（附赠TCP的特点）？"><a href="#87、UDP的特点有哪些（附赠TCP的特点）？" class="headerlink" title="87、UDP的特点有哪些（附赠TCP的特点）？"></a>87、UDP的特点有哪些（附赠TCP的特点）？</h3><ul><li>UDP是<strong>无连接的</strong>；</li><li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP是<strong>面向报文</strong>的；</li><li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li><li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li><li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li></ul><p>那么，再说一次TCP的特点：</p><ul><li><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</li><li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ul><h3 id="88、TCP对应的应用层协议"><a href="#88、TCP对应的应用层协议" class="headerlink" title="88、TCP对应的应用层协议"></a>88、TCP对应的应用层协议</h3><p>FTP：定义了文件传输协议，使用21端口.<br>Telnet：它是一种用于远程登陆的端口,23端口<br>SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。<br>POP3：它是和SMTP对应，POP3用于接收邮件。</p><h3 id="89、UDP对应的应用层协议"><a href="#89、UDP对应的应用层协议" class="headerlink" title="89、UDP对应的应用层协议"></a>89、UDP对应的应用层协议</h3><p>DNS：用于域名解析服务，用的是53号端口<br>SNMP：简单网络管理协议，使用161号端口<br>TFTP(Trival File Transfer Protocal)：简单文件传输协议，69</p><h3 id="90、数据链路层常见协议？可以说一下吗？"><a href="#90、数据链路层常见协议？可以说一下吗？" class="headerlink" title="90、数据链路层常见协议？可以说一下吗？"></a>90、数据链路层常见协议？可以说一下吗？</h3><table><thead><tr><th>协议</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>ARP</td><td>地址解析协议</td><td>根据IP地址获取物理地址</td></tr><tr><td>RARP</td><td>反向地址转换协议</td><td>根据物理地址获取IP地址</td></tr><tr><td>PPP</td><td>点对点协议</td><td>主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</td></tr></tbody></table><blockquote><p>《OSI七层模型与TCP&#x2F;IP五层模型》：<a href="https://www.cnblogs.com/qishui/p/5428938.html">https://www.cnblogs.com/qishui/p/5428938.html</a></p></blockquote><h3 id="91、Ping命令基于哪一层协议的原理是什么？"><a href="#91、Ping命令基于哪一层协议的原理是什么？" class="headerlink" title="91、Ping命令基于哪一层协议的原理是什么？"></a>91、Ping命令基于哪一层协议的原理是什么？</h3><p>ping命令基于网络层的命令，是基于ICMP协议工作的。</p><h3 id="92、在进行UDP编程的时候，一次发送多少bytes好"><a href="#92、在进行UDP编程的时候，一次发送多少bytes好" class="headerlink" title="92、在进行UDP编程的时候，一次发送多少bytes好?"></a>92、在进行UDP编程的时候，一次发送多少bytes好?</h3><p>当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的。</p><p>我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:首先,我们知道,TCP&#x2F;IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.UDP属于运输层,</p><p>下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.</p><p>所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。</p><p>当我们发送的UDP数据大于1472的时候会怎样呢？<br>这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).<br>把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.<br>这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便<br>无法重组数据报.将导致丢弃整个UDP数据报。</p><p>因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.</p><p>进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.<br>如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机<br>制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.</p><p>鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.<br>最好将UDP的数据长度控件在548字节(576-8-20)以内</p><blockquote><p>《TCP协议中的窗口机制——滑动窗口详解》：<a href="https://blog.csdn.net/m0_37962600/article/details/79951780">https://blog.csdn.net/m0_37962600/article/details/79951780</a></p></blockquote><h3 id="93、TCP-利用滑动窗口实现流量控制的机制？"><a href="#93、TCP-利用滑动窗口实现流量控制的机制？" class="headerlink" title="93、TCP 利用滑动窗口实现流量控制的机制？"></a>93、TCP 利用滑动窗口实现流量控制的机制？</h3><blockquote><p> 流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。</p></blockquote><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。</p><blockquote><p>例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p></blockquote><h3 id="94、可以解释一下RTO，RTT和超时重传分别是什么吗？"><a href="#94、可以解释一下RTO，RTT和超时重传分别是什么吗？" class="headerlink" title="94、可以解释一下RTO，RTT和超时重传分别是什么吗？"></a>94、可以解释一下RTO，RTT和超时重传分别是什么吗？</h3><ul><li><p>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：</p><ul><li><p>发送的数据没能到达接收端，所以对方没有响应。</p></li><li><p>接收端接收到数据，但是ACK报文在返回过程中丢失。</p></li><li><p>接收端拒绝或丢弃数据。</p></li></ul></li><li><p>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。</p><ul><li><p>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</p></li><li><p>重传次数到达上限之后停止重传。</p></li></ul></li><li><p>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</p></li></ul><h3 id="95、XSS攻击是什么？（低频）"><a href="#95、XSS攻击是什么？（低频）" class="headerlink" title="95、XSS攻击是什么？（低频）"></a>95、XSS攻击是什么？（低频）</h3><p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。如何防范XSS攻击<br>1）前端，服务端，同时需要字符串输入的长度限制。<br>2）前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。<br>防 XSS 的核心是必须对输入的数据做过滤处理。</p><h3 id="96、CSRF攻击？你知道吗？"><a href="#96、CSRF攻击？你知道吗？" class="headerlink" title="96、CSRF攻击？你知道吗？"></a>96、CSRF攻击？你知道吗？</h3><p>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。</p><h3 id="97、如何防范CSRF攻击"><a href="#97、如何防范CSRF攻击" class="headerlink" title="97、如何防范CSRF攻击"></a>97、如何防范CSRF攻击</h3><p><strong>安全框架</strong>，例如Spring Security。<br><strong>token机制</strong>。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。<br><strong>验证码</strong>。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。<br><strong>referer识别</strong>。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。<br>1）验证请求来源地址；<br>2）关键操作添加验证码；<br>3）在请求地址添加 token 并验证。</p><h3 id="98、文件上传漏洞是如何发生的？你有经历过吗？"><a href="#98、文件上传漏洞是如何发生的？你有经历过吗？" class="headerlink" title="98、文件上传漏洞是如何发生的？你有经历过吗？"></a>98、文件上传漏洞是如何发生的？你有经历过吗？</h3><p>文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。<br>许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。</p><h3 id="99、如何防范文件上传漏洞"><a href="#99、如何防范文件上传漏洞" class="headerlink" title="99、如何防范文件上传漏洞"></a>99、如何防范文件上传漏洞</h3><p>文件上传的目录设置为不可执行。<br>1）判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。<br>2）对上传的文件类型进行白名单校验，只允许上传可靠类型。<br>3）上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。<br>4）限制上传文件的大小。<br>5）单独设置文件服务器的域名。</p><h3 id="100、拥塞控制原理听说过吗？"><a href="#100、拥塞控制原理听说过吗？" class="headerlink" title="100、拥塞控制原理听说过吗？"></a>100、拥塞控制原理听说过吗？</h3><ul><li><p>拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</p></li><li><p>TCP拥塞控制算法：</p><ul><li><p>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</p></li><li><p>快速重传 &amp; 快速恢复：略。</p></li><li><p>最终拥塞窗口会收敛于稳定值。</p></li></ul></li></ul><h3 id="101、如何区分流量控制和拥塞控制？"><a href="#101、如何区分流量控制和拥塞控制？" class="headerlink" title="101、如何区分流量控制和拥塞控制？"></a>101、如何区分流量控制和拥塞控制？</h3><ul><li><p>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</p></li><li><p>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</p></li><li><p>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}。</p></li></ul><h3 id="102、常见的HTTP状态码有哪些？"><a href="#102、常见的HTTP状态码有哪些？" class="headerlink" title="102、常见的HTTP状态码有哪些？"></a>102、常见的HTTP状态码有哪些？</h3><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出</td></tr></tbody></table><h4 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx 信息"></a>1xx 信息</h4><p><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p><h4 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h4><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h4 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h4><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h4 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h4><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h4 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h4><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_web</title>
      <link href="/2020/05/17/java_web/"/>
      <url>/2020/05/17/java_web/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1前言"><a href="#1-1前言" class="headerlink" title="1.1前言"></a>1.1前言</h3><p>web开发：</p><ul><li><p>静态web:</p><ul><li>html,css</li><li>数据不会变化</li></ul></li><li><p>动态web</p><ul><li>技术栈：Servlet&#x2F;JSP</li></ul></li></ul><h3 id="1-2-web应用程序"><a href="#1-2-web应用程序" class="headerlink" title="1.2 web应用程序"></a>1.2 web应用程序</h3><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="2-Tomcat"><a href="#2-Tomcat" class="headerlink" title="2.Tomcat"></a>2.Tomcat</h2><p>tomcat更改端口号和主机名</p><p><img src="/2020/05/17/java_web/image-20210610202145517.png" alt="image-20210610202145517"></p><p>为了能够访问，需要把drivers配置文件里的etc里的host文件修改127.0.0.1 ————&gt;  其他名</p><h4 id="高难度面试题"><a href="#高难度面试题" class="headerlink" title="高难度面试题"></a>高难度面试题</h4><p>网站是如何访问的！</p><ul><li><p>1.输入一个域名，回车</p></li><li><p>2.检查本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射</p><ul><li><p>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  www.qingjiang.com</span><br></pre></td></tr></table></figure></li><li><p>没有：去DNS服务器找，找到就返回，找不到就返回null</p></li></ul></li></ul><h2 id="3-Http"><a href="#3-Http" class="headerlink" title="3.Http"></a>3.Http</h2><h3 id="3-1两个时代"><a href="#3-1两个时代" class="headerlink" title="3.1两个时代"></a>3.1两个时代</h3><ul><li>http1.0<ul><li>HTTP&#x2F;1.0:客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li></ul></li><li>http2.0<ul><li>HTTP&#x2F;1.1: 客户端可以与web服务器连接后，可以获得多个web资源</li></ul></li></ul><h3 id="3-2http请求"><a href="#3-2http请求" class="headerlink" title="3.2http请求"></a>3.2http请求</h3><ul><li>客户端 – 发请求—服务器</li></ul><p>百度：</p><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h4><ul><li>请求行中的方式：get</li><li>请求方式：get,post<ul><li>get:请求能够携带的参数较少，大小有限制，会在浏览器的URL地址栏显示数据，不安全，但高效</li><li>post:没有限制，不会在URL地址栏显示数据，安全，不高效</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request URL: https:<span class="comment">//www.baidu.com/</span></span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: <span class="number">200</span> OK</span><br><span class="line">Remote Address: <span class="number">182.61</span><span class="number">.200</span><span class="number">.7</span>:<span class="number">443</span></span><br><span class="line">Referrer Policy: strict-origin-when-cross-origin</span><br></pre></td></tr></table></figure><h4 id="2-请求头"><a href="#2-请求头" class="headerlink" title="2.请求头"></a>2.请求头</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Accept: text/html <span class="comment">//告诉浏览器，它支持的数据类型</span></span><br><span class="line">Accept-Encoding: gzip, deflate, br<span class="comment">//支持哪种编码</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.9</span></span><br><span class="line">Cache-Control: max-age=<span class="number">0</span><span class="comment">//缓存控制</span></span><br><span class="line">Connection: keep-alive<span class="comment">//告诉浏览器，请求完成是断开还是保持连接</span></span><br></pre></td></tr></table></figure><h3 id="3-3-http响应"><a href="#3-3-http响应" class="headerlink" title="3.3 http响应"></a>3.3 http响应</h3><ul><li>服务器–相应—客户端</li></ul><p>百度：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">private</span><span class="comment">//缓存控制</span></span><br><span class="line">Connection: keep-alive<span class="comment">//连接</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="1-状态码"><a href="#1-状态码" class="headerlink" title="1.状态码"></a>1.状态码</h4><ul><li>200：请求成功</li><li>3xx:请求重定向</li><li>4xx:找不到资源</li><li>5xx:服务器代码错误  500   502：网关错误</li></ul><h4 id="2-常见面试题"><a href="#2-常见面试题" class="headerlink" title="2.常见面试题"></a>2.常见面试题</h4><p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p><h2 id="4-Maven"><a href="#4-Maven" class="headerlink" title="4.Maven"></a>4.Maven</h2><p><strong>为什么使用maven</strong>？</p><ol><li>在java web中要使用大量的jar包</li><li>maven可以自动导入和配置jar包</li></ol><h3 id="4-1maven架构管理工具"><a href="#4-1maven架构管理工具" class="headerlink" title="4.1maven架构管理工具"></a>4.1maven架构管理工具</h3><p>maven的核心思想：<strong>约定大于配置</strong></p><h3 id="4-2配置环境变量"><a href="#4-2配置环境变量" class="headerlink" title="4.2配置环境变量"></a>4.2配置环境变量</h3><ul><li>M2_HOME  :maven下的bin目录</li><li>MAVEN_HOME: MAVEN的目录</li><li>在系统的path中配置MAVEN_HOME： %MAVEN_HOME%\bin</li></ul><h3 id="4-3-配置镜像"><a href="#4-3-配置镜像" class="headerlink" title="4.3 配置镜像"></a>4.3 配置镜像</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-本地仓库"><a href="#4-4-本地仓库" class="headerlink" title="4.4 本地仓库"></a>4.4 本地仓库</h3><p><strong>建立一个本地仓库</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\environment\apache-maven-3.8.1\maven-repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-5-在IDEA中使用MAVEN"><a href="#4-5-在IDEA中使用MAVEN" class="headerlink" title="4.5 在IDEA中使用MAVEN"></a>4.5 在IDEA中使用MAVEN</h3><h3 id="4-6创建一个普通的Maven项目"><a href="#4-6创建一个普通的Maven项目" class="headerlink" title="4.6创建一个普通的Maven项目"></a>4.6创建一个普通的Maven项目</h3><h3 id="4-7标记文件夹功能"><a href="#4-7标记文件夹功能" class="headerlink" title="4.7标记文件夹功能"></a>4.7标记文件夹功能</h3><h3 id="4-8在IDEA中配置Tomcat"><a href="#4-8在IDEA中配置Tomcat" class="headerlink" title="4.8在IDEA中配置Tomcat"></a>4.8在IDEA中配置Tomcat</h3><p><img src="/2020/05/17/java_web/image-20210610225048745.png" alt="image-20210610225048745"></p><p>解决警告问题</p><p><strong>为什么会有这个问题：我们访问一个网站，需要指定一个文件夹的而名字。</strong></p><p><img src="/2020/05/17/java_web/image-20210610225227107.png" alt="image-20210610225227107"></p><p><img src="/2020/05/17/java_web/image-20210610225618734.png" alt="image-20210610225618734"></p><p><img src="/2020/05/17/java_web/image-20210610225951759.png" alt="image-20210610225951759"></p><p>maven由于他的约定大于配置，之后可能遇到写的配置文件，无法被导出或生效的问题。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  在build中配置resource,来防止我们资源导出失败的问题  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-9-IDEA操作"><a href="#4-9-IDEA操作" class="headerlink" title="4.9 IDEA操作"></a>4.9 IDEA操作</h3><p><img src="/2020/05/17/java_web/image-20210611104654694.png" alt="image-20210611104654694"></p><h3 id="4-10-解决问道的问题"><a href="#4-10-解决问道的问题" class="headerlink" title="4.10 解决问道的问题"></a>4.10 解决问道的问题</h3><ol><li><p>maven3.6.2无法导入的问题</p><p>解决方法：降低版本至3.6.1</p></li><li><p>tomcat闪退</p></li><li><p>IDEA中重复配置maven</p><p>在IDEA中的全局默认配置中去配置</p><p><img src="/2020/05/17/java_web/image-20210611105413061.png" alt="image-20210611105413061"></p></li><li><p>maven默认web项目中的web.xml版本问题</p><p><img src="/2020/05/17/java_web/image-20210611105822457.png" alt="image-20210611105822457"></p></li><li><p>替换为webapp4.0版本和tomcat一致</p></li></ol><p><img src="/2020/05/17/java_web/image-20210611110059067.png" alt="image-20210611110059067"></p><h2 id="5-Servlet"><a href="#5-Servlet" class="headerlink" title="5.Servlet"></a>5.Servlet</h2><h3 id="5-1-hello-servlet"><a href="#5-1-hello-servlet" class="headerlink" title="5.1 hello servlet"></a>5.1 hello servlet</h3><p>​利用tomcat例子，查看servlet源码怎么写。</p><p><img src="/2020/05/17/java_web/image-20210611111244776.png" alt="image-20210611111244776"></p><p><img src="/2020/05/17/java_web/image-20210611111310122.png" alt="image-20210611111310122"></p><p><img src="/2020/05/17/java_web/image-20210611111322155.png" alt="image-20210611111322155"></p><h3 id="5-2-maven仓库中查找servlet"><a href="#5-2-maven仓库中查找servlet" class="headerlink" title="5.2 maven仓库中查找servlet"></a>5.2 maven仓库中查找servlet</h3><p><strong>要写一个serlvet要继承HttpServlet类</strong></p><p>在IDEA中编写，发现本地仓库没有这个jar包，去maven仓库找。</p><p><img src="/2020/05/17/java_web/image-20210611111557277.png" alt="image-20210611111557277"></p><p><img src="/2020/05/17/java_web/image-20210611111615091.png" alt="image-20210611111615091"></p><p><img src="/2020/05/17/java_web/image-20210611111721081.png" alt="image-20210611111721081"></p><p>在maven仓库中找到的httpServlet都不是，回过头去查看tomcat例子中导入的jar包，是javax.io.servlet。发现也没找到，而tomcat作为服务器能启动，应该有该jar包作为支持，所以去tomcat的lib目录下找，与servlet相关的jar包。</p><p><img src="/2020/05/17/java_web/image-20210611111944047.png" alt="image-20210611111944047"></p><p>找到了相关的一个去maven仓库中查找。</p><p><img src="/2020/05/17/java_web/image-20210611112102064.png" alt="image-20210611112102064"></p><p>上图，找用的人最多的，且查看所在的文件加目录为  <strong>javax.servlet-api</strong>，确定就是他。</p><p><img src="/2020/05/17/java_web/image-20210611112238992.png" alt="image-20210611112238992"></p><p>点进去后，找到使用人数最多的。</p><p><img src="/2020/05/17/java_web/image-20210611112345100.png" alt="image-20210611112345100"></p><p>根据上图可以决定下载jar包，还是导入maven依赖</p><h3 id="5-3-从java-ee工程自动生成servlet查看导入了什么包"><a href="#5-3-从java-ee工程自动生成servlet查看导入了什么包" class="headerlink" title="5.3 从java ee工程自动生成servlet查看导入了什么包"></a>5.3 从java ee工程自动生成servlet查看导入了什么包</h3><p><img src="/2020/05/17/java_web/image-20210611113021937.png" alt="image-20210611113021937"></p><p><img src="/2020/05/17/java_web/image-20210611113335995.png" alt="image-20210611113335995"></p><p><img src="/2020/05/17/java_web/image-20210611113544354.png" alt="image-20210611113544354"></p><h2 id="6-Servlet开始"><a href="#6-Servlet开始" class="headerlink" title="6.Servlet开始"></a>6.Servlet开始</h2><h3 id="6-1Servlet简介"><a href="#6-1Servlet简介" class="headerlink" title="6.1Servlet简介"></a>6.1Servlet简介</h3><ul><li>Servlet就是sun公司开发动态web的一门技术</li><li>Sun在这些API中提供了一个接口叫做：Servlet,如果你想开发一个Servlet程序，只需要万册灰姑娘两个小步骤：<ul><li>编写一个类，实现Servlet接口</li><li>把开发号的java类部署到web服务器中</li></ul></li></ul><p><strong>把实现了Servlet接口的java程序叫做：Servlet</strong></p><h3 id="6-2-HelloServlet"><a href="#6-2-HelloServlet" class="headerlink" title="6.2 HelloServlet"></a>6.2 HelloServlet</h3><p>Servlet接口Sun公司有两个默认实现类：HttpServlet,GenericServlet</p><ol><li><p>构建一个普通的Maven项目，删掉里面的src目录，以后再这里建立Moudel;这个空工程就是Maven主工程</p></li><li><p>关于Maven父子工程的理解</p><p>父项目中会有</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>servlet-01<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子项目中有</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaweb-02-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.neu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父项目中的jar子项目中可以使用</p></li><li><p>Maven环境优化</p><ol><li>修改web.xml为最新的</li><li>将maven的结构搭建完整</li></ol></li><li><p>编写servlet</p><ol><li>编写一个普通类</li><li>实现Servlet接口，这里我们直接继承HttpServlet</li></ol><p><img src="/2020/05/17/java_web/image-20210611162555531.png" alt="image-20210611162555531"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">//由于get或post只是请求实现的不同方式，可以相互调用，业务逻辑都一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        ServletOutputStream outputStream = resp.getOutputStream();</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.print(<span class="string">&quot;hello,servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Servlet的映射</p><p>为什么需要映射：我们写的是java程序，但是需要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet.</p><p>还需要给他一个浏览器能够访问的路径。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.neu.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置tomcat</p><p>注意配置tomcat访问的路径</p></li><li><p>启动测试</p></li></ol><h3 id="6-3-servlet运行原理"><a href="#6-3-servlet运行原理" class="headerlink" title="6.3 servlet运行原理"></a>6.3 servlet运行原理</h3><p>servlet是由web服务器调用，web服务器收到浏览器请求之后，会：</p><p><img src="/2020/05/17/java_web/image-20210611170232903.png" alt="image-20210611170232903"></p><p>流程解释：</p><ol><li><p>浏览器向web容器（tomcat）发起http请求；</p></li><li><p>如果请求是第一次访问，web容器会产生servlet  class，之后访问就是调用</p></li><li><p>web容器产生两个对象：request（请求头，请求体）、response（响应头，响应体）。对应Java中的Request,Reponse对象</p></li><li><p>web容器调用Servlet,servlet中有一个service方法，同时把request,reponse对象传给service方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service(ServletRequest req,ServletReponse res);</span><br></pre></td></tr></table></figure></li><li><p>service方法调用完会返回，web容器读取响应信息，web容器拿到相应信息之后返回给客户端</p></li><li><p>我们自己的实现类，重写了这些方法：</p><ol><li>接收并处理请求</li><li>给出响应的信息</li></ol></li></ol><h3 id="6-4-mapping问题"><a href="#6-4-mapping问题" class="headerlink" title="6.4 mapping问题"></a>6.4 mapping问题</h3><ol><li><p>一个servlet可以指定一个映射路径</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>一个servlet可以指定多个映射路径</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>一个servlet可以指定通用映射路径</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  //hello下的任何请求都会进入hello  servlet</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认请求路径</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>指定一些前缀或后缀</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以自定义后缀实现请求映射</span></span><br><span class="line"><span class="comment">注意点：*前面不能加项目映射的路径 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.qing<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优先级问题</p><p>制定了固有的映射路径优先级最高，找不到去找默认的处理请求</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.neu.ErrorServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 404路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="6-5-ServletContext"><a href="#6-5-ServletContext" class="headerlink" title="6.5  ServletContext"></a>6.5  ServletContext</h3><p>web容器在启动的时候，他会为每个web程序都会创建一个对应的ServletContext对象，他代表了当前的web应用；</p><h4 id="1-共享数据"><a href="#1-共享数据" class="headerlink" title="1. 共享数据"></a>1. 共享数据</h4><p>在这个Servlet中保存的数据，在另一个Servlet中共享</p><p><img src="/2020/05/17/java_web/image-20210611215621523.png" alt="image-20210611215621523"></p><p>放置数据的类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        this.getInitParameter();  //初始化参数</span></span><br><span class="line"><span class="comment">//        this.getServletConfig();    //servelt配置</span></span><br><span class="line"><span class="comment">//        this.getServletContext();   //上下文</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;秦将&quot;</span>; <span class="comment">//数据</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;username&quot;</span>,username);;<span class="comment">//将一个数据保存在了ServletContext中，名字：username,值：username</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取数据的类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) context.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">&quot;名字&quot;</span>+username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml中配置注册和映射</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.neu.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.neu.GetServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/getc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-获取初始化参数"><a href="#2-获取初始化参数" class="headerlink" title="2. 获取初始化参数"></a>2. 获取初始化参数</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一些web应用初始化参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        resp.getWriter().print(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-请求转发"><a href="#3-请求转发" class="headerlink" title="3.请求转发"></a>3.请求转发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">    <span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> servletContext.getRequestDispatcher(<span class="string">&quot;/gp&quot;</span>);<span class="comment">//转发到具体地址</span></span><br><span class="line">    requestDispatcher.forward(req,resp);<span class="comment">//实现请求转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-读取资源文件"><a href="#4-读取资源文件" class="headerlink" title="4.读取资源文件"></a>4.读取资源文件</h4><p>Properties类：</p><ul><li>在Java目录下新建properties</li><li>在resources目录下新建properties</li></ul><p>发现：都被打包到了同一个路径下：classes,我们俗称这个路径为类路径：classespath</p><p>思路：需要一个文件流</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext().getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(is);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    resp.getWriter().print(username+<span class="string">&quot;:&quot;</span>+password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-HttpServletResponse"><a href="#6-6-HttpServletResponse" class="headerlink" title="6.6 HttpServletResponse"></a>6.6 HttpServletResponse</h3><p>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的HttpServletResponse对象。</p><ul><li>如果要获取客户端请求火来的参数：找HttpServletRequest</li><li>如果要给客户端响应一些信息：找HttpServletResponse</li></ul><h4 id="1-简单分类"><a href="#1-简单分类" class="headerlink" title="1.简单分类"></a>1.简单分类</h4><p><strong>负责向浏览器发送数据的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException;<span class="comment">//写中文用</span></span><br></pre></td></tr></table></figure><p><strong>负责向浏览器发送响应头的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这四个是ServletResponse接口的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharacterEncoding</span><span class="params">(String charset)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentLength</span><span class="params">(<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentLengthLong</span><span class="params">(<span class="type">long</span> len)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentLengthLong</span><span class="params">(<span class="type">long</span> len)</span>;</span><br><span class="line"><span class="comment">//这些是HttpServletResponse接口的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDateHeader</span><span class="params">(String name, <span class="type">long</span> date)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDateHeader</span><span class="params">(String name, <span class="type">long</span> date)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(String name, String value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHeader</span><span class="params">(String name, String value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntHeader</span><span class="params">(String name, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addIntHeader</span><span class="params">(String name, <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><p><strong>响应的状态码常量</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_CONTINUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_SWITCHING_PROTOCOLS</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_OK</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_CREATED</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_ACCEPTED</span> <span class="operator">=</span> <span class="number">202</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_NON_AUTHORITATIVE_INFORMATION</span> <span class="operator">=</span> <span class="number">203</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_NO_CONTENT</span> <span class="operator">=</span> <span class="number">204</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_RESET_CONTENT</span> <span class="operator">=</span> <span class="number">205</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_PARTIAL_CONTENT</span> <span class="operator">=</span> <span class="number">206</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_MULTIPLE_CHOICES</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_MOVED_PERMANENTLY</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_MOVED_TEMPORARILY</span> <span class="operator">=</span> <span class="number">302</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_FOUND</span> <span class="operator">=</span> <span class="number">302</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_SEE_OTHER</span> <span class="operator">=</span> <span class="number">303</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_NOT_MODIFIED</span> <span class="operator">=</span> <span class="number">304</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_USE_PROXY</span> <span class="operator">=</span> <span class="number">305</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_TEMPORARY_REDIRECT</span> <span class="operator">=</span> <span class="number">307</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_BAD_REQUEST</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_UNAUTHORIZED</span> <span class="operator">=</span> <span class="number">401</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_PAYMENT_REQUIRED</span> <span class="operator">=</span> <span class="number">402</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_FORBIDDEN</span> <span class="operator">=</span> <span class="number">403</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_NOT_FOUND</span> <span class="operator">=</span> <span class="number">404</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_METHOD_NOT_ALLOWED</span> <span class="operator">=</span> <span class="number">405</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_NOT_ACCEPTABLE</span> <span class="operator">=</span> <span class="number">406</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_PROXY_AUTHENTICATION_REQUIRED</span> <span class="operator">=</span> <span class="number">407</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_REQUEST_TIMEOUT</span> <span class="operator">=</span> <span class="number">408</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_CONFLICT</span> <span class="operator">=</span> <span class="number">409</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_GONE</span> <span class="operator">=</span> <span class="number">410</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_LENGTH_REQUIRED</span> <span class="operator">=</span> <span class="number">411</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_PRECONDITION_FAILED</span> <span class="operator">=</span> <span class="number">412</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_REQUEST_ENTITY_TOO_LARGE</span> <span class="operator">=</span> <span class="number">413</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_REQUEST_URI_TOO_LONG</span> <span class="operator">=</span> <span class="number">414</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_UNSUPPORTED_MEDIA_TYPE</span> <span class="operator">=</span> <span class="number">415</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_REQUESTED_RANGE_NOT_SATISFIABLE</span> <span class="operator">=</span> <span class="number">416</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_EXPECTATION_FAILED</span> <span class="operator">=</span> <span class="number">417</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_INTERNAL_SERVER_ERROR</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_NOT_IMPLEMENTED</span> <span class="operator">=</span> <span class="number">501</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_BAD_GATEWAY</span> <span class="operator">=</span> <span class="number">502</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_SERVICE_UNAVAILABLE</span> <span class="operator">=</span> <span class="number">503</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_GATEWAY_TIMEOUT</span> <span class="operator">=</span> <span class="number">504</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_HTTP_VERSION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">505</span>;</span><br></pre></td></tr></table></figure><h4 id="2-常见应用"><a href="#2-常见应用" class="headerlink" title="2.常见应用"></a>2.常见应用</h4><ol><li><p>向浏览器输出消息</p></li><li><p>下载文件</p><ol><li>要获取下载文件的路径</li><li>下载的文件名是啥</li><li>想办法让浏览器支持下载我们需要的东西</li><li>获取下载文件的输入流</li><li>创建缓冲区</li><li>获取OutputStream对象</li><li>将FileOutputStream流写入到buffer缓冲区</li><li>使用OutputStream将缓冲区中的数据输出到客户端</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//1. 要获取下载文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> <span class="string">&quot;F:\\java-work\\maven_web\\javaweb-02-servlet\\response\\src\\main\\resources\\image.png&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;下载文件的路径：&quot;</span>+realPath);</span><br><span class="line">    <span class="comment">//2. 下载的文件名是啥</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//3. 想办法让浏览器支持下载我们需要的东西;中文文件名用URLEncoder.encode(fileName,&quot;UTF-8&quot;)解决乱码</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+ URLEncoder.encode(fileName,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    <span class="comment">//4. 获取下载文件的输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">//5. 创建缓冲区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//6. 获取OutputStream对象</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">    <span class="comment">//7. 将FileOutputStream流写入到buffer缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> ((in.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8. 使用OutputStream将缓冲区中的数据输出到客户端</span></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-验证码功能"><a href="#3-验证码功能" class="headerlink" title="3.验证码功能"></a>3.验证码功能</h4><p>验证怎么来的？</p><ul><li>前端实现</li><li>后端实现，需要用到java的图片实现类，生成一个图片</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//如何让浏览器3秒刷新一次</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;3&quot;</span>);;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在内存中创建一个图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(<span class="number">80</span>, <span class="number">20</span>, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    <span class="comment">//得到图片</span></span><br><span class="line">    <span class="type">Graphics2D</span> <span class="variable">graphics</span> <span class="operator">=</span> (Graphics2D) image.getGraphics();<span class="comment">//笔</span></span><br><span class="line">    <span class="comment">//是指图片的背景颜色</span></span><br><span class="line">    graphics.setColor(Color.white);</span><br><span class="line">    graphics.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">80</span>,<span class="number">20</span>);<span class="comment">//填充颜色区域</span></span><br><span class="line">    <span class="comment">//给图片些数据</span></span><br><span class="line">    graphics.setColor(Color.blue);<span class="comment">//画笔颜色</span></span><br><span class="line">    graphics.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="literal">null</span>,Font.BOLD,<span class="number">20</span>));</span><br><span class="line">    graphics.drawString(makeNum(),<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉浏览器，这个请求用图片的方式打开</span></span><br><span class="line">    resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="comment">//网站存在缓存，设置不让浏览器缓存</span></span><br><span class="line">    resp.setDateHeader(<span class="string">&quot;expires&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把图片写给浏览器</span></span><br><span class="line">    ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, resp.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">makeNum</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">9999999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">7</span> - num.length();i++)&#123;</span><br><span class="line">        sb.append(<span class="string">&quot;0&quot;</span>);     <span class="comment">//随机生成的位数最大为7位，其他用0填充</span></span><br><span class="line">    &#125;</span><br><span class="line">    num = sb.toString() + num;   <span class="comment">//随机生成的位数最大为7位，其他用0填充</span></span><br><span class="line">    <span class="keyword">return</span> num;     <span class="comment">//保证必须是7位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4.重定向"></a>4.重定向</h4><p>一个web资源收到客户端请求，他会通知客户端去访问两一个web资源，这个过程叫做重定向。</p><p>常见场景：</p><ul><li>用户登录</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原理：</span></span><br><span class="line"><span class="comment">    resp.setHeader(&quot;Location&quot;,&quot;/response/image&quot;);</span></span><br><span class="line"><span class="comment">    resp.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);//302</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;/response/image&quot;</span>);<span class="comment">//重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重定向和转发的区别</strong></p><p>相同点：</p><ul><li>页面都会跳转</li></ul><p>不同点：</p><ul><li>请求转发的时候，url不会产生变化  307</li><li>重定向的时候，Url会变化  302</li></ul><h3 id="6-7-HttpServletRequest"><a href="#6-7-HttpServletRequest" class="headerlink" title="6.7 HttpServletRequest"></a>6.7 HttpServletRequest</h3><p> HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到 HttpServletRequest，通过这个 HttpServletRequest的方法，可以获取到客户端的所有信息。</p><p><img src="/2020/05/17/java_web/image-20210612163954404.png" alt="image-20210612163954404"></p><h4 id="1-获取前端传递的参数"><a href="#1-获取前端传递的参数" class="headerlink" title="1.获取前端传递的参数"></a>1.获取前端传递的参数</h4><p><img src="/2020/05/17/java_web/image-20210612164045458.png" alt="image-20210612164045458"></p><h4 id="2-请求转发"><a href="#2-请求转发" class="headerlink" title="2.请求转发"></a>2.请求转发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//后台接收中文乱码问题</span></span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String[] hobbys = req.getParameterValues(<span class="string">&quot;hobbys&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(username );</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    System.out.println(Arrays.toString(hobbys));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过请求转发</span></span><br><span class="line">    resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//请求转发不需要写项目路径，相对就可以。</span></span><br><span class="line">    req.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Cookie-Session"><a href="#7-Cookie-Session" class="headerlink" title="7.Cookie,Session"></a>7.Cookie,Session</h2><h3 id="7-1会话"><a href="#7-1会话" class="headerlink" title="7.1会话"></a>7.1会话</h3><p><strong>会话</strong>：用户打开了一个浏览器，点击了很多超链接，访问了多个web资源，关闭浏览器，这个过程可以称为会话</p><p><strong>有状态会话</strong>：</p><h3 id="7-2保存会话的两种技术"><a href="#7-2保存会话的两种技术" class="headerlink" title="7.2保存会话的两种技术"></a>7.2保存会话的两种技术</h3><p><strong>cookie</strong></p><ul><li>客户端技术（响应，请求）</li></ul><p><strong>session</strong></p><ul><li>服务器技术，利用这个技术，可以保存用户的会话信息。可以把信息保存在session种</li></ul><p>常见场景：网站登录之后，下次就不用再登录了</p><h3 id="7-3-Cookie"><a href="#7-3-Cookie" class="headerlink" title="7.3 Cookie"></a>7.3 Cookie</h3><ol><li>从请求中获取Cookie信息</li><li>服务器响应给客户端cookie</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cookie,服务器端从客户端获取</span></span><br><span class="line">Cookie[] cookies = req.getCookies();<span class="comment">//这里返回数组，说明Cookie可能有多个</span></span><br><span class="line">cookie.getName();<span class="comment">//获得cookie中的key</span></span><br><span class="line">cookie.getValue()<span class="comment">//获得cookie中的value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器给客户端响应一个Cookie</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;lastLoginTime&quot;</span>, System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//cookie有效期为一天</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">resp.addCookie(cookie);<span class="comment">//响应给客户端一个cookie</span></span><br></pre></td></tr></table></figure><p><strong>cookie一般保存再本地的用户目录下appdata</strong></p><ul><li>一个Cookie只能保存一个信息</li><li>一个web站点可以给浏览器发送多个cookie,最多存放20个cookie</li><li>cookie大小有限制4kb</li><li>300个cookie浏览器上线</li></ul><p><strong>删除cookie</strong>:</p><ul><li>不设置有效期，关闭浏览器，自动失效</li><li>设置有效期为0</li></ul><p><strong>编码解码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLEncoder.encode(<span class="string">&quot;实验室&quot;</span>,<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//编码</span></span><br><span class="line">URLDecoder.decode(cookie.getValue(),<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//解码</span></span><br></pre></td></tr></table></figure><h3 id="7-4-Session-重点"><a href="#7-4-Session-重点" class="headerlink" title="7.4 Session(重点)"></a>7.4 Session(重点)</h3><p>什么是session:</p><ul><li>服务器会给每一个用户（浏览器）创建一个Session对象；</li><li>一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在</li><li>用户登录之后，整个网站他都可以访问。—&gt;保存用户的信息；保存购物车的信息….</li></ul><p>Session跟Cookie的区别：</p><ul><li>Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）</li><li>Session把用户的数据写到用户独占的Session中，服务器端保存（保存重要的信息，减少服务器资源浪费）</li><li>Session对象由服务器创建</li></ul><p>使用场景：</p><ul><li>保存一个登录用户的信息</li><li>购物车信息</li><li>在整个网站中，经常会使用的数据，将他保存咋Session中</li></ul><p>使用Session:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//得到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给Session中存东西</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;关晓彤&quot;</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> session.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断Session是不是新创建的</span></span><br><span class="line">        <span class="keyword">if</span>(session.isNew())&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session创建成功，ID:&quot;</span>+id);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session已经在服务器中了，ID:&quot;</span>+id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//session创建的时候做了什么事情：</span></span><br><span class="line"><span class="comment">//        Cookie co = new Cookie(&quot;JSESSIONID&quot;, id);</span></span><br><span class="line"><span class="comment">//        resp.addCookie(co);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">name</span> <span class="operator">=</span> (Person) session.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//手动注销session</span></span><br><span class="line">        session.invalidate();</span><br></pre></td></tr></table></figure><p>会话自动过期：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  设置session默认的失效时间--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--    1分钟后session自动失效，以分钟为单位--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-JSP"><a href="#8-JSP" class="headerlink" title="8. JSP"></a>8. JSP</h2><h3 id="8-1什么是JSP"><a href="#8-1什么是JSP" class="headerlink" title="8.1什么是JSP"></a>8.1什么是JSP</h3><p>java Server Pages: Java 服务器端页面，也和Servlet一样，用于动态web技术</p><p>最大的特点：</p><ul><li>JSP就像HTML</li><li>区别：<ul><li>HTML只给用户提供静态数据</li><li>JSP页面可以嵌入JAVA代码，为用户提供动态数据</li></ul></li></ul><h3 id="8-2-JSP原理"><a href="#8-2-JSP原理" class="headerlink" title="8.2 JSP原理"></a>8.2 JSP原理</h3><p><strong>JSP是怎么执行的</strong></p><ul><li><p>服务器内部工作</p><ul><li><p>tomcat中有一个work目录</p></li><li><p>IDEA中使用Tomcat的会在IDEA的tomcat生成一个work目录</p><p><img src="/2020/05/17/java_web/image-20210613212821408.png" alt="image-20210613212821408"></p><p><img src="/2020/05/17/java_web/image-20210613212911207.png" alt="image-20210613212911207"></p></li></ul></li></ul><p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet</strong></p><p>JSP最终会被转换为一个Java类</p><p>JSP本质上就是一个Servlet</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspInit</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//JSPService</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(http.HttpServletRequest request, http.HttpServletResponse response)</span><span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException &#123;</span><br></pre></td></tr></table></figure><ol><li><p>判断请求</p></li><li><p>内置对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;<span class="comment">//页面上下文</span></span><br><span class="line">   javax.servlet.http.<span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//session</span></span><br><span class="line">   <span class="keyword">final</span> javax.servlet.ServletContext application;<span class="comment">//applicationContext</span></span><br><span class="line">   <span class="keyword">final</span> javax.servlet.ServletConfig config;<span class="comment">//congig</span></span><br><span class="line">   javax.servlet.jsp.<span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//out</span></span><br><span class="line">   <span class="keyword">final</span> java.lang.<span class="type">Object</span> <span class="variable">page</span> <span class="operator">=</span> <span class="built_in">this</span>;<span class="comment">//page:当前</span></span><br><span class="line">HttpServletRequest request;<span class="comment">//请求</span></span><br><span class="line">HttpServletResponse response;<span class="comment">//响应</span></span><br></pre></td></tr></table></figure></li><li><p>输出前增加的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);<span class="comment">//设置响应的页面类型</span></span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="built_in">this</span>, request, response,<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">8192</span>, <span class="literal">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure></li><li><p>以上的这些个对象在jsp页面直接使用</p><p><img src="/2020/05/17/java_web/image-20210613215215521.png" alt="image-20210613215215521"></p><p>在JSP页面中：</p><p>只要是JAVA代码，就会原封不动的输出；</p><p>如果是HTML代码，就会被转换为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.write(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样的格式，返回到前端。</p></li></ol><h3 id="8-3-JSP基础语法"><a href="#8-3-JSP基础语法" class="headerlink" title="8.3 JSP基础语法"></a>8.3 JSP基础语法</h3><p>任何语言都有自己的语法，JAVA中有，JSP作为Java技术的一种应用，它拥有一些自己扩充的语法（了解即可），Java的所有语法都支持。</p><p><strong>JSP表达式</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--  JSP表达式</span><br><span class="line"> 作用：用来将程序的输出，输出到客户端</span><br><span class="line"> &lt;%= 变量或表达式%&gt;</span><br><span class="line"> --%&gt;</span><br><span class="line">&lt;%= <span class="keyword">new</span> <span class="title class_">java</span>.util.Date()  %&gt;</span><br></pre></td></tr></table></figure><p><strong>JSP脚本片段</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--  jsp脚本片段 --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">  &#125;</span><br><span class="line">  out.println(<span class="string">&quot;&lt;h1&gt;SUM=&quot;</span>+sum+<span class="string">&quot;&lt;h1/&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>脚本片段的再实现</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%-- 在代码中嵌入HTML元素 --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">%&gt;</span><br><span class="line">  &lt;h1&gt;Hello,World  &lt;%=i%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><strong>JSP声明</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Loading Servlet&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">globalVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入了TEST方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>JSP声明会被编译到JSP生成的JAVA类的类中，其他的两个会被生成到service方法中</p><p>在JSP中嵌入JAVA代码即可。</p><p>JSP的注释不会在客户端中显示，HTML的就会</p><h3 id="8-4-JSP指令"><a href="#8-4-JSP指令" class="headerlink" title="8.4 JSP指令"></a>8.4 JSP指令</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
