<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>alogrithm</title>
      <link href="/2022/05/17/alogrithm/alogrithm/"/>
      <url>/2022/05/17/alogrithm/alogrithm/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>思路</p></blockquote><p>快速排序的主要思想：通过划分将待排序的数组分成两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的数组序列分别进行快速排序。</p><ol><li>选择主元</li><li>维护两个指针  <strong>&#x3D;&#x3D;i  ,  j&#x3D;&#x3D;</strong> ,指针  <strong>j</strong>  从  <strong>l</strong>  至  <strong>r</strong>  遍历，指针  <strong>i</strong>  维护比主元小的数；<ol><li>初始  <strong>i &#x3D; l-1 ,  j &#x3D; l</strong>  ,</li><li>当 **arr[j] &lt;&#x3D; pivot  <strong>时，说明当前遍历到的这个数应该在右边部分，所以，将</strong>arr[j]  <strong>与</strong>arr[i + 1]  <strong>交换，之后</strong>i + + **，使指针  <strong>i</strong>   维护的是比  <strong>pivot</strong>  小的最靠右的数。</li></ol></li><li>递归遍历  <strong>pivot</strong> 左边的</li><li>递归遍历  <strong>pivot</strong> 右边的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        randomQuickSort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomQuickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> randomPartition(nums,l,r);<span class="comment">//快排，返回主元的位置</span></span><br><span class="line">            randomQuickSort(nums,l,pos-<span class="number">1</span>);<span class="comment">//左递归</span></span><br><span class="line">            randomQuickSort(nums,pos+<span class="number">1</span>,r);<span class="comment">//右递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(r - l + <span class="number">1</span>) + l;<span class="comment">//随机选择主元</span></span><br><span class="line">        swap(nums,r,i);<span class="comment">//把主元移到数组末尾</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums,l,r);<span class="comment">//开始交换排序(返回主元最后的位置)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[r];<span class="comment">//主元的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>;<span class="comment">//比主元小的数最右边的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= r - <span class="number">1</span>;j++)&#123;<span class="comment">//j遍历所有数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;<span class="comment">//当前值比主元小，应该将其移动到左边去</span></span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums,i,j);<span class="comment">//移动交换（此时i+1的位置是比主元大的数）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,i+<span class="number">1</span>,r);<span class="comment">//最后将主元放到“中间”位置上</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//返回主元所在位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路</p></blockquote><p>归并排序利用了分治的思想来对序列进行排序。对于一个长度为 <strong>n</strong> 的序列，将其分解为两个长度为<strong>n&#x2F;2</strong>   的子序列，然后再递归分解子序列，直至不能再分，然后线性合并两个有序的子序列。</p><ol><li>划分左右子序列  <strong>[ l , mid]   [mid + 1，r ]</strong></li><li>左递归 <strong>[ l , mid]</strong></li><li>右递归 <strong>[mid + 1，r ]</strong></li><li>线性合并<ol><li>维护两个指针<strong>i，j</strong>，<strong>i</strong>遍历左&#x3D;&#x3D;有序&#x3D;&#x3D;子序列，<strong>j</strong>  遍历右&#x3D;&#x3D;有序&#x3D;&#x3D;子序列，维护临时数组<strong>temp</strong></li><li>如果 <strong>nums[ i ]  &lt;&#x3D;  nums[ j ]</strong>  ，&#x3D;&#x3D;temp[cnt++] &#x3D; nums[ i ]&#x3D;&#x3D;</li><li>否则：&#x3D;&#x3D;temp[cnt++] &#x3D; nums[ j ]&#x3D;&#x3D;</li><li>如果左&#x2F;右子序列有剩余元素，将剩余元素都追加给temp</li><li>左右子序列都遍历完，将&#x3D;&#x3D;temp&#x3D;&#x3D;赋值给&#x3D;&#x3D;nums&#x3D;&#x3D;</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] temp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//取中点为分界</span></span><br><span class="line">        mergeSort(nums,l,mid);<span class="comment">//左递归</span></span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);<span class="comment">//右递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归结束后，开始线性合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">temp[cnt++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比较完还有剩余</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">            temp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将temp赋值给nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; r - l + <span class="number">1</span>;k ++)&#123;</span><br><span class="line">nums[l + k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>思路</p></blockquote><p>将待排序的序列构建成一个大顶堆，堆顶的元素为最大值，将堆定的元素与堆的最后一个元素交换（最大值就到了堆的最后一个位置上），将最大值元素从堆中移除，重新调整堆的结构，使大顶堆结构不变。重复操作，直至堆中没有元素，那么就从小到大堆序列进行了排序。</p><blockquote><p>堆（Heap）</p></blockquote><p><strong>定义</strong></p><ul><li>堆就是用<strong>数组</strong>实现的二叉树；</li><li>堆是一种<strong>完全二叉树</strong></li><li>有多种具体实现：大顶堆、小顶堆<ul><li><strong>大</strong>顶堆：父节点的值<strong>大于</strong>左&#x2F;右子节点的值</li><li><strong>小</strong>顶堆：父节点的值<strong>小于</strong>左&#x2F;右子节点的值</li></ul></li></ul><blockquote><p>堆排序步骤</p></blockquote><ul><li>构建一个大顶堆<ul><li>从倒数第二层二叉树（最后一个非叶子节点），递归往上进行堆的构建（父子节点的大小判断和移动）</li></ul></li><li>将堆顶元素（最大值）和堆的最后一个元素交换</li><li>移除最后一个元素，调整大顶堆的结构使仍满足大顶堆定义</li><li>重复交换堆顶元素和堆的最后一个元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        buildHeap(nums,nums.length);<span class="comment">//创建一个堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">            swap(nums,i,<span class="number">0</span>);<span class="comment">//将最大值移动到堆的最后一个位置</span></span><br><span class="line">            heapify(nums,i,<span class="number">0</span>);<span class="comment">//调整结构满足大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastNode</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">//堆的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (lastNode - <span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//最后一个非叶子节点，需要heapify的第一个父节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parent;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">heapify(nums,n,i);<span class="comment">// 调整父子节点的大小关系（调整结构）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调整为大顶堆结构</span></span><br><span class="line"><span class="comment">    @params nums:数组（堆）</span></span><br><span class="line"><span class="comment">    @params n : 堆的大小</span></span><br><span class="line"><span class="comment">    @params i : 调整的父节点位置索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> n,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child_1</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//左子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child_2</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;<span class="comment">//右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(child_1 &lt; n &amp;&amp; nums[child_1] &gt; nums[max])&#123; <span class="comment">//确定三个节点中的最大值</span></span><br><span class="line">max = child_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child_2 &lt; n &amp;&amp; nums[child_2] &gt; nums[max])&#123;<span class="comment">//确定三个节点中的最大值</span></span><br><span class="line">            max = child_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != i)&#123;</span><br><span class="line">            swap(nums,max,i);<span class="comment">//交换使堆顶为最大值</span></span><br><span class="line">            heapify(nums,n,max);<span class="comment">//交换完之后再次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路</p></blockquote><ol><li>选择 nums[0] - nums[n - 1]中的最小值，与nums[0]交换</li><li>选择 nums[1] - nums[n - 1]中的最小值，与nums[1]交换</li><li>选择 nums[2] - nums[n - 1]中的最小值，与nums[2]交换</li><li>重复操作</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">selectSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minIndex])&#123;</span><br><span class="line">minIndex = j;</span><br><span class="line">                    swap(nums,j,minIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路</p></blockquote><p>把n个待排序的数看作一个有序表和一个无序表，开始时，有序表只包含一个元素（nums[0]），无序表包含n - 1个元素，排序过程中每次从无序表中取出第一个元素，把他与有序表元素依次比较，插入到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">insertValue = nums[i];</span><br><span class="line">            insertIndex = i;</span><br><span class="line">            <span class="keyword">while</span>(insertIndex &gt; <span class="number">0</span> &amp;&amp; nums[insertIndex - <span class="number">1</span>] &gt; insertValue)&#123;</span><br><span class="line">                nums[insertIndex] = nums[insertIndex - <span class="number">1</span>];</span><br><span class="line">                insertIndex --;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[insertIndex] = insertValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;：当需要插入的数较小时，后移的次数多。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思路</p></blockquote><p>分组进行插入排序：</p><ul><li>将  <strong>n</strong>  个待排序序列分成 <strong>gap</strong> （ <strong>n&#x2F;2</strong> ） 组 ，每组之间前一个数和后一个数的间隔  <strong>gap &#x3D; n &#x2F; 2</strong>  <ul><li>对所有分组进行插入排序</li></ul></li><li><strong>gap  &#x3D; gap &#x2F; 2</strong>  重复进行插入排序，直至  <strong>gap  &#x3D; 0</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        shellSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;gap &gt; <span class="number">0</span>; gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//下面是正常的插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap;i &lt; n;i ++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span>(insertIndex &gt; <span class="number">0</span> &amp;&amp; nums[insertIndex - gap] &gt; insertValue)&#123;</span><br><span class="line">                    nums[insertIndex] = nums[insertIndex - gap];</span><br><span class="line">                    insertIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[insertIndex] = insertValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>思路</p></blockquote><p>将所有待比较的数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低为开始，依次进行一次排序。</p><ul><li>10个桶：对应0~9个数字</li><li>将每个数的<strong>个位</strong>取出，查看应该将这个数（所有位都有）放到哪个对应的桶中</li><li>按照10个桶的顺序，和桶中元素的顺序组成一个新数组</li><li>接下来依据<strong>十位</strong>，将数据放到桶中，之后再取出</li><li>重复操作，直至最高位都已经判断了。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arraySort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        radixSort(<span class="type">int</span>[] nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();  <span class="comment">//最长的位数</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][nums.length];<span class="comment">//定义十个桶，每个桶都有一定容量</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//存放每个桶中有几个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>;i &lt; maxLength;i ++, n *= <span class="number">10</span>)&#123;<span class="comment">//循环最大数的位数次；和每次判断位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> nums[j] / n % <span class="number">10</span>;<span class="comment">//取出要判断的位上的数</span></span><br><span class="line">                <span class="comment">//放到对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = nums[j];</span><br><span class="line">                bucketElementCounts[digitOfElement] ++;<span class="comment">//桶中元素的个数++</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//取出桶中的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; <span class="number">10</span>;k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//循环拿出桶里的数据</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k];l++)&#123;</span><br><span class="line">nums[index++] = bucked[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bucketElementCounts[k] = <span class="number">0</span>;<span class="comment">//把每个桶的数据清空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2022/05/17/spring/spring/"/>
      <url>/2022/05/17/spring/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Spring-AOP"><a href="#1-Spring-AOP" class="headerlink" title="1.Spring AOP"></a>1.Spring AOP</h2><h3 id="1-1使用AOP好处"><a href="#1-1使用AOP好处" class="headerlink" title="1.1使用AOP好处"></a>1.1使用AOP好处</h3><p><strong>1.集中处理某一关注点&#x2F;横切逻辑</strong><br><strong>2.可以很方便的添加&#x2F;删除关注点</strong><br><strong>3.侵入性少，增强代码可读性及可维护性</strong></p><h3 id="1-2-AOP的术语"><a href="#1-2-AOP的术语" class="headerlink" title="1.2 AOP的术语"></a>1.2 AOP的术语</h3><p><strong>1.Join point（连接点）</strong><br>Spring 官方文档的描述：</p><blockquote><p>A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p></blockquote><p>程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法的执行。通俗的讲，连接点即表示类里面可以被增强的方法<br><strong>2.Pointcut（切入点）</strong></p><blockquote><p>Pointcut are expressions that is matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language</p></blockquote><p>切入点是与连接点匹配的表达式，用于确定是否需要执行通知。切入点使用与连接点匹配的不同类型的表达式，Spring框架使用AspectJ切入点表达式语言。我们可以将切入点理解为需要被拦截的Join point<br><strong>3.Advice（增强&#x2F;通知）</strong><br>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知和环绕通知(切面要完成的功能)<br><strong>4.Aspect（切面）</strong><br>Aspect切面表示Pointcut（切入点）和Advice（增强&#x2F;通知）的结合</p><h3 id="1-3-Spring-AOP用法"><a href="#1-3-Spring-AOP用法" class="headerlink" title="1.3 Spring AOP用法"></a>1.3 Spring AOP用法</h3><p><strong>资源代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置登录用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUserHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        holder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验用户权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;authService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> CurrentUserHolder.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;admin&quot;</span>.equals(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户无此权限！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;productService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">deleteProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品id为&quot;</span> + id + <span class="string">&quot;的商品成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProductByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品名称为&quot;</span> + name + <span class="string">&quot;的商品成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;100&quot;</span>.equals(id.toString())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该商品不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对业务逻辑类进行增强的方法</strong></p><p><strong>1.使用within表达式匹配包类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配ProductServiceImpl类里面的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.aop.service.impl.ProductServiceImpl)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchType</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配com.aop.service包及其子包下所有类的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.aop.service..*)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchPackage</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>2.使用this、target、bean表达式匹配对象类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配AOP对象的目标对象为指定类型的方法，即ProductServiceImpl的aop代理对象的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;this(com.aop.service.impl.ProductServiceImpl)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchThis</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配实现ProductService接口的目标对象</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;target(com.aop.service.ProductService)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTarget</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有以Service结尾的bean里面的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;bean(*Service)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchBean</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>3.使用args表达式匹配参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配第一个参数为Long类型的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;args(Long, ..) &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchArgs</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>4.使用@annotation、@within、@target、@args匹配注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配标注有AdminOnly注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.aop.annotation.AdminOnly)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchAnno</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标注有Beta的类底下的方法，要求annotation的Retention级别为CLASS</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@within(com.google.common.annotations.Beta)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchWithin</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标注有Repository的类底下的方法，要求annotation的Retention级别为RUNTIME</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@target(org.springframework.stereotype.Repository)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTarget</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配传入的参数类标注有Repository注解的方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@args(org.springframework.stereotype.Repository)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchArgs</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>5.使用execution表达式</strong><br>execution表达式是我们在开发过程中最常用的，它的语法如下：</p><p><img src="/JUC.assets%5C1240" alt="execution表达式"></p><p><strong>modifier-pattern</strong>：用于匹配public、private等访问修饰符<br><strong>ret-type-pattern</strong>：用于匹配返回值类型，不可省略<br><strong>declaring-type-pattern</strong>：用于匹配包类型<br><strong>modifier-pattern（param-pattern）</strong>：用于匹配类中的方法，不可省略<br><strong>throws-pattern</strong>：用于匹配抛出异常的方法</p><blockquote><p>切面Aspect代码</p><p>@Aspect：告诉Spring当前类是一个切面类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>    <span class="comment">//一定要写这个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下的方法名以delete开头、参数类型为Long的public方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.aop.service.impl.ProductServiceImpl.delete*(Long))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchCondition</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用matchCondition这个切入点进行增强</span></span><br><span class="line">    <span class="meta">@Before(&quot;matchCondition()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before 前置通知......&quot;</span>);</span><br><span class="line">        authService.checkAccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对切面类增强的方法进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置用户名</span></span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.selectProduct(<span class="number">100L</span>);</span><br><span class="line">        productService.deleteProductByName(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果，（只有deleteProductById方法拦截成功）：</span></span><br><span class="line">查询商品成功！</span><br><span class="line">删除商品名称为衣服的商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: 该用户无此权限！</span><br><span class="line"></span><br><span class="line">at com.aop.service.impl.AuthServiceImpl.checkAccess(AuthServiceImpl.java:<span class="number">15</span>)</span><br><span class="line">at com.aop.security.SecurityAspect.before(SecurityAspect.java:<span class="number">50</span>)</span><br></pre></td></tr></table></figure><blockquote><p>可以在多个表达式之间使用连接符匹配多个条件， 如使用||表示“或”，使用 &amp;&amp;表示“且”</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下方法名以select或delete开头的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.select*(..)) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;execution(* com.aop.service.impl.ProductServiceImpl.delete*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchCondition</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用matchCondition这个切入点进行增强</span></span><br><span class="line"><span class="meta">@Before(&quot;matchCondition()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;before 前置通知......&quot;</span>);</span><br><span class="line">   authService.checkAccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.selectProduct(<span class="number">100L</span>);</span><br><span class="line">        productService.deleteProductByName(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果；全部拦截成功</span></span><br><span class="line">before 前置通知......</span><br><span class="line">查询商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line">删除商品名称为衣服的商品成功！</span><br><span class="line">before 前置通知......</span><br><span class="line">删除商品id为<span class="number">100</span>的商品成功！</span><br></pre></td></tr></table></figure><h3 id="1-4-Advice注解"><a href="#1-4-Advice注解" class="headerlink" title="1.4 Advice注解"></a>1.4 Advice注解</h3><p>Advice注解一共有五种，分别是：<br><strong>1.@Before前置通知</strong><br>前置通知在切入点运行前执行，不会影响切入点的逻辑<br><strong>2.@After后置通知</strong><br>后置通知在切入点正常运行结束后执行，如果切入点抛出异常，则在抛出异常前执行<br><strong>3.@AfterThrowing异常通知</strong><br>异常通知在切入点抛出异常前执行，如果切入点正常运行（未抛出异常），则不执行<br><strong>4.@AfterReturning返回通知</strong><br>返回通知在切入点正常运行结束后执行，如果切入点抛出异常，则不执行<br><strong>5.@Around环绕通知</strong><br>环绕通知是功能最强大的通知，可以在切入点执行前后自定义一些操作。环绕通知需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.aop.service.impl.ProductServiceImpl类下面的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchAll</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;matchAll()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        authService.checkAccess();</span><br><span class="line">        System.out.println(<span class="string">&quot;befor 在切入点执行前运行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = joinPoint.proceed(joinPoint.getArgs());<span class="comment">//获取参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;after 在切入点执行后运行,result = &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after 在切入点执行后抛出exception运行&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        CurrentUserHolder.set(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        productService.deleteProductById(<span class="number">100L</span>);</span><br><span class="line">        productService.selectProduct(<span class="number">10L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">before 在切入点执行前运行</span><br><span class="line">删除商品id为<span class="number">100</span>的商品成功！</span><br><span class="line">after 在切入点执行后运行,result = <span class="number">100</span></span><br><span class="line"><span class="keyword">finally</span>......</span><br><span class="line">before 在切入点执行前运行</span><br><span class="line">查询商品失败！</span><br><span class="line">after 在切入点执行后抛出exception运行</span><br><span class="line">java.lang.RuntimeException: 该商品不存在！</span><br><span class="line">at com.aop.service.impl.ProductServiceImpl.selectProduct(ProductServiceImpl.java:<span class="number">41</span>)</span><br><span class="line"><span class="keyword">finally</span>......</span><br></pre></td></tr></table></figure><p>在执行ProceedingJoinPoint对象的proceed方法前相当于Before前置通知；执行proceed方法相当于运行切入点（同时可以获取参数）；在方法执行之后相当于After后置通知，如果运行切入点抛出异常，则catch中的内容相当于AfterThrowing异常通知;finally中的内容无论切入点是否抛出异常，都将执行</p><h3 id="1-5-使用总结"><a href="#1-5-使用总结" class="headerlink" title="1.5 使用总结"></a>1.5 使用总结</h3><blockquote><p>AOP：【动态代理】<br>          指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</p><p>  1、导入aop模块；Spring AOP：(spring-aspects)<br>  2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<br>  3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；<br>          通知方法：<br>              前置通知(@Before)：logStart：在目标方法(div)运行之前运行<br>              后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<br>              返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<br>              异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<br>              环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）<br>  4、给切面类的目标方法标注何时何地运行（通知注解）；<br>  5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<br>  6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)<br>  7、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】<br>          在Spring中很多的 @EnableXXX;</p><p>  三步：<br>      1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）<br>      2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）<br>      3）、开启基于注解的aop模式；@EnableAspectJAutoProxy</p></blockquote><h3 id="1-7-案例"><a href="#1-7-案例" class="headerlink" title="1.7 案例"></a>1.7 案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">我定义了一个除法方法，作为一个切面：需要增强的业务方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.kun.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathCalculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathCalculator...div...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i/j;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span>： 告诉Spring当前类是一个切面类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspects</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽取公共的切入点表达式</span></span><br><span class="line">    <span class="comment">//1、本类引用</span></span><br><span class="line">    <span class="comment">//2、其他的切面引用</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.kun.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logStart</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;运行。。。@Before:参数列表是：&#123;&quot;</span>+Arrays.asList(args)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(&quot;com.kun.aop.LogAspects.pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logEnd</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;结束。。。@After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JoinPoint一定要出现在参数表的第一位</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;</span>+result+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;异常。。。异常信息：&#123;&quot;</span>+exception+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@EnableAspectJAutoProxy:注解开启切面代理</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">aop的配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kun.aop.LogAspects;</span><br><span class="line"><span class="keyword">import</span> com.kun.aop.MathCalculator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfigOfAOP</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//业务逻辑类加入容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MathCalculator <span class="title function_">calculator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MathCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切面类加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogAspects <span class="title function_">logAspects</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogAspects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8代理对象创建过程"><a href="#1-8代理对象创建过程" class="headerlink" title="1.8代理对象创建过程"></a>1.8代理对象创建过程</h3><h4 id="1-8-1-EnableAspectJAutoProxy"><a href="#1-8-1-EnableAspectJAutoProxy" class="headerlink" title="1.8.1@EnableAspectJAutoProxy"></a>1.8.1@EnableAspectJAutoProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">     * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它导入了一个<strong>AspectJAutoProxyRegistrar</strong>组件，进一步查看其代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.config.AopConfigUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.context.annotation.MetadataUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy&#125; annotation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">     * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">enableAJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">                attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它实现了<strong>ImportBeanDefinitionRegistrar</strong>接口，这个接口可以向IOC容器中注册bean。 由此可以推测aop利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion。</p></blockquote><p><img src="/JUC.assets%5C1140836-20181031200151572-1248357045.png" alt="img"></p><blockquote><p><em>IOC容器中注入了一个internalAutoProxyCreator&#x3D;AnnotationAwareAspectJAutoProxyCreator的bean，</em>到此可以得出结论，@EnableAspectJAutoProxy给容器中注册一个AnnotationAwareAspectJAutoProxyCreator。</p></blockquote><h4 id="1-8-2-AnnotationAwareAspectJAutoProxyCreator创建过程"><a href="#1-8-2-AnnotationAwareAspectJAutoProxyCreator创建过程" class="headerlink" title="1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程"></a>1.8.2 AnnotationAwareAspectJAutoProxyCreator创建过程</h4><p><img src="/JUC.assets%5C1140836-20181031201123887-743732675.png" alt="img"></p><blockquote><p>在此需要关注两点内容：</p><p>1）关注后置处理器SmartInstantiationAwareBeanPostProcessor（在bean初始化完成前后做事情）</p><p>2）关注自动装配BeanFactory。</p></blockquote><blockquote><p>通过代码查看，发现父类AbstractAutoProxyCreator中有后置处理器的内容；AbstactAdvisorAutoProxyCreator类中重写了其父类AbstractAutoProxyCreator中setBeanFactory()方法，在AnnotationAwareAspectJAutoProxyCreator类中initBeanFactory()方法完成了自动装配BeanFactory。</p></blockquote><p>1）、 @EnableAspectJAutoProxy 开启AOP功能<br> 2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator<br> 3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；<br> 4）、容器的创建流程：<br>        1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象<br>        2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean<br>            1）、创建业务逻辑组件和切面组件<br>            2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>            3）、组件创建完之后，判断组件是否需要增强<br>                     是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；<br> 5）、执行目标方法：<br>        1）、代理对象执行目标方法<br>        2）、CglibAopProxy.intercept()；<br>             1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）<br>             2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>             3）、效果：<br>                      正常执行：前置通知-》目标方法-》后置通知-》返回通知<br>                      出现异常：前置通知-》目标方法-》后置通知-》异常通知</p><h3 id="1-9-面试回答AOP"><a href="#1-9-面试回答AOP" class="headerlink" title="1.9 面试回答AOP"></a>1.9 面试回答AOP</h3><p>简单说说 AOP 的设计：</p><ol><li>每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li><li>每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP。</li><li>当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦截器”。内层拦截器的设计就是职责连的设计。</li></ol><p><strong>可以将 AOP 分成 2 个部分。</strong><br>第一：代理的创建；<br>第二：代理的调用。</p><ol><li>代理的创建（按步骤）：</li></ol><ul><li>首先，需要创建代理工厂，代理工厂需要 3 个重要的信息：拦截器数组，目标对象接口数组，目标对象。</li><li>创建代理工厂时，默认会在拦截器数组尾部再增加一个默认拦截器 —— 用于最终的调用目标方法。</li><li>当调用 getProxy 方法的时候，会根据接口数量大余 0 条件返回一个代理对象（JDK or Cglib）。</li><li>注意：创建代理对象时，同时会创建一个外层拦截器，这个拦截器就是 Spring 内核的拦截器。用于控制整个 AOP 的流程。</li></ul><ol start="2"><li>代理的调用</li></ol><ul><li>当对代理对象进行调用时，就会触发外层拦截器。</li><li>外层拦截器根据代理配置信息，创建内层拦截器链。创建的过程中，会根据表达式判断当前拦截是否匹配这个拦截器。而这个拦截器链设计模式就是职责链模式。</li><li>当整个链条执行到最后时，就会触发创建代理时那个尾部的默认拦截器，从而调用目标方法。最后返回。</li></ul><p>题外话：Spring 的事务也就是个拦截器。</p><p><img src="/JUC.assets%5C124011111" alt="img"></p><p><img src="/JUC.assets%5CAOP%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B" alt="img"></p><h2 id="2-Spring-三级缓存"><a href="#2-Spring-三级缓存" class="headerlink" title="2. Spring 三级缓存"></a>2. Spring 三级缓存</h2><h3 id="2-1-Spring-Bean的循环依赖"><a href="#2-1-Spring-Bean的循环依赖" class="headerlink" title="2.1 Spring Bean的循环依赖"></a><strong>2.1 Spring Bean的循环依赖</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这其实就是Spring环境下典型的循环依赖场景</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类：</p><p><img src="/JUC.assets%5C%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p><ol><li><p><strong>构造器注入循环依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p><p><img src="/JUC.assets%5Cimage-20210912191502658.png" alt="image-20210912191502658"></p></li></ol><blockquote><p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘） </p><p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决~~~</p></blockquote><ol start="2"><li><p><strong>field属性注入（setter方法注入）循环依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>结果：项目启动成功，能够正常work</strong></p></li><li><p><strong><code>prototype</code> field属性注入循环依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单例Bean内注入</span></span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private A a;</span><br></pre></td></tr></table></figure><p><img src="/JUC.assets%5Cimage-20210912191727007.png" alt="image-20210912191727007"></p></li></ol><blockquote><p>对于Spring循环依赖的情况总结如下：</p><ol><li>不能解决的情况： 1. 构造器注入循环依赖 2. <code>prototype</code> field属性注入循环依赖</li><li>能解决的情况： 1. field属性注入（setter方法注入）循环依赖</li></ol></blockquote><p><strong>Spring创建Bean的流程</strong></p><p><img src="/JUC.assets%5C20210912.png" alt="20210912"></p><p>对Bean的创建最为核心三个方法解释如下：</p><ul><li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li><li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li><li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li></ul><p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p><p><strong>Spring容器的<code>&#39;三级缓存&#39;</code></strong></p><p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p><p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line"><span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line"><span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line"><span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p><ol><li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li><li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li><li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li></ol><p><strong>获取单例Bean的源码如下：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isActuallyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li><li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li><li>如果还是获取不到，且允许singletonFactories（allowEarlyReference&#x3D;true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从</strong><code>**singletonFactories**</code><strong>中移除，并且放进</strong><code>**earlySingletonObjects**</code><strong>。其实也就是从三级缓存</strong><code>**移动（是剪切、不是复制哦~）**</code><strong>到了二级缓存）</strong></li></ol><blockquote><p> <strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong></p></blockquote><p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span></span><br><span class="line">@<span class="title class_">FunctionalInterface</span></span><br><span class="line">public interface <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">T <span class="title function_">getObject</span>() throws <span class="title class_">BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。 </p></blockquote><p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p><p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来 <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p><h3 id="2-2-源码解析"><a href="#2-2-源码解析" class="headerlink" title="2.2 源码解析"></a>2.2 源码解析</h3><p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FactoryBeanRegistrySupport</span> implements <span class="title class_">ConfigurableBeanFactory</span> &#123;</span><br><span class="line">...</span><br><span class="line">protected &lt;T&gt; T <span class="title function_">doGetBean</span>(final <span class="title class_">String</span> name, @<span class="title class_">Nullable</span> final <span class="title class_">Class</span>&lt;T&gt; requiredType, @<span class="title class_">Nullable</span> final <span class="title class_">Object</span>[] args, boolean typeCheckOnly) throws <span class="title class_">BeansException</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span></span><br><span class="line"><span class="title class_">Object</span> sharedInstance = <span class="title function_">getSingleton</span>(beanName);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="title function_">markBeanAsCreated</span>(beanName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.<span class="title function_">isSingleton</span>()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span></span><br><span class="line"><span class="comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span></span><br><span class="line"><span class="comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span></span><br><span class="line">sharedInstance = <span class="title function_">getSingleton</span>(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">createBean</span>(beanName, mbd, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">BeansException</span> ex) &#123;</span><br><span class="line"><span class="title function_">destroySingleton</span>(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = <span class="title function_">getObjectForBeanInstance</span>(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span></span><br><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractBeanFactory</span> implements <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line">...</span><br><span class="line">protected <span class="title class_">Object</span> <span class="title function_">doCreateBean</span>(final <span class="title class_">String</span> beanName, final <span class="title class_">RootBeanDefinition</span> mbd, final @<span class="title class_">Nullable</span> <span class="title class_">Object</span>[] args) throws <span class="title class_">BeanCreationException</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span></span><br><span class="line">instanceWrapper = <span class="title function_">createBeanInstance</span>(beanName, mbd, args);</span><br><span class="line"><span class="comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span></span><br><span class="line"><span class="comment">// 注意：此处是原始对象，这点非常的重要</span></span><br><span class="line">final <span class="title class_">Object</span> bean = instanceWrapper.<span class="title function_">getWrappedInstance</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span></span><br><span class="line"><span class="comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span></span><br><span class="line"><span class="comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span></span><br><span class="line">boolean earlySingletonExposure = (mbd.<span class="title function_">isSingleton</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">allowCircularReferences</span> &amp;&amp; <span class="title function_">isSingletonCurrentlyInCreation</span>(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.<span class="title function_">isTraceEnabled</span>()) &#123;</span><br><span class="line">logger.<span class="title function_">trace</span>(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span></span><br><span class="line"><span class="comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span></span><br><span class="line"><span class="comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span></span><br><span class="line"><span class="comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span></span><br><span class="line"><span class="comment">// 若不需要执行AOP的逻辑，直接返回Bean</span></span><br><span class="line"><span class="title function_">addSingletonFactory</span>(beanName, () -&gt; <span class="title function_">getEarlyBeanReference</span>(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span> exposedObject = bean; <span class="comment">//exposedObject 是最终返回的对象</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 填充属于，解决@Autowired依赖~</span></span><br><span class="line"><span class="title function_">populateBean</span>(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 执行初始化回调方法们~~~</span></span><br><span class="line">exposedObject = <span class="title function_">initializeBean</span>(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span></span><br><span class="line"><span class="comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span></span><br><span class="line"><span class="comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span></span><br><span class="line"><span class="comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span></span><br><span class="line"><span class="comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了&quot;偷天换日&quot; 特别适合中间件的设计</span></span><br><span class="line"><span class="comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span></span><br><span class="line"><span class="title class_">Object</span> earlySingletonReference = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span></span><br><span class="line"><span class="comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// allowRawInjectionDespiteWrapping这个值默认是false</span></span><br><span class="line"><span class="comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">allowRawInjectionDespiteWrapping</span> &amp;&amp; <span class="title function_">hasDependentBean</span>(beanName)) &#123;</span><br><span class="line"><span class="comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span></span><br><span class="line"><span class="title class_">String</span>[] dependentBeans = <span class="title function_">getDependentBeans</span>(beanName);</span><br><span class="line"><span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个个检查它所以Bean</span></span><br><span class="line"><span class="comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span></span><br><span class="line"><span class="comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span></span><br><span class="line"><span class="comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span></span><br><span class="line"><span class="comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="title class_">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.<span class="title function_">add</span>(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span></span><br><span class="line"><span class="comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line"><span class="title class_">StringUtils</span>.<span class="title function_">collectionToCommaDelimitedString</span>(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然是remove方法 但是它的返回值也非常重要</span></span><br><span class="line"><span class="comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span></span><br><span class="line">protected boolean <span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(<span class="params"><span class="built_in">String</span> beanName</span>) &#123;</span><br><span class="line"><span class="comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">alreadyCreated</span>.<span class="title function_">contains</span>(beanName)) &#123;</span><br><span class="line"><span class="title function_">removeSingleton</span>(beanName);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p><p>这里有个小细节：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p><h3 id="2-3-流程总结（非常重要）"><a href="#2-3-流程总结（非常重要）" class="headerlink" title="2.3 流程总结（非常重要）"></a>2.3 流程总结（<code>非常重要</code>）</h3><p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p><p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean(&quot;a&quot;)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T <span class="title function_">doGetBean</span>(<span class="params">...</span>)&#123;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line"><span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="title function_">markBeanAsCreated</span>(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line"><span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line"><span class="title class_">Object</span> beanInstance = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line"><span class="comment">//1、标注a正在创建中~</span></span><br><span class="line"><span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line"><span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line"><span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">sharedInstance = <span class="title function_">getSingleton</span>(beanName, () -&gt; &#123; ... <span class="keyword">return</span> <span class="title function_">createBean</span>(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected <span class="title class_">Object</span> <span class="title function_">doCreateBean</span>(<span class="params"></span>)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span></span><br><span class="line">instanceWrapper = <span class="title function_">createBeanInstance</span>(beanName, mbd, args);</span><br><span class="line"><span class="comment">// 此处bean为&quot;原始Bean&quot;   也就是这里的A实例对象：A@1234</span></span><br><span class="line">final <span class="title class_">Object</span> bean = instanceWrapper.<span class="title function_">getWrappedInstance</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span></span><br><span class="line">boolean earlySingletonExposure = (mbd.<span class="title function_">isSingleton</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">allowCircularReferences</span> &amp;&amp; <span class="title function_">isSingletonCurrentlyInCreation</span>(beanName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span></span><br><span class="line"><span class="comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="title function_">addSingletonFactory</span>(beanName, () -&gt; <span class="title function_">getEarlyBeanReference</span>(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span></span><br><span class="line"><span class="title class_">Object</span> exposedObject = bean; </span><br><span class="line"><span class="comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span></span><br><span class="line"><span class="comment">// 因此此处会调用getBean(&quot;b&quot;)，so 会重复上面步骤创建B类的实例</span></span><br><span class="line"><span class="comment">// 此处我们假设B已经创建好了 为B@5678</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是在populateBean(&quot;b&quot;)的时候依赖有beanA，所以此时候调用getBean(&quot;a&quot;)最终会调用getSingleton(&quot;a&quot;)，</span></span><br><span class="line"><span class="comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">populateBean</span>(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span></span><br><span class="line"><span class="comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span></span><br><span class="line"><span class="comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span></span><br><span class="line">exposedObject = <span class="title function_">initializeBean</span>(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span></span><br><span class="line"><span class="comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span></span><br><span class="line"><span class="comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span></span><br><span class="line"><span class="comment">// 因此此处返回A的实例：A@1234</span></span><br><span class="line"><span class="title class_">Object</span> earlySingletonReference = <span class="title function_">getSingleton</span>(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span></span><br><span class="line"><span class="comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span></span><br><span class="line"><span class="comment">// 这种情况至此，就全部结束了~~~</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span></span><br><span class="line"><span class="comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是[&quot;b&quot;]这个依赖</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">allowRawInjectionDespiteWrapping</span> &amp;&amp; <span class="title function_">hasDependentBean</span>(beanName)) &#123;</span><br><span class="line"><span class="title class_">String</span>[] dependentBeans = <span class="title function_">getDependentBeans</span>(beanName);</span><br><span class="line"><span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A@1234依赖的是[&quot;b&quot;]，所以此处去检查b</span></span><br><span class="line"><span class="comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span></span><br><span class="line"><span class="keyword">for</span> (<span class="title class_">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span></span><br><span class="line"><span class="comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span>(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.<span class="title function_">add</span>(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line"><span class="title class_">StringUtils</span>.<span class="title function_">collectionToCommaDelimitedString</span>(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解： </p><p><img src="/JUC.assets%5C%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="循环依赖流程图"></p><hr><p><strong>最后的最后，由于我太暖心了_，再来个纯文字版的总结。</strong> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p><ol><li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li><li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li><li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li><li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li><li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li><li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li><li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li><li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li><li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li><li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li></ol><p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p><hr><hr><hr><h3 id="2-4-循环依赖对AOP代理对象创建流程和结果的影响"><a href="#2-4-循环依赖对AOP代理对象创建流程和结果的影响" class="headerlink" title="2.4 循环依赖对AOP代理对象创建流程和结果的影响"></a>2.4 循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h3><p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p><p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span></span><br><span class="line"><span class="comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span></span><br><span class="line"><span class="comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span></span><br><span class="line"><span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span></span><br><span class="line"><span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环依赖校验（非常重要）~~~~</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span></span><br><span class="line"><span class="comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span></span><br><span class="line"><span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line"><span class="comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span></span><br><span class="line"><span class="comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span></span><br><span class="line"><span class="comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环依赖校验</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span></span><br><span class="line"><span class="comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span></span><br><span class="line"><span class="comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">&#125;...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀~~~）</p><p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Caused</span> <span class="attr">by</span>: org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">BeanCurrentlyInCreationException</span>: <span class="title class_">Error</span> creating bean <span class="keyword">with</span> name <span class="string">&#x27;a&#x27;</span>: <span class="title class_">Requested</span> bean is currently <span class="keyword">in</span> <span class="attr">creation</span>: <span class="title class_">Is</span> there an unresolvable circular reference?</span><br><span class="line">at org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">support</span>.<span class="property">DefaultSingletonBeanRegistry</span>.<span class="title function_">beforeSingletonCreation</span>(<span class="title class_">DefaultSingletonBeanRegistry</span>.<span class="property">java</span>:<span class="number">339</span>)</span><br><span class="line">at org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">support</span>.<span class="property">DefaultSingletonBeanRegistry</span>.<span class="title function_">getSingleton</span>(<span class="title class_">DefaultSingletonBeanRegistry</span>.<span class="property">java</span>:<span class="number">215</span>)</span><br></pre></td></tr></table></figure><blockquote><p> 注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别~~ 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置~ </p></blockquote><p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span></span><br><span class="line"><span class="comment">// 但是：我们的此bean还是需要AOP代理的~~~</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private HelloService helloService;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样它的大致运行如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line"><span class="comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">...</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">... 这里更不用说，因为earlySingletonExposure=<span class="literal">false</span>  所以上面的代理对象exposedObject 直接<span class="keyword">return</span>了~</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p><p>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</p><blockquote><p> <code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些 </p></blockquote><p>该抽象类实现了创建代理的动作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span></span><br><span class="line"><span class="comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span></span><br><span class="line"><span class="comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span></span><br><span class="line"><span class="comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span></span><br><span class="line"><span class="comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p><p><strong><code>上面分析了三种case，现给出结论如下：</code></strong> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong></p><h2 id="3-Spring-MVC"><a href="#3-Spring-MVC" class="headerlink" title="3. Spring MVC"></a>3. Spring MVC</h2><p><img src="/JUC.assets%5CspringMVC" alt="img"></p><p><img src="/JUC.assets%5Cimage-20210912190512831.png" alt="image-20210912190512831"></p><h2 id="4-java动态代理"><a href="#4-java动态代理" class="headerlink" title="4. java动态代理"></a>4. <a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html">java动态代理</a></h2><p>关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式–代理模式，而对于代理，根据创建代理类的时间点，又可以分为静态代理和动态代理。</p><h3 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h3><p>  代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。在后面我会</p><p>解释这种间接性带来的好处。代理模式结构图（图片来自《大话设计模式》）：</p><p><img src="/JUC.assets%5C1085268-20170409105440082-1652546649.jpg" alt="img">                             </p><h3 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h3><p>  <strong>1、静态代理</strong></p><p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p><p>  <strong>2、静态代理简单实现</strong></p><p> 根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，</p><p>班长就是学生的代理。</p><p>  首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>Student类实现Person接口。Student可以具体实施上交班费的动作。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>下面测试一下，看如何使用代理模式：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentsProxy</span>(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//班长代理上交班费</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行结果：</p><p><img src="/JUC.assets%5C1085268-20170409141805347-556037068.png" alt="img"></p><p>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行结果：</p><p><img src="/JUC.assets%5C1085268-20170409143428488-1662654340.png" alt="img"></p><p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p><h3 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a><strong>三、动态代理</strong></h3><p>   <strong>1.动态代理</strong></p><p>  代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">       beforeMethod();</span><br><span class="line">       stu.giveMoney();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p><p>   <strong>2、动态代理简单实现</strong></p><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p>创建一个动态代理对象步骤，具体代码见后面：</p><ul><li>创建一个InvocationHandler对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line"> <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br></pre></td></tr></table></figure><ul><li>使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;Person.class&#125;);</span><br></pre></td></tr></table></figure><ul><li>获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);</span><br></pre></td></tr></table></figure><ul><li>通过构造器constructor来创建一个动态实例stuProxy</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person stuProxy = (Person) cons.newInstance(stuHandler);</span><br></pre></td></tr></table></figure><p>就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure><p>到这里肯定都会很疑惑，这动态代理到底是如何执行的，是如何通过代理对象来执行被代理对象的方法的，先不急，我们先看看一个简单的完整的动态代理的例子。还是上面静态代理的例子，班长需要帮学生代交班费。**<br>**首先是定义一个Person接口:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建需要被代理的实际类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">finishTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><p>再再invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuInvocationHandler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StuInvocationHandler</span><span class="params">(T target)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">stuHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StuInvocationHandler</span>&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">stuProxy</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。</p><p>运行结果：</p><p><img src="/JUC.assets%5C1085268-20170409164136175-1515319571.png" alt="img"></p><p>上面说到，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p><p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p><h3 id="四、动态代理原理分析"><a href="#四、动态代理原理分析" class="headerlink" title="四、动态代理原理分析"></a><strong>四、动态代理原理分析</strong></h3><p>  <strong>1、Java动态代理创建出来的动态代理类</strong></p><p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我们最应该关注的是 Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">&quot;$Proxy0&quot;</span>, Student.class.getInterfaces());</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;G:/javacode/javase/Test/bin/proxy/StuProxy.class&quot;</span>;</span><br><span class="line"><span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path)) &#123;</span><br><span class="line">    fos.write(classFile);</span><br><span class="line">    fos.flush();</span><br><span class="line">    System.out.println(<span class="string">&quot;代理类class文件写入成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;写文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：\</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">  *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">  *Proxy构造方法：</span></span><br><span class="line"><span class="comment">  *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">  *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">  *         this.h = h;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;proxy.Person&quot;</span>).getMethod(<span class="string">&quot;giveMoney&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">  *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。<br>上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/05/17/redis/redis/"/>
      <url>/2022/05/17/redis/redis/</url>
      
        <content type="html"><![CDATA[<h4 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h4><h5 id="为什么要用Nosql"><a href="#为什么要用Nosql" class="headerlink" title="为什么要用Nosql"></a>为什么要用Nosql</h5><blockquote><p>1、单机MYSQL的年代</p></blockquote><ul><li>数据量如果太大，一个机器放不下了</li><li>数据的索引（B + Tree）,一个机器内存也放不下</li><li>访问量（读写混合），一个服务器承受不了</li></ul><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210602111138714.png" alt="image-20210602111138714"></p><p>出现以上三种情况之一，就必须要晋级</p><blockquote><p>2、Memacshed(缓存) + MYSQL + 垂直拆分（读写分离）</p></blockquote><p>希望减轻服务器的压力、使用缓存来保证效率</p><p>发展过程：优化数据结构和索引 —&gt; 文件缓存（IO） –&gt; Memcacahed(当时最热门的技术)</p><blockquote><p>3、分库分表+水平拆分+MYSQL集群</p></blockquote><blockquote><p>4、如今时代</p></blockquote><ul><li>MYSQL等关系型数据库就不够用了！数据量很多 </li><li>MYSQL有的使用它来存储一些较大的文件，博客，图片！数据表很大，效率就低了！如果有一种数据库来专门处理这种数据，MySQL的压力就小了</li></ul><blockquote><p>5.目前的互联网项目</p></blockquote><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210602110847515.png" alt="image-20210602110847515"></p><blockquote><p>为什么用NoSQL</p></blockquote><p>用户的个人信息、社交网络、地理位置。用户自己产生的数据、用户日志等等爆发式增长。</p><p>这时候我们就需要使用NoSQL数据库，NoSQL可以很好的处理以上的情况。</p><h5 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h5><blockquote><p>NoSQL</p></blockquote><p>NoSQL &#x3D;  Not Only SQL(不仅仅是SQL)</p><p>关系型数据库：表格、行、列。</p><p>泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代。尤其是超大规模的高并发社区。</p><p>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！</p><p>不需要多余的操作就可以横向扩展的！Map&lt;String,Object&gt;使用键值对来控制！</p><blockquote><p>NoSQL特点</p></blockquote><ul><li>方便扩展（数据之间没有关系，很好扩展）</li><li>大数据量高性能（Redis一秒写8万次，读取11万一秒，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</li><li>数据类型是多样型的（不需要事先设计数据库。随去随用。如果数据库十分大的表，很多人就无法设计了）</li><li>传动的关系型数据库（RDBMS）和NoSQL</li></ul><blockquote><p>传统的RDBMS</p><ul><li>结构化祖师</li><li>SQL</li><li>数据和关系都存在单独的表中</li><li>数据操作语言，数据定义语言</li><li>严格的一致性</li><li>基础的事务</li></ul></blockquote><blockquote><p>NoSQL</p><ul><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储，列存储，文档存储，图形数据库（社交关系）</li><li>最终一致性</li><li>CAP定理和BASE(异地多活)</li><li>高新能、高可用、高可扩展性</li></ul></blockquote><h5 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h5><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210602120705404.png" alt="image-20210602120705404"></p><h5 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h5><p><strong>KV键值对</strong></p><ul><li>新浪：Redis</li><li>美团：Redis + Tair</li><li>阿里，百度：Redis + memcache</li></ul><p><strong>文档型数据库（bson格式）</strong></p><ul><li>MongoDB(一般必须要掌握)<ul><li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关心性数据库中功能最丰富，最像关系型数据库的！</li></ul></li></ul><p><strong>列存储数据库</strong></p><ul><li>HBase</li><li>分布式文件系统</li></ul><p><strong>图关系数据库</strong></p><ul><li>不是存图形的，放的是关系。如：朋友圈社交网络，广告推荐</li></ul><p><strong>对比</strong></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210602121947362.png" alt="image-20210602121947362"></p><h4 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p>Redis是什么？</p></blockquote><p>Redis(Remote Dictionary Server),远程字典服务</p><blockquote><p>Redis能做什么？</p></blockquote><ul><li>内存存储、持久化，内存中是断电丢失、所以说持久化很重要（rdb,aof）</li><li>小路高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量）</li></ul><blockquote><p>特性</p></blockquote><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事物</li></ul><blockquote><p>学习中需要用到的东西</p></blockquote><ul><li>官网：<a href="https://redis.io/">https://redis.io/</a></li><li>中文网：<a href="https://www.redis.cn/">https://www.redis.cn/</a></li><li>下载地址：</li></ul><h5 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h5><ul><li>1.下载安装包</li></ul><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210602144746430.png" alt="image-20210602144746430"></p><h5 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h5><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603190644081.png" alt="image-20210603190644081"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603195130190.png" alt="image-20210603195130190"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603195512417.png" alt="image-20210603195512417"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603195553950.png" alt="image-20210603195553950"></p><p>5.redis的默认安装路径 <code>/usr</code>下面</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603195823324.png" alt="image-20210603195823324"></p><p>6.将redis配置文件复制到当前目录下</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603200133459.png" alt="image-20210603200133459"></p><p>7.redis默认不知后台启动的，需要修改配置文件<code>vim redis.conf</code> </p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603200452315.png"></p><p>8.启动redis服务</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603200622845.png" alt="image-20210603200622845"></p><p>9.使用redis客户端连接</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603200835121.png" alt="image-20210603200835121"></p><p>10.查看redis进程是否开启</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603200959309.png" alt="image-20210603200959309"></p><p>11.关闭redis服务</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210603201102943.png" alt="image-20210603201102943"></p><h5 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h5><p><strong>redis-benchmark</strong>是一个压力测试工具！</p><p>官方自带的性能测试工具</p><p>redis-benchmark命令参数</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210604140602063.png" alt="image-20210604140602063"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试：100各并发连接 10000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 10000</span><br></pre></td></tr></table></figure><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>redis默认有16个数据库</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210604141851021.png" alt="image-20210604141851021"></p><p>默认使用的第0个数据库，可以使用select进行切换数据库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3<span class="comment">#切换数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize<span class="comment">#查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *<span class="comment">#查看所有key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; flushdb<span class="comment">#清空数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushall  <span class="comment">#清空全部数据库</span></span><br></pre></td></tr></table></figure><blockquote><p>Redis 是单线程</p></blockquote><p>Redis是基于内存操作，CUP不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就是用单线程了。</p><p><strong>Redis为什么是单线程的还这么快</strong></p><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CUP上下文会切换！）一定比单线程效率高？</li></ul><p>核心：redis是将所有的数据都放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p><h4 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h4><h5 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name chuchu</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">3) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line">5) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; expire name 60<span class="comment">#设置name的过期时间？</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ttl anme</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name<span class="comment">#查看key的类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> ange<span class="comment">#查看key的类型</span></span><br><span class="line">none</span><br></pre></td></tr></table></figure><h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; append key1 hello<span class="comment">#append命令，向字符串尾部追加字符串。如果key不存在，就会新建这个key</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen key1<span class="comment">#获取字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;,world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1hello,world&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0<span class="comment">#初始浏览量为0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views<span class="comment"># 每次加1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views<span class="comment">#每次减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby views 10<span class="comment">#加10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; decrby views 5<span class="comment">#减5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;get&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment">#字符串范围 range</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 3<span class="comment">#截取字符串[0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1<span class="comment">#获取全部字符串</span></span><br><span class="line"><span class="string">&quot;hello,world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#替换</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 xx<span class="comment">#替换 1 索引位置的bc 为 xx</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;axxdefg&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment">#setex (set with expire)#设置过期时间</span></span><br><span class="line"><span class="comment">#setnx (set if not exist)#不存在设置（在分布式锁中会常常使用）</span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 <span class="string">&quot;hello&quot;</span><span class="comment">#设置key3的值为&quot;hello&quot;，30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;redis&quot;</span><span class="comment">#mykey不存在时设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key2&quot;</span></span><br><span class="line">2) <span class="string">&quot;mykey&quot;</span></span><br><span class="line">3) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx key3 <span class="string">&quot;MongDB&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SETNX mykey <span class="string">&quot;mongdb&quot;</span><span class="comment">#mykey存在时设置失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment">#mset #批量设置</span></span><br><span class="line"><span class="comment">#mget #批量获取</span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k5 v5<span class="comment">#msetnx 批量不存在时设置，要么一起成功，要么一起失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="built_in">set</span> user:1 &#123;name:zhangsan,age:3&#125; <span class="comment">#设置一个user:1对象  值为json字符串来保存一个对象</span></span><br><span class="line"><span class="comment">#这里的key时巧妙的设计：  user:&#123;id&#125;:&#123;filed&#125;,如此设计</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="comment">###################################################################################################</span></span><br><span class="line">getset <span class="comment">#先get后set</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getset db redis<span class="comment">#如果不存在值，返回null,如果存在值返回db</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb<span class="comment">#如果存在值，获取原来的值，并设置新的值</span></span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String类似的使用场景：value除了时字符串还可以时数组</p><ul><li>计数器</li><li>统计多单位的数量</li></ul><hr><h5 id="List-列表"><a href="#List-列表" class="headerlink" title="List (列表)"></a>List (列表)</h5><p>基本的数据类型，列表</p><p>在redis中可以将list用成<strong>栈、队列、阻塞队列</strong></p><p>所有的list命令都是<strong>L</strong>开头的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one<span class="comment">#将一个值或多个值插入列表的头部（左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1<span class="comment">#获取list中的值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list four<span class="comment">#将一个值或多个值插入列表的尾部（右）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list <span class="comment">#移除左边的值</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list<span class="comment">#移除右边的值</span></span><br><span class="line"><span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">lindex <span class="comment">#获取索引对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1<span class="comment">#通过下标获取某一个值</span></span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">llen <span class="comment">#获取list长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen list<span class="comment">#返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">移除指定的值</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 three<span class="comment">#移除list中指定个数的value,精确匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">trim 修剪：list 截断</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello2&quot;</span> <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2<span class="comment">#通过下标截取指定的长度，这个list已经被改变了，只剩下截取的元素了</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">rpoplpush<span class="comment">#移除列表最后一个元素，并且将它添加到另一个元素并返回</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span> <span class="string">&quot;hello1&quot;</span> <span class="string">&quot;hello2&quot;</span> <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist<span class="comment">#移除mylist最后一个元素，并且将它添加到myotherlist中并返回</span></span><br><span class="line"><span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello3&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">lset  <span class="comment">#将列表指定索引处设置元素值（替换）</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line">linsert <span class="comment">#在某个元素的前面或者后面插入一个值</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before <span class="string">&quot;world&quot;</span> <span class="string">&quot;other&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after <span class="string">&quot;world&quot;</span> <span class="string">&quot;new&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;other&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">4) <span class="string">&quot;new&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>他实际是一个链表，before node after,left  ,right都可以插入值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高。中间元素，相对来说效率会低一点。</li></ul><p>消息排队！消息队列 (lpush rpop )，栈（lpush,lpop）.</p><hr><h5 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h5><p>set中的值不能重复</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;world&quot;</span> <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello<span class="comment">#判断某个值是不是在set中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset <span class="comment">#获取set中元素的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset <span class="string">&quot;hello&quot;</span><span class="comment">#移除某个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="built_in">set</span> 无序不重复集合</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset<span class="comment">#随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2<span class="comment">#随机抽选出两个元素</span></span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span> <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">删除指定的key,随机删除key</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset<span class="comment">#随机删除集合中的一些元素</span></span><br><span class="line"><span class="string">&quot;chuchu2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;chuchu&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">将一个指定的值，移动到另一个集合中</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span> <span class="string">&quot;nihao&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 hello<span class="comment">#将myset中的hello移动到myset2中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;nihao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">微博，b站，共同关注（交集）</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 c d </span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2<span class="comment">#查看不同的</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2<span class="comment">#查看相同的（交集）</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sunion key1 key2<span class="comment">#并集</span></span><br><span class="line">1) <span class="string">&quot;d&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微博，A用户将所有关注的人放在一个set集合中。将它的粉丝也放在一个集合中。</p><h5 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h5><hr><p>Map集合，key-map!这时候这个值是一个map集合！本质与String类型没有太大区别，还是一个简单的key-value.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 chuchu<span class="comment">#往map里添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1<span class="comment">#获取元素</span></span><br><span class="line"><span class="string">&quot;chuchu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<span class="comment">#一次添加多个</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2<span class="comment">#一次获取多个</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash<span class="comment">#获取全部</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field2<span class="comment">#删除指定的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash </span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">获取长度</span><br><span class="line">hlen</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field3 hello field4 redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash<span class="comment">#获取字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field3&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">5) <span class="string">&quot;field4&quot;</span></span><br><span class="line">6) <span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget myhash field3</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">判断某个值是否存在</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field<span class="comment">#判断field是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">#只获得所有的字段</span></span><br><span class="line"><span class="comment">#只获得所有的值</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash<span class="comment">#获取所有的字段key</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;field3&quot;</span></span><br><span class="line">3) <span class="string">&quot;field4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash<span class="comment">#获取所有的值value</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">#incr decr</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field 6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field 2<span class="comment">#增加2</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 9<span class="comment">#不存在时设置自动为9，如果已经存在就不成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field7 2<span class="comment">#不存在时设置自动为9，如果不存在就成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><hr><h5 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h5><p>在set的基础上，增加了一个值，set k1 v1 &#x3D;&gt; zset k1 score v1</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 zhangsan 5000 wangsi 500 liwu</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf<span class="comment">#从最小值到最大值排序</span></span><br><span class="line">1) <span class="string">&quot;liwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1<span class="comment">#从最大值到最小值排序</span></span><br><span class="line">1) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores<span class="comment">#加上key</span></span><br><span class="line">1) <span class="string">&quot;liwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">移除rem中的元素</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;liwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary liwu<span class="comment">#移除指定集合中的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;wangsi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary<span class="comment">#获取集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello 2 world 3 chuchu 4 dedi</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3<span class="comment">#获取指定区间内的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h4><h5 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h5><hr><blockquote><p>geoadd</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#geoadd 添加地理位置</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing <span class="comment">#添加城市数据</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai 106.50 29.53 chongqing 114.05 22.52 shenzhen</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>geopos</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing chongqing<span class="comment">#获取指定城市的经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>geodist</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city chongqing xian<span class="comment">#获取重庆 西安之间的距离</span></span><br><span class="line"><span class="string">&quot;575046.9885&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city chongqing xian km<span class="comment">#获取重庆 西安之间的距离 km</span></span><br><span class="line"><span class="string">&quot;575.0470&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>我附近的人？（获得所有附近的人的地址，定位）通过半径来查询</p><p>georadius:以给定的经纬度为中心，查询某一半径内的元素</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km<span class="comment">#以经纬度110 30 为中心寻找方圆1000km的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord<span class="comment">#把经纬度一块查出来</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 1<span class="comment">#限制查询多少个</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>georadiusbymember :以给定的元素为中心，寻找</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city shanghai 300 km<span class="comment">#找出以上海为中心，300km内的城市</span></span><br><span class="line">1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>geo 底层的实验原理其实就是zset，我们可以使用zset命令来操作geo!</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1<span class="comment">#查看地图中全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing<span class="comment">#移除特定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><hr><h5 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h5><blockquote><p>什么是基数？</p></blockquote><p>A{1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（不重复的元素） &#x3D; 5，可以接受误差。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd myset a b c d e f g h i j<span class="comment">#创建第一组元素myset</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount myset<span class="comment">#统计myset元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; pfadd myset2 i j k z x c v b n m<span class="comment">#创建第二组元素myset2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount myset2</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey3 myset myset2<span class="comment">#合并两个元素 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br></pre></td></tr></table></figure><p>如果允许容错，可以使用hyperloglog;如果不允许容错，使用set</p><hr><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><blockquote><p>位存储</p></blockquote><p>统计疫情感染人数：0 1 0 1</p><p>统计用户信息，活跃，不活跃！登录，未登录！两个状态的都可以使用bitmaps</p><p>Bitmaps位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态！</p><p>365天&#x3D; 365 bit    1字节&#x3D; 8 bit  46个字节左右</p><p>使用bitmap记录周一到周日的打卡！</p><p>周一：1  周二 ：0  周三 0  周四：1 ………</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210604222909632.png" alt="image-20210604222909632"></p><p>查看某一个是否有打卡：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>统计操作，统计打卡的天数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign 0 3  <span class="comment">#查看0-3天的打卡记录（可以忽略最后两个参数）</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>要么同时成功，要么同时失败，原子性！</p><p><strong>redis单条命令是保证原子性的，但redis的事务是不保证原子性的！</strong></p><p>redis事务本质：一组命令的集合！一个事务中的所有米杠零都会被序列化，在事务执行国策和观念中，会按照顺序执行！</p><p>一次性、顺序性、排他性！</p><p><strong>redis没有隔离级别的概念</strong></p><p>所有的命令在食物中，并没有直接被执行！只有发起执行名命令的之后才会执行！Exec</p><p>redis的事务：</p><ul><li>开启事务（）</li><li>命令入队（）</li><li>执行事务（）</li></ul><blockquote><p>正常执行事务：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1<span class="comment">#命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard<span class="comment">#放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4<span class="comment">#事务队列中的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>编译型异常（代码有问题！命令有错！），事务中所有的命令都不会被执行!</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; getset k3<span class="comment">#错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务报错</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="comment">#所有的命令都没有执行</span></span><br></pre></td></tr></table></figure><blockquote><p>运行时异常（1&#x2F;0)，如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1<span class="comment">#执行的时候会失败</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range<span class="comment">#虽然第一条命令报错了，但是依旧执行成功了</span></span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>监控！Watch</p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，什么时候都会出问题，无论什么时候都会加锁</li></ul><p><strong>乐观锁</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据，version！</li><li>获取version</li><li>更新的时候比较version</li></ul><blockquote><p> Redis的监视测试</p></blockquote><p>正常执行成功！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#事务正常结束，数据期间没有发生变动，这个时候就正常执行成功</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>测试多线程修改值，使用watch可以当作redis的乐观锁操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment">#监视 money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行之前 ，另一个线程，修改了money,这个时候，就会导致事务执行失败。</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><hr><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>我们要使用java来操作redis</p><blockquote><p>jedis是redis官方推荐的Java连接开发工具！使用Java操作redis的中间件</p></blockquote><p>1、导入对应的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  导入jedis包  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   fastjson     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编码测试：</p><ul><li>连接数据库</li><li>操作命令</li><li>断开连接</li></ul><hr><h4 id="Springboot整合"><a href="#Springboot整合" class="headerlink" title="Springboot整合"></a>Springboot整合</h4><p>Springboot操作数据：spring-data  jpa  jdbc  mongodb  redis</p><p>springdata也是和springboot齐名的项目</p><p>说明：在springboot2.x后，原来使用的jedis被替换为了lettuce</p><p>jedis:采用直连，多个线程操作的话，是不安全的，如果想要避免，使用jedis pool连接池。更像BIO模式</p><p>lettuce:采用netty，实例可以在多个线程中共享，不存在不安全的情况，减少线程数量。更像NIO模式。</p><blockquote><p>整合测试</p></blockquote><hr><h4 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h4><hr><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><p>redis是内存数据库，如果不保存到磁盘那么一旦服务器进行退出，服务器中的数据库状态也会消失，所以redis提供了持久化的功能！</p><h5 id="rdb（redis-database"><a href="#rdb（redis-database" class="headerlink" title="rdb（redis database)"></a>rdb（redis database)</h5><blockquote><p>什么是rdb</p><p>在rdb中是做备份的。</p></blockquote><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605220814251.png" alt="image-20210605220814251"></p><p>在指定的时间间隔内将内存中的数据集体快照写入磁盘，也就是行话说的Snapshot快照，他恢复时是将快照文件直接读到内存里</p><p>Redis会单独创建（fork）一子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模的数据回复，且对于数据恢复的完整性不是非常铭感，那么RDB方式要比AOF方式更加的搞笑。RDB的缺点是最后一个持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。</p><p><strong>rdb保存的文件就是dump.rdb</strong>，都是再配置文件的快照中配置的。</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605215959106.png" alt="image-20210605215959106"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605220113199.png" alt="image-20210605220113199"></p><blockquote><p>触发机制</p></blockquote><p>1.save的规则满足的情况下，会自动触发rdb规则</p><p>2.执行flushall命令，也会触发rdb规则</p><p>3.退出redis,也会产生rdb文件</p><p>备份就自动生成一个dump.rdb文件</p><blockquote><p>如何恢复rdb文件</p></blockquote><p>1.将rdb文件放在redis启动目录下，redis启动的时候就会自动检测dump.rdb文件，恢复其中的数据！</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605220725190.png" alt="image-20210605220725190"></p><p>优点：</p><p>1.适合大规模的数据恢复</p><p>2.对数据的完整性不高！</p><p>缺点：</p><p>1.需要一定的时间间隔进行操作。如果redis意外宕机了，这个最后一个修改的数据就没有了</p><p>2.frok进程的时候，会占用一定的内存。</p><h5 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h5><p>将我们的所有命令都记录下来，history,恢复的时候就把这个文件都执行一遍。</p><blockquote><p>是什么</p></blockquote><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605221159230.png" alt="image-20210605221159230"></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有执行记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话根据日志文件的内容将写质量从前到后执行一次完成数据的恢复工作。</p><p><strong>AOF保存的是appendonly.aof文件</strong></p><blockquote><p>append</p></blockquote><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605221453938.png" alt="image-20210605221453938"></p><p>默认是不开启的，首要手动进行配置。只需要将图片中的no改成yes即可。</p><p>重启，redis就可以生效了</p><p>如果这个aof文件有错误，这时候，redis是启动不起来的，我们需要修复这个aof文件。</p><p>redis给提供了一个工具<strong>redis-check-aof –fix</strong></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605221951633.png" alt="image-20210605221951633"></p><p>如果文件正常，重启就可以直接恢复</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605222035669.png" alt="image-20210605222035669"></p><blockquote><p>重写的说明</p></blockquote><p>aof默认就是文件的无限追加，文件会越来越大</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605222459699.png" alt="image-20210605222459699"></p><p>如果文件大于64mb,就会fork一个新进程，来存储。</p><blockquote><p>优点和缺点</p></blockquote><p>优点：</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605222146491.png" alt="image-20210605222146491"></p><ul><li>每一次修改都同步，文件的完成行会更好。</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高。</li></ul><p>缺点</p><ul><li>相对于数据文件来说，aof远远大于rdb,修复的速度比rdb慢</li><li>aof运行效率要比rdb慢，所以redis默认是rdb持久化</li></ul><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605222653878.png" alt="image-20210605222653878"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605222710992.png" alt="image-20210605222710992"></p><hr><h4 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h4><p>Redis发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者(sub)接收消息。微信、微博、关注系统</p><p>Redis客户端可以订阅任意数量的频道。</p><p>订阅&#x2F;发布消息图：</p><p>第一个：消息发送者，第二个：i难道  第三个：消息订阅者</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605222937453.png" alt="image-20210605222937453"></p><p>下图展示了频道channel1,以及订阅这个批到的三个客户端    cliend2  client5  client1之间的关系：</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605223110336.png" alt="image-20210605223110336"></p><p>当有新消息通过PUBLISH命令发送给频道channel1是，这个消息就会被发送给订阅他的三个客户端：</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605223151668.png" alt="image-20210605223151668"></p><blockquote><p>命令</p></blockquote><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605223221923.png" alt="image-20210605223221923"></p><blockquote><p>测试</p></blockquote><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605223513325.png" alt="image-20210605223513325"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605223555029.png" alt="image-20210605223555029"></p><p>使用场景：</p><ul><li>实时消息系统</li><li>实时聊天（频道当作聊天室，将信息回显给所有人）</li><li>订阅，关注系统</li></ul><p>稍微复杂的场景就会使用消息中间件做。</p><hr><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605224004576.png" alt="image-20210605224004576"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605224158394.png" alt="image-20210605224158394"></p><p><img src="C:\Users\user\Desktop\image-20210605223945161.png" alt="image-20210605223945161"></p><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@wang bin]<span class="comment"># cd /usr/local/bin/</span></span><br><span class="line">[root@wang bin]<span class="comment"># redis-server myconfig/redis.conf </span></span><br><span class="line">[root@wang bin]<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication<span class="comment">#查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#角色  master</span></span><br><span class="line">connected_slaves:0<span class="comment">#没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:2854ce507ff1f9aff323997061d3b23625d6630f</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>复制三个配置文件，然后修改对应的信息：</p><ul><li>端口</li><li>pid名字</li><li>log文件名字</li><li>dump.rdb名字</li></ul><p>修改完毕之后启动3个服务，可以通过进程查看。</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210605225646549.png" alt="image-20210605225646549"></p><h5 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h5><p><strong>默认情况下，每台Redis服务器都是主节点；</strong>一般情况下配置从机就好</p><p>认老大！一主（79）二从（80，81）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379<span class="comment">#配置为从机</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave<span class="comment">#当前角色</span></span><br><span class="line">master_host:127.0.0.1<span class="comment">#主机的信息</span></span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1c57c3653aeea15421b2823d167bafeb33328320</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"><span class="comment">#主机信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=224,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=224,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1c57c3653aeea15421b2823d167bafeb33328320</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:224</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:224</span><br></pre></td></tr></table></figure><p>真实的配置应该在配置文件中进行配置。</p><blockquote><p>细节</p></blockquote><p>主机可以写，从机布恩那个写只能读。主机的所有数据，都会被从机自动保存。</p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606123842636.png" alt="image-20210606123842636"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606124414757.png" alt="image-20210606124414757"></p><h4 id="哨兵模式（自动选举老大的模式）"><a href="#哨兵模式（自动选举老大的模式）" class="headerlink" title="哨兵模式（自动选举老大的模式）"></a>哨兵模式（自动选举老大的模式）</h4><hr><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606124522477.png" alt="image-20210606124522477"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606124552896.png" alt="image-20210606124552896"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606124640481.png" alt="image-20210606124640481"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606124712184.png" alt="image-20210606124712184"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606125014448.png" alt="image-20210606125014448"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606125528056.png" alt="image-20210606125528056"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606125421955.png" alt="image-20210606125421955"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606125552003.png" alt="image-20210606125552003"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606125658591.png" alt="image-20210606125658591"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606125811111.png" alt="image-20210606125811111"></p><hr><h4 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h4><h5 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h5><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606130057642.png" alt="image-20210606130057642"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606130334389.png" alt="image-20210606130334389"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606130406045.png"></p><h5 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h5><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606130504240.png" alt="image-20210606130504240"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606130645085.png" alt="image-20210606130645085"></p><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606130812505.png" alt="image-20210606130812505"></p><p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210606131018633.png" alt="image-20210606131018633"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2022/05/17/linux/linux/"/>
      <url>/2022/05/17/linux/linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2022/05/17/mysql/mysql/"/>
      <url>/2022/05/17/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL基本架构"><a href="#一、MySQL基本架构" class="headerlink" title="一、MySQL基本架构"></a>一、MySQL基本架构</h2><h3 id="1、MySQL介绍"><a href="#1、MySQL介绍" class="headerlink" title="1、MySQL介绍"></a>1、MySQL介绍</h3><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong>开源免费，默认端口号是<strong>3306</strong>。</p><p>是一个<strong>单进程多线程</strong>数据库</p><blockquote><p><strong>SQL</strong>：<strong>结构化查询语言</strong>，是一种数据库查询语言，用于<strong>对数据库进行增删改查</strong>等操作；</p><p><strong>数据库</strong>：物理操作系统文件或其他形式文件类型的集合 </p><p><strong>实例：</strong>MySQL数据库有后台线程以及一个共享内存区组成，数据库实例才是操作数据库文件的，在系统上的表现就是一个进程</p><p><strong>关系型数据库：</strong>是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一列就存放着一条数据（比如一个用户的信息）。</p></blockquote><h3 id="2、MySQL的客户端-x2F-服务器架构"><a href="#2、MySQL的客户端-x2F-服务器架构" class="headerlink" title="2、MySQL的客户端&#x2F;服务器架构"></a>2、MySQL的客户端&#x2F;服务器架构</h3><p>MySQL是一个<strong>客户端&#x2F;服务器架构</strong></p><blockquote><p>日常使用场景如下：</p><p>1、启动MySQL服务器程序</p><p>2、启动MySQL客户端程序</p><p>3、在客户端程序输入命令语句请求发到服务器端，服务器端根据请求内容处理请求并向客户端返回处理结果</p></blockquote><p><strong>客户端进程向服务器进程</strong>发送请求并得到回复的过程本质上是一个<strong>进程间通信的过程</strong>，MySQL支持三种进程间通信方式：</p><ul><li><p><strong>TCP&#x2F;IP</strong>（服务器与客户端不在同一主机中必须用）</p><p>TCP&#x2F;IP套接字方式是任何平台均提供的最常用方式</p></li><li><p><strong>命名管道和共享内存</strong>（windows环境可以用）</p></li><li><p><strong>Unix域套接字文件</strong>（类Unix环境可以用）</p></li></ul><h3 id="3、MySQL的逻辑架构（一条查询语句是如何执行的）"><a href="#3、MySQL的逻辑架构（一条查询语句是如何执行的）" class="headerlink" title="3、MySQL的逻辑架构（一条查询语句是如何执行的）"></a>3、MySQL的逻辑架构（一条查询语句是如何执行的）</h3><p>MySQL的逻辑架构如下：大致分为<strong>Server层和存储引擎层</strong></p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等；<strong>存储引擎层负责数据的存储和提取。其架构模式是插件式</strong>的，支持 InnoDB（默认）、MyISAM、Memory 等多个存储引擎。</p><img src="images/image-20210516155741654.png" alt="image-20210516155741654" style="zoom:80%;" /><h4 id="（1）连接器"><a href="#（1）连接器" class="headerlink" title="（1）连接器"></a>（1）<strong>连接器</strong></h4><p>负责<strong>与客户端建立连接、获取权限、维持和管理连接</strong>，在完成经典的 TCP 握手后，连接器就要开始认证你的身份（用户名和密码），若正确，回到<strong>权限表查出你拥有的权限</strong>。</p><blockquote><p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。</p></blockquote><p>连接完成后若长时间空闲，默认是8小时，连接器会自行与客户端断开连接。</p><p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则<strong>一直使用同一个连接</strong>。<strong>短连接</strong>则是指每次<strong>执行完很少的几次查询就断开</strong>连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<strong>建议尽量使用长连接</strong>。</p><blockquote><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉，从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol></blockquote><h4 id="（2）查询缓存（8-0版本已删掉）"><a href="#（2）查询缓存（8-0版本已删掉）" class="headerlink" title="（2）查询缓存（8.0版本已删掉）"></a>（2）<strong>查询缓存</strong>（8.0版本已删掉）</h4><p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果能在缓存中找到 key，即查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>多数情况下会建议不要使用查询缓存</strong></p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了<strong>额外的开销：每次查询后都要做一次缓存操作，失效后还要销毁</strong>。</p><p>查询缓存的失效非常频繁，<strong>只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。对于更新压力大的数据库来说，查询缓存的命中率会非常低。<strong>除非你的业务就是有一张静态表（例如系统配置表）</strong>，很长时间才会更新一次。</p><h4 id="（3）分析器"><a href="#（3）分析器" class="headerlink" title="（3）分析器"></a>（3）<strong>分析器</strong></h4><p>MySQL 需要知道你要做什么，因此需要对 <strong>SQL 语句做解析</strong>。</p><p>首先做“<strong>词法分析”，识别出字符串的内容分别代表什么</strong>；其次做“<strong>语法分析</strong>”，判断输入的这个 SQL 语句<strong>是否满足 MySQL 语法</strong>。</p><h4 id="（4）优化器"><a href="#（4）优化器" class="headerlink" title="（4）优化器"></a>（4）<strong>优化器</strong></h4><p>MySQL需要知道该怎么做。</p><p>优化的结果就是<strong>生成一个执行计划</strong>，这个执行计划表明了<strong>应该使用哪些索引进行查询，表之间的连接顺序是啥样的</strong>。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划</p><h4 id="（5）执行器"><a href="#（5）执行器" class="headerlink" title="（5）执行器"></a>（5）<strong>执行器</strong></h4><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，<strong>开始执行语句</strong>。</p><p>开始执行的时候，要先判断一下你对这个表<strong>有没有执行查询的权限</strong>，若有则<strong>调用存储引擎查询结果并将结果集返回给客户端</strong></p><h3 id="4、日志系统（一条更新语句如何执行）"><a href="#4、日志系统（一条更新语句如何执行）" class="headerlink" title="4、日志系统（一条更新语句如何执行）"></a>4、日志系统（一条更新语句如何执行）</h3><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和bin log（归档日志）</p><h4 id="（1）redo-log（重做日志）"><a href="#（1）redo-log（重做日志）" class="headerlink" title="（1）redo log（重做日志）"></a>（1）redo log（重做日志）</h4><p>MySQL更改数据的时候，之所以不直接写磁盘文件中的数据，主要因为<strong>直接写磁盘文件是随机写</strong>，开销大性能低。所以先在内存中对数据进行更改，再由后台线程<strong>异步刷新到磁盘</strong>（一般等空闲时）。为<strong>防止断电重启丢失内存内容</strong>，所以还需要加上写日志这个步骤，万一断电重启，还能通过日志中的记录进行恢复。</p><p><strong>写日志到磁盘是顺序写</strong>，相比随机写开销更小，能提升语句执行的性能</p><p>这个技术就是<strong>WAL(Write Ahead Log)技术</strong>，也称为<strong>日志先行</strong>的技术，指的是对数据文件进行修改前，必须将修改先记录日志。保证了数据<strong>一致性</strong>和<strong>持久性</strong>，并且提升语句执行性能。</p><p>有了 redo log，事务提交过程中任何阶段，MySQL突然奔溃，<strong>重启后都能保证事务的持久性，已提交的数据不会丢失</strong>，这个能力称为<strong>crash-safe</strong>。</p><p>redo log记录的是数据库中<strong>每个页的修改</strong>，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页（恢复数据页，只能恢复到最后一次提交的位置，因为修改会覆盖之前的）。</p><p>redo log<strong>固定大小</strong>，只能<strong>循环写</strong>，从头开始写，写到末尾就又回到开头，<strong>相当于一个环形</strong>。当日志写满了，就需要对<strong>旧的记录进行擦除</strong>，但在擦除之前，需要确保这些要被擦除记录对应在内存中的数据页都已经刷到磁盘中了。在redo log满了到擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求，所以有可能会导致MySQL卡顿。（所以针对<strong>并发量大的系统</strong>，适当设置<strong>redo log的文件大小非常重要</strong>）</p><h4 id="（2）bin-log（归档日志）"><a href="#（2）bin-log（归档日志）" class="headerlink" title="（2）bin log（归档日志）"></a>（2）bin log（归档日志）</h4><p>binlog（归档日志）是MySQL的 Server 层的日志 ，主要记录用户对<strong>数据库操作的SQL语句</strong>（除了查询语句），之所以称为归档日志，是因为不想redo log会擦掉之前的记录而是一直记录，主要用作<strong>主从同步</strong>和数据库<strong>基于某时间点的还原</strong>。（即主从模式下是必须的，若单机模式下，可视情况而定）</p><p>这两种日志有以下三点不同。</p><ol><li><strong>redo log 是 InnoDB 引擎</strong>特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是<strong>物理日志</strong>，记录的是“在<strong>某个数据页上做了什么修改</strong>”；binlog 是<strong>逻辑日志</strong>，记录的是这个<strong>语句的原始逻辑</strong>，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>两种日志<strong>写入磁盘的时间点</strong>不同，redolog在事务进行中不断地被顺序写入，而binlog只在事务提交时写入一次。</li><li><strong>redo log 是循环写的，空间固定会用完</strong>；binlog 是可以追加写入的。<strong>“追加写</strong>”是指 binlog 文件写到一定大小后会切换到下一个，并<strong>不会覆盖以前的日志</strong>。</li></ol><p><strong>MySQL能够恢复到任意时间点的状态就是依赖binlog实现</strong></p><blockquote><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul></blockquote><h4 id="（3）为什么bin-log没有crash-safe"><a href="#（3）为什么bin-log没有crash-safe" class="headerlink" title="（3）为什么bin log没有crash-safe"></a>（3）为什么bin log没有crash-safe</h4><p>当数据库 crash 后，想要恢复<strong>未刷盘但已经写入 redo log 和 binlog 的数据</strong>到内存时，binlog 是无法恢复的。虽然 <strong>binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有</strong>。而 redo log 不一样，<strong>只要刷入磁盘的数据，都会从 redo log 中抹掉</strong>，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</p><blockquote><p>举个栗子，binlog 记录了两条日志：</p><p>给 ID&#x3D;2 这一行的 c 字段加1<br>给 ID&#x3D;2 这一行的 c 字段加1</p><p>在记录1刷盘后，记录2未刷盘时，数据库 crash。重启后，只通过 binlog 数据库无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘</p></blockquote><h4 id="（4）undo-log回滚日志"><a href="#（4）undo-log回滚日志" class="headerlink" title="（4）undo log回滚日志"></a>（4）undo log回滚日志</h4><p>主要就是提供了<strong>回滚</strong>的作用，但其还有另一个主要作用，就是<strong>多版本并行控制(MVCC)，保证事务的原子性</strong>。在数据修改的流程中，会记录一条与<strong>当前操作相反的逻辑日志到undo log</strong>中（可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录），如果因为某些原因导致事务异常失败了，可以借助该undo log进行回滚，保证事务的原子性，所以undo log也必不可少。</p><h4 id="（5）update语句的更新流程"><a href="#（5）update语句的更新流程" class="headerlink" title="（5）update语句的更新流程"></a>（5）update语句的更新流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><ol><li><strong>执行器先找引擎取 ID&#x3D;2 这一行</strong>。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器<strong>拿到引擎给的行数据</strong>，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，<strong>再调用引擎接口写入这行新数据</strong>。</li><li>引擎<strong>将这行新数据更新到内存中</strong>，同时将这个更新操作<strong>记录到 redo log</strong> 里面，此时 redo log 处于 <strong>prepare 状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器<strong>生成这个操作的 binlog，并把 binlog 写入磁盘</strong>。</li><li>执行器调用引擎的<strong>提交事务接口</strong>，引擎把刚刚写入的 <strong>redo log 改成提交（commit）状态</strong>，更新完成。</li></ol><img src="images/image-20210518132954825.png" alt="image-20210518132954825" style="zoom:67%;" /><p>图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><h4 id="（6）两阶段提交"><a href="#（6）两阶段提交" class="headerlink" title="（6）两阶段提交"></a>（6）两阶段提交</h4><p><strong>为什么redo log要分两步写，中间再穿插写binlog呢？</strong>可用反证法</p><blockquote><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol></blockquote><p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><h3 id="5、存储引擎"><a href="#5、存储引擎" class="headerlink" title="5、存储引擎"></a>5、存储引擎</h3><p>MySQL服务器把<strong>数据的存储和提取操作</strong>都封装到了一个叫存储引擎的模块里。</p><p>MySQL 的server层在完成<strong>查询优化后，执行器只需要按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端</strong>。</p><p>注意：<strong>存储引擎是基于表的，而不是数据库</strong>。</p><p>常用存储引擎：</p><ul><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><h4 id="（1）InnoDB存储引擎简介"><a href="#（1）InnoDB存储引擎简介" class="headerlink" title="（1）InnoDB存储引擎简介"></a>（1）InnoDB存储引擎简介</h4><p>MySQL默认的<strong>事务型</strong>存储引擎，支持<strong>行锁</strong>，支持<strong>外键</strong>，通过使用多版本并发控制（<strong>MVCC</strong>）来获得高并发性，并实现了SQL标准的四种隔离级别，默认为REPEATABLE级别，同时使用一种<strong>Next-Key Locking防止幻读</strong>。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><p>此外还提供了<strong>插入缓冲</strong>（Insert buffer）、<strong>二次写</strong>（double write）、<strong>自适应哈希索引</strong>（Adaptive hash index）、<strong>预读</strong>（read ahead）等高性能高可用的功能。</p><p>InnoDB存储引擎将数据放在一个逻辑的<strong>表空间</strong>中，4.1版本开始后，可以将每个该引擎的表放在一个<strong>独立的ibd文件</strong>中。</p><p>对表中数据的存储，采用了<strong>聚集</strong>（cluster）的方法，每张表的存储都是按<strong>主键顺序存放</strong>（若无显示定义主键或唯一键，则会生成一个隐藏列rowid，以此为主键）</p><h4 id="（2）MyISAM存储引擎简介"><a href="#（2）MyISAM存储引擎简介" class="headerlink" title="（2）MyISAM存储引擎简介"></a>（2）MyISAM存储引擎简介</h4><p>不支持事务、行锁、外键</p><p>在表读取时，也可以往表中插入新的记录，称为并发插入</p><p>MyISAM存储引擎表由MYD和MYI组成，M<strong>YD存放数据文件，MYI存放索引文件</strong>。</p><p>与大多数数据库不同的是它的缓<strong>冲池只缓存索引文件，不缓冲数据文件</strong></p><h4 id="（3）MyISAM和InnoDB的区别"><a href="#（3）MyISAM和InnoDB的区别" class="headerlink" title="（3）MyISAM和InnoDB的区别"></a>（3）MyISAM和InnoDB的区别</h4><p>以下五点，前者均不支持，后者均支持</p><ul><li><p>是否支持<strong>事务</strong></p></li><li><p>是否支持<strong>行锁</strong></p><p>MyISAM、MEMORY等<strong>只支持表锁</strong>，，而且同一时刻只允许一个用户对表进行写操作，所以这些引擎最好用在只读或大部分读或单用户的情景下，不适合并发场景</p></li><li><p>是否支持<strong>MVCC</strong></p></li><li><p>是否支持<strong>外键</strong></p><p>一般也不建议在数据库层面使用外键的，应用层面可以解决，根据项目而定</p></li><li><p>是否支持<strong>数据库异常崩溃后的安全恢复</strong></p><p>依赖于 <code>redo log</code></p></li></ul><blockquote><ul><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的<strong>隔离性</strong>（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul></blockquote><h4 id="（4）设置、修改表的存储引擎"><a href="#（4）设置、修改表的存储引擎" class="headerlink" title="（4）设置、修改表的存储引擎"></a>（4）设置、修改表的存储引擎</h4><p><strong>设置表的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名&#123;</span><br><span class="line">建表语句</span><br><span class="line">&#125;ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><p><strong>修改表的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h3 id="6、MySQL字符集"><a href="#6、MySQL字符集" class="headerlink" title="6、MySQL字符集"></a>6、MySQL字符集</h3><h4 id="（1）字符集"><a href="#（1）字符集" class="headerlink" title="（1）字符集"></a>（1）字符集</h4><p>计算机中只能存储二进制数据，为存储字符串数据，需要建立字符与二进制数据的映射关系（解码和编码），人们抽象出一个字符集的概念描述某个字符范围内的编码规则</p><h4 id="（2）常用字符集"><a href="#（2）常用字符集" class="headerlink" title="（2）常用字符集"></a>（2）常用字符集</h4><ul><li><p>ASCII字符集</p><p>收录128个字符，所以可用1字节来编码</p></li><li><p>ISO 8859-1字符集</p><p>收录256个字符，前者的扩充，可用1字节编码</p></li><li><p>GB2312字符集</p><p>收录了汉字等，兼容ASCII字符集，若该字符在ASCII字符集中，则1字节编码，否则2字节编码，即变长编码方式</p></li><li><p>GBK字符集</p><p>前者的扩充，编码方式兼容前者，2字节编码</p></li><li><p>UTF-8字符集</p><p>收录地球上能想到的所有字符，而且还在不断扩充。兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用1～4个字节</p><blockquote><p>准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。</p></blockquote></li></ul><h4 id="（3）MySQL支持的字符集"><a href="#（3）MySQL支持的字符集" class="headerlink" title="（3）MySQL支持的字符集"></a>（3）MySQL支持的字符集</h4><p>MySQL中常用utf-8字符集</p><ul><li><p><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</p></li><li><p><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</p></li></ul><p>在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用<code>utf8mb4</code>。</p><h3 id="7、MySQL数据类型"><a href="#7、MySQL数据类型" class="headerlink" title="7、MySQL数据类型"></a>7、MySQL数据类型</h3><h4 id="（1）整型"><a href="#（1）整型" class="headerlink" title="（1）整型"></a>（1）整型</h4><blockquote><p>INT(11) 中的<strong>数字只是规定了交互工具显示字符的个数</strong>，对于存储和计算来说是没有意义的。</p></blockquote><p>TINYINT, SMALLINT, MEDIUMINT, <strong>INT</strong>, BIGINT 分别使用 8, 16, 24, <strong>32</strong>, 64 位存储空间，<strong>一般情况下越小的列越好</strong>。</p><h4 id="（2）浮点数"><a href="#（2）浮点数" class="headerlink" title="（2）浮点数"></a>（2）浮点数</h4><p><strong>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型</strong>。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 <strong>DECIMAL 的计算比浮点类型需要更高的代价</strong>。</p><p>FLOAT占用4个字节，DOUBLE占用8个字节；</p><h4 id="（3）字符串"><a href="#（3）字符串" class="headerlink" title="（3）字符串"></a>（3）字符串</h4><blockquote><p>VARCHAR(50)：50表示最多存放50个字符；VARCHAR最多存放65532个字符</p><p>CHAR(50)：50表示存放50个字符，不足就用空格补齐；CHAR最多存放255个字符</p></blockquote><p>主要有 <strong>CHAR</strong> 和 <strong>VARCHAR</strong> 两种类型，一种是<strong>定长的</strong>，一种是<strong>变长的</strong>。还有TEXT、BLOB</p><p><strong>VARCHAR 这种变长类型能够节省空间</strong>，因为只需要存储必要的内容。但是在执行 <strong>UPDATE 时可能会使行变得比原来长</strong>，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行<strong>拆成不同的片段</strong>存储，而 InnoDB 则需要<strong>分裂页</strong>来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h4 id="（4）时间和日期"><a href="#（4）时间和日期" class="headerlink" title="（4）时间和日期"></a>（4）时间和日期</h4><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><p><strong>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</strong>切忌使用字符串存储日期（占用空间大，比较效率低，无法用日期相关的API）</p><h5 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h5><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 <strong>8 字节</strong>的存储空间。它是<strong>时区无关的</strong>。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h5 id="TIMESTAMP（推荐）"><a href="#TIMESTAMP（推荐）" class="headerlink" title="TIMESTAMP（推荐）"></a>TIMESTAMP（推荐）</h5><p><strong>和 UNIX 时间戳相同</strong>，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的<strong>秒数</strong>，使用 <strong>4 字节</strong>，只能表示从 1970 年到 2038 年。</p><p><strong>它和时区有关</strong>，也就是说<strong>一个时间戳在不同的时区所代表的具体时间是不同的</strong>。</p><p>MySQL 提供了 FROM_UNIXTIME() <strong>函数把 UNIX 时间戳转换为日期</strong>，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>若插入时未指定 TIMESTAMP 列的值，会将这个值<strong>默认设置为当前时间</strong>。</p><h3 id="8、数据库设计三大范式"><a href="#8、数据库设计三大范式" class="headerlink" title="8、数据库设计三大范式"></a>8、数据库设计三大范式</h3><h4 id="（1）第一范式"><a href="#（1）第一范式" class="headerlink" title="（1）第一范式"></a>（1）第一范式</h4><p>1NF是对属性的<strong>原子性</strong>，要求属性具有原子性，每一列必须是不可分割的最小单元</p><blockquote><p>不能把多个列组合成一个列，比如把邮箱和手机号合为一个列就是不满足第一范式；</p><p>同时也不能把已是不可分割的原子列再进行拆分；</p></blockquote><h4 id="（2）第二范式"><a href="#（2）第二范式" class="headerlink" title="（2）第二范式"></a>（2）第二范式</h4><p>在满足1NF的基础上，2NF是对记录的<strong>唯一性</strong>，要求<strong>记录有唯一标识</strong>，也就是<strong>要有主键，其他字段都完全依赖于主键，不能只与主键的某一部分相关</strong>（针对联合主键来说）。</p><p><strong>在通俗来讲就是一个数据库表中只能保存一种对象的信息，如果属于这个对象的属性就可以放进来，不属于就不能放进来。不可以把多种对象的数据保存在同一张数据库表中</strong></p><blockquote><p>表：学号、课程号、姓名、学分；</p><p>这个表保存了两种对象的数据:学生信息, 课程信息；这里<strong>学分依赖课程号</strong>，<strong>姓名依赖于学号</strong>，所以不符合二范式。</p><p>正确做法:<br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p></blockquote><h4 id="（3）第三范式"><a href="#（3）第三范式" class="headerlink" title="（3）第三范式"></a>（3）第三范式</h4><p><strong>不能有冗余信息</strong>，<strong>数据表中的每个字段都和主键直接相关，而不能间接相关</strong>，<strong>不能存在传递依赖关系</strong></p><p><strong>通俗来讲，比如一个表描述的这个对象里引用了另一个对象，那么没必要把另一个对象的全部属性都加进来，只需要把它的主键放进来就足够了。</strong></p><blockquote><p>比如一个表: 学号, 姓名, 学院, 学院电话</p><p>这个表存在一种传递依赖关系，学院电话依赖于学院，学院依赖于学号，也就是学院电话并不是直接依赖于学号</p></blockquote><p>如果不满足第三范式的话会有重复冗余的信息，修改时需要同时修改多条记录，否则就会出现<strong>数据不一致的情况</strong> 。</p><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 学院)；</p><p>学院：(学院, 学院电话)。</p><h2 id="二、InnoDB存储引擎"><a href="#二、InnoDB存储引擎" class="headerlink" title="二、InnoDB存储引擎"></a>二、InnoDB存储引擎</h2><h3 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h3><p>后台线程的主要作用是<strong>刷新内存池中的数据，保证缓冲池数据都是最新的数据</strong>；将<strong>已修改的数据文件刷新到磁盘</strong>；<strong>保证数据库发生异常崩溃后，能将数据恢复；</strong></p><h4 id="（1）Master-Thread"><a href="#（1）Master-Thread" class="headerlink" title="（1）Master Thread"></a>（1）Master Thread</h4><p>核心后台线程，保证将缓冲池中的数据异步刷新到磁盘，保证数据的一致性（脏页刷新、合并插入缓冲、undo页回收）</p><h4 id="（2）IO-Thread"><a href="#（2）IO-Thread" class="headerlink" title="（2）IO Thread"></a>（2）IO Thread</h4><p>因为大量使用了AIO（Async  IO）处理写请求，该线程负责这些IO请求的回调处理</p><h4 id="（3）Purge-Thread"><a href="#（3）Purge-Thread" class="headerlink" title="（3）Purge Thread"></a>（3）Purge Thread</h4><p>事务被提交后。undo日志可能不再需要，该线程负责回收已经使用并分配的undo页</p><h4 id="（4）Page-Cleaner-Thread"><a href="#（4）Page-Cleaner-Thread" class="headerlink" title="（4）Page Cleaner Thread"></a>（4）Page Cleaner Thread</h4><p>1.2版本引入，将脏页刷新工作放到该线程处理，减轻Master Thread的压力</p><h3 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h3><h4 id="（1）缓冲池"><a href="#（1）缓冲池" class="headerlink" title="（1）缓冲池"></a>（1）缓冲池</h4><p><strong>缓冲池是一块内存区域，用来弥补CPU与磁盘速度之间的鸿沟</strong>。缓冲池缓存的数据页类型：数据页、索引页、undo页、插入缓冲、自适应哈希索引等等，绝非只有数据页和索引页。</p><h4 id="（2）LRU-List-、Free-List和Flush-List"><a href="#（2）LRU-List-、Free-List和Flush-List" class="headerlink" title="（2）LRU List 、Free List和Flush List"></a>（2）LRU List 、Free List和Flush List</h4><p>缓冲池通过<strong>LRU算法</strong>来进行管理，<strong>频繁使用</strong>的页放在LRU列表的<strong>前端</strong>，首先<strong>释放末尾的页</strong>，页大小默认16KB</p><p>InnoDB的LRU算法对传统算法做了<strong>优化</strong>，再LRU列表中加入了<strong>midpoint位置</strong>，新读取的页并非放入首端，而是放在midpoint位置（默认在LRU列表尾部37%的位置，差不多<strong>3&#x2F;8</strong>）。该位置前面称作<strong>new列表（热数据），后面为old列表（冷数据）</strong>。</p><blockquote><p>主要是为了<strong>避免某些操作例如扫描操作，需要访问许多页甚至全部的页</strong>，这些页通常只在本次操作中需要，并非活跃的热数据，而如果直接放入首部，势必会让LRU列表大换血，导<strong>致真正的热点数据被挤出</strong></p></blockquote><p>此外，还引入另一个参数表示页读取到该位置后，需要等待多久才会被加入热端</p><p>数据刚启动时，LRU列表是空的，此时缓冲池的页都放在<strong>Free列表中</strong>，当<strong>需要缓冲页时</strong>，会从Free表查找是否有<strong>空闲页</strong>，若有，则删除并<strong>加入到LRU列表</strong></p><p><strong>LRU表中的数据页被修改后，称为脏页</strong>，数据库会通过checkpoint机制将其<strong>刷新到磁盘上</strong>，而<strong>Flush列表的页即为脏页</strong>，注意脏页既存在于LRU也存在于Flush中，<strong>Flush列表只是管理将页刷新回磁盘，而非特定用于存储脏页</strong></p><h4 id="（3）重做日志缓冲（redo-log）"><a href="#（3）重做日志缓冲（redo-log）" class="headerlink" title="（3）重做日志缓冲（redo log）"></a>（3）重做日志缓冲（redo log）</h4><p>内存区域除了缓冲池，还有redo log缓冲池，将redo log想放入该区域，之后再异步刷新到重做日志文件。</p><p>刷盘时机：</p><ul><li><strong>master thread以每秒一次</strong>的频率定时刷新</li><li>每个<strong>事务提交时</strong>会刷新</li><li>当该<strong>缓冲池剩余空间小于一半</strong>时刷新</li></ul><h4 id="（4）额外内存池"><a href="#（4）额外内存池" class="headerlink" title="（4）额外内存池"></a>（4）额外内存池</h4><p>在对一些数据结构本身的内存进行分配时，需从额外的内存池中进行申请，当该区域内存不够时，会从缓冲池进行申请</p><h3 id="3、Checkpoint"><a href="#3、Checkpoint" class="headerlink" title="3、Checkpoint"></a>3、Checkpoint</h3><p>checkpoint（检查点）技术的目的是解决以下几个问题：</p><ul><li>缩短数据库的恢复时间</li><li>缓冲池不够用时，将脏页刷新到磁盘</li><li>redo log不可用时，刷新脏页</li></ul><p>当数据库宕机时，无需重做所有的日志，因为checkpoint之前的页都已经刷新回磁盘，故数据库秩序对checkpoint后的重做日志进行恢复即可，缩短恢复时间。</p><h3 id="4、InnoDB的关键特性"><a href="#4、InnoDB的关键特性" class="headerlink" title="4、InnoDB的关键特性"></a>4、InnoDB的关键特性</h3><ul><li><p><strong>插入缓冲</strong></p></li><li><p><strong>两次写</strong></p></li><li><p><strong>自适应哈希索引</strong></p><p>哈希是一种非常快的查找方法，时间复杂度一般为O(1)，一般只需要一次查找就能；而B+树高度一般3~4层，需要3 ~ 4次查找。</p><p>InnoDB存储引擎会监控对表上各索引页的查询。若观察到建立哈希索引可以带来速度提升，则建立哈希索引，称为自适应哈希索引。</p><p>InnoDB会自动根据访问的频率和模式自动地为某些热点页建立哈希索引，它是根据B+树页构造而来，不需要为整张表建立索引。其设计思想是数据库自优化的，无需人为调整</p></li><li><p><strong>异步IO</strong></p><p>用户可以在发送一个请求后立即发送下一个请求，全部请求发送完后，等待IO操作完成即可，AIO可以进行IO Merge操作，将多个IO合并为一个IO。（访问多个连续的页时）</p></li><li><p><strong>刷新临近页</strong></p><p>刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起刷新。与IO Merge绝配。</p></li></ul><h2 id="三、文件"><a href="#三、文件" class="headerlink" title="三、文件"></a>三、文件</h2><h3 id="1、参数文件"><a href="#1、参数文件" class="headerlink" title="1、参数文件"></a>1、参数文件</h3><p>MySQL数据的参数类型：</p><ul><li><p>动态参数</p><p>可以在MySQL实例中进行更改，可通过SET命令更改，关键字session和global分别表示参数修改是基于当前会话还是整个实例的生命周期</p></li><li><p>静态参数</p><p>整个实例的生命周期中不得更改</p></li></ul><h3 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h3><p>常见日志文件有：</p><ul><li>错误日志（err log）</li><li>二进制（归档）日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）</li></ul><h4 id="（1）错误日志"><a href="#（1）错误日志" class="headerlink" title="（1）错误日志"></a>（1）错误日志</h4><p>对MySQL的启动、运行、关闭过程进行了记录。不仅记录了所有错误信息还有一些警告信息或正确信息，DBA遇到问题应首先查看该文件。默认为 ”主机名.err“</p><h4 id="（2）慢查询日志"><a href="#（2）慢查询日志" class="headerlink" title="（2）慢查询日志"></a>（2）慢查询日志</h4><p>帮助DBA定位可能存在问题的SQL语句，进行SQL语句层面的优化，默认关闭</p><h4 id="（3）查询日志"><a href="#（3）查询日志" class="headerlink" title="（3）查询日志"></a>（3）查询日志</h4><p>记录了所有对MySQL数据库请求的信息，默认为“主机名.log”</p><h4 id="（4）二进制（归档）日志"><a href="#（4）二进制（归档）日志" class="headerlink" title="（4）二进制（归档）日志"></a>（4）二进制（归档）日志</h4><p>记录了对MySQL数据库执行更改的所有操作，所以不包括SELECT和SHOW这类操作（该类操作可以查查询日志）。</p><p>该日志默认关闭，开始会损失1%的性能，可以接受。</p><p>未提交的binlog会被记录到一个缓存中，事务提交时将其写入磁盘。</p><p>主要作用：</p><ul><li><strong>恢复</strong>（recovery）：在一个数据库全备文件恢复后，可以通过binlog进行part-in-time的恢复</li><li><strong>复制</strong>（replication）：主从复制</li><li>审计（audit）：判断是否有对数据库进行注入的攻击</li></ul><h3 id="3、表结构定义文件"><a href="#3、表结构定义文件" class="headerlink" title="3、表结构定义文件"></a>3、表结构定义文件</h3><p>每个表都有一个与之对应的frm文件，记录了该表的表结构定义，此外，frm还用来记录视图的定义。</p><h3 id="4、InnoDB存储引擎文件"><a href="#4、InnoDB存储引擎文件" class="headerlink" title="4、InnoDB存储引擎文件"></a>4、InnoDB存储引擎文件</h3><h4 id="（1）表空间文件"><a href="#（1）表空间文件" class="headerlink" title="（1）表空间文件"></a>（1）表空间文件</h4><p>InnoDB采用将存储的数据按照表空间进行存放的设计。默认有个ibdata1的表空间文件，初始10MB，但是是自增文件</p><p>所有记录都会存放在该共享表空间中。此外，用户还可以将每个InnoDB引擎的表产生一个独立表空间：表名.ibd。</p><p>注意：独立表空间仅存储该表的数据、索引和插入缓冲BITMAP等，其余信息依旧在共享表空间</p><h4 id="（2）重做日志文件"><a href="#（2）重做日志文件" class="headerlink" title="（2）重做日志文件"></a>（2）重做日志文件</h4><p>同样是记录事务日志，redolog与binlog有什么不同？</p><ul><li>binlog是MySQl Server层实现的，可以记录所有的MySQL记录，而redolog是InnoDB引擎特有的，只记录有关该引擎的记录</li><li>记录的内容不同，binlog记录的是一个事务的具体操作，是逻辑日志；而redolog记录的是每个页的更改的物理情况，是物理日志</li><li>写入的时间不同，binlog仅在事务提交前提交，不论事务多大，即只写盘一次；而在事务进行的过程中，却不断有重做日志条目写入到重做日志文件中</li><li><strong>redolog 是循环写的，空间固定会用完</strong>；binlog 是可以追加写入的。<strong>“追加写</strong>”是指 binlog 文件写到一定大小后会切换到下一个，并<strong>不会覆盖以前的日志</strong>。</li></ul><h2 id="四、表"><a href="#四、表" class="headerlink" title="四、表"></a>四、表</h2><h3 id="1、索引组织表"><a href="#1、索引组织表" class="headerlink" title="1、索引组织表"></a>1、索引组织表</h3><p>在InnoDB存储引擎中，表<strong>都是根据主键顺序组织存放的</strong>，这种存储方式的表称为<strong>索引组织表</strong>。</p><p>在InnoDB存储引擎的表中，<strong>每个表都有主键</strong>，若未显示的定义主键，则会按下面方式选择或创建主键：</p><ul><li>判断是否有<strong>非空的唯一索引</strong>，有则设为主键</li><li>否则，自行创建一个<strong>隐藏主键row_id</strong></li></ul><h3 id="2、InnoDB逻辑存储结构"><a href="#2、InnoDB逻辑存储结构" class="headerlink" title="2、InnoDB逻辑存储结构"></a>2、InnoDB逻辑存储结构</h3><p>所有数据都被逻辑地存放在一个空间中，称为表空间。表空间由段（segment）、区（extent）、页（page）组成。</p><h4 id="（1）表空间"><a href="#（1）表空间" class="headerlink" title="（1）表空间"></a>（1）表空间</h4><p>前文已介绍，分为共享表空间和独立表空间</p><h4 id="（2）段"><a href="#（2）段" class="headerlink" title="（2）段"></a>（2）段</h4><p>常见的段有数据段、索引段、回滚段等，因为InnoDB<strong>存储引擎表是索引组织的</strong>，因此<strong>数据即索引，索引即数据</strong>，数据段也就是B+树的叶子节点，索引段即B+树的非叶子结点。</p><h4 id="（3）区"><a href="#（3）区" class="headerlink" title="（3）区"></a>（3）区</h4><p>区由<strong>连续的页</strong>组成，一个区为1MB，一个页为16KB，那么一个区由64个连续页</p><blockquote><p>每个段开始时，先用32个页大小的碎片页来存放数据，在使用完碎片页后才是64个连续页的申请，对于一些小表，这样做可以在开始时申请较少的空间，节省磁盘容量开销</p></blockquote><h4 id="（4）页"><a href="#（4）页" class="headerlink" title="（4）页"></a>（4）页</h4><p>InnoDB磁盘管理的最小单位</p><h4 id="（5）行"><a href="#（5）行" class="headerlink" title="（5）行"></a>（5）行</h4><p>数据是按行排列的</p><h3 id="3、InnoDB行记录格式"><a href="#3、InnoDB行记录格式" class="headerlink" title="3、InnoDB行记录格式"></a>3、InnoDB行记录格式</h3><p>两种格式存放行记录数据：</p><ul><li>Compact（默认）</li><li>Redundant</li></ul><h4 id="（1）Compact行记录格式"><a href="#（1）Compact行记录格式" class="headerlink" title="（1）Compact行记录格式"></a>（1）Compact行记录格式</h4><p>设计目标是<strong>高效地存储数据</strong>。一个页中存放地<strong>行数据越多，性能也就越高</strong>。</p><p>固定长度CHAR字段在未能完全占用其长度时，会用0x20进行填充</p><p>不论是CHAR还是VARCHAR，该格式下<strong>NULL值都不占用任何存储空间</strong></p><h4 id="（2）Redundant行记录格式"><a href="#（2）Redundant行记录格式" class="headerlink" title="（2）Redundant行记录格式"></a>（2）Redundant行记录格式</h4><p><strong>CHAR类型的NULL值需要占用空间</strong></p><h4 id="（3）行溢出数据"><a href="#（3）行溢出数据" class="headerlink" title="（3）行溢出数据"></a>（3）行溢出数据</h4><p>InnoDB存储引擎可以<strong>将一条记录的某些数据存在真正的数据页面之外</strong>。</p><p>如果某一列中的数据非常多的话，在本记录的真实数据处只会存储<strong>该列的前768个字节的数据</strong>和一个<strong>指向其他页的地址</strong>，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出<code>768</code>字节的那些页面也被称为溢出页</p><img src="images/image-20210605081536271.png" alt="image-20210605081536271" style="zoom: 67%;" /><blockquote><p>VARCHAR类型最大支持<strong>65535，单位是字节</strong>。</p><p>VARCHAR(N)中的<strong>N指的是字符的长度，并非字节长度</strong>，不同字符集中，字符占用的字节数不一样，即使同一字符集，也不一定一样</p></blockquote><h4 id="（4）Compressed和Dynamic行记录格式"><a href="#（4）Compressed和Dynamic行记录格式" class="headerlink" title="（4）Compressed和Dynamic行记录格式"></a>（4）Compressed和Dynamic行记录格式</h4><p>这俩行格式和<code>Compact</code>行格式挺像，只不过在处理**<code>行溢出</code>数据时有点儿分歧**，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址</p><h3 id="4、InnoDB数据页结构"><a href="#4、InnoDB数据页结构" class="headerlink" title="4、InnoDB数据页结构"></a>4、InnoDB数据页结构</h3><h4 id="（1）File-Header"><a href="#（1）File-Header" class="headerlink" title="（1）File Header"></a>（1）File Header</h4><p>记录各种页都通用的一些头信息。描述了针对各种页的通用信息。例如：</p><ul><li><p>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以<strong>所有的数据页会组成一个双链表</strong>，无需物理上相连。</p></li><li><p>每个页都有一个页号，InnoDB<strong>通过页号可以唯一定位一个页</strong>。</p></li><li><p>校验和与File Trailer中相对应</p></li></ul><h4 id="（2）Page-Header"><a href="#（2）Page-Header" class="headerlink" title="（2）Page Header"></a>（2）Page Header</h4><p>记录数据页的状态信息</p><h4 id="（3）Infimum和Supremum-Record"><a href="#（3）Infimum和Supremum-Record" class="headerlink" title="（3）Infimum和Supremum Record"></a>（3）Infimum和Supremum Record</h4><p>每个数据页有两个虚拟的行记录，用来限定记录的边界。Infimum是比数据页中任何主键值都要小的值，同理另一个。</p><h4 id="（4）User-Record和Free-Space"><a href="#（4）User-Record和Free-Space" class="headerlink" title="（4）User Record和Free Space"></a>（4）User Record和Free Space</h4><p>User Record是实际存储行记录的内容。</p><p>Free Space是空闲空间，链表数据结构。每当我们插入一条记录，都会从该部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，在一条记录被删除后，加入空闲链表中。</p><h4 id="（5）Page-Directory（页目录）"><a href="#（5）Page-Directory（页目录）" class="headerlink" title="（5）Page Directory（页目录）"></a>（5）Page Directory（页目录）</h4><p><strong>B+树索引只能找到记录所在的页，将页载入内存中，再通过page directory进行二分查找才能找到具体的记录</strong>。</p><p><code>InnoDB</code>会为把页中的<strong>记录划分为若干个组</strong>，每个组的最后一个记录的页内地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：</p><ul><li>通过<strong>二分法</strong>确定该记录所在的<strong>槽</strong>。</li><li>通过<strong>记录的next_record</strong>属性<strong>遍历</strong>该槽所在的组中的各个记录。</li></ul><blockquote><p>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</p></blockquote><h4 id="（6）File-Trailer"><a href="#（6）File-Trailer" class="headerlink" title="（6）File Trailer"></a>（6）File Trailer</h4><p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</p><blockquote><p>这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trialer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p></blockquote><h3 id="5、约束"><a href="#5、约束" class="headerlink" title="5、约束"></a>5、约束</h3><p>关系型数据库系统和文件系统地一个不同在于，关系数据库本身能保证存储数据的完整性，无需程序控制。几乎所有的关系型数据库都支持约束机制，来保证数据库的完整性。</p><h4 id="（1）数据完整性"><a href="#（1）数据完整性" class="headerlink" title="（1）数据完整性"></a>（1）数据完整性</h4><p>一般来说数据完整性有三种形式：</p><ul><li>实体完整性保证表中有一个主键（通过PRIMARTY KEY或UNIQUE KEY保证）</li><li>域完整性保证数据每列的值满足特定的条件（通过选定合适的数据类型或外键或触发器保证）</li><li>参照完整性保证两张表之间的关系（通过外键或触发器保证）</li></ul><blockquote><p>InnoDB提供了以下几种约束：</p><ul><li>Primary Key 主键约束</li><li>Unique Key 唯一键约束</li><li>Foreign Key 外键约束</li><li>Default 默认</li><li>NOT NULL 非空约束</li></ul></blockquote><h4 id="（2）约束和索引的区别？"><a href="#（2）约束和索引的区别？" class="headerlink" title="（2）约束和索引的区别？"></a>（2）约束和索引的区别？</h4><p>用户<strong>创建了一个唯一索引就创建了一个唯一的约束</strong>，但是约束和索引的概念还是有所不同的：<strong>约束是一个逻辑概念，用来保证数据的完整性</strong>，而<strong>索引是一个数据结构，既有逻辑上的概念，在数据库中也还代表着物理存储的方式</strong>。</p><h4 id="（3）外键约束"><a href="#（3）外键约束" class="headerlink" title="（3）外键约束"></a>（3）外键约束</h4><p>外键建立时，InnoDB会自动对该列创建一个索引，可以很好地避免外键列上无索引而导致地死锁问题。</p><p>对于参照完整性，外键很有用。但是对于<strong>数据导入时，外键往往导致在外键约束的检查上花费大量时间，因为外键是即时检查的，所以对于导入的每一行都会检查，严重影响性能。</strong></p><h3 id="6、视图"><a href="#6、视图" class="headerlink" title="6、视图"></a>6、视图</h3><p><strong>什么是视图</strong></p><p>视图(VIEW)是一个<strong>虚拟的表</strong>，<strong>一组数据的逻辑表示</strong>，是从数据库中一个或多个表中导出来的，内容由查询定义。视图本身不包含任何数据，这些数据仍然存放在原来的表（基表）中。使用视图查询数据时，仍然从基表中取数据，一旦基表中的数据变化，视图中的数据也会相应改变。</p><p><strong>特点：</strong></p><ul><li>视图的列可以来自不同的表；</li><li>视图是由基表（实表）产生的虚表；</li><li>视图的建立和删除不影响基表；</li><li>对视图内容的更新（增删改）会影响基表；</li><li>当视图来自多个基表时，不允许添加和删除数据</li></ul><p><strong>优点：</strong></p><ul><li><p>简单性</p><p>简化用户对数据的理解和操作，看到的就是需要的，可以将那些经常使用到的查询定义为视图，简化操作；</p></li><li><p>安全性</p><p>可以防止未授权用户查看特定的行或列，使有权限用户只能看到表中特定行</p></li><li><p>逻辑数据独立性</p><p>视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，程序一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。视图可以在以下几个方面使程序与数据独立。</p><p>（1）如果应用建立在数据库表上，当数据库表发生变化时，可以在表上建立视图，通过视图屏蔽表的变化，从而使应用程序可以不动。</p><p>（2）如果应用建立在数据库表上，当应用发生变化时，可以在表上建立视图，通过视图屏蔽应用的变化，从而使数据库表不动。</p><p>（3）如果应用建立在视图上，当数据库表发生变化时，可以在表上修改视图，通过视图屏蔽表的变化，从而使应用程序可以不动。</p><p>（4）如果应用建立在视图上，当应用发生变化时，可以在表上修改视图，通过视图屏蔽应用的变化，从而使数据库可以不动。</p></li></ul><h2 id="五、索引"><a href="#五、索引" class="headerlink" title="五、索引"></a>五、索引</h2><p><strong>什么是索引？</strong></p><p><strong>索引是一种用于快速查询和检索数据的数据结构。</strong>索引就相当于目录，通过对内容建立索引形成目录，方便查找书中的内容。</p><p><strong>InnoDB支持以下几种常见索引：</strong></p><ul><li><p>B+树索引</p><p><strong>B+树索引并不能找到具体的行记录，而是找到记录所在的页，将页读入内存在通过页目录进行二分查找找到相应的记录。</strong></p></li><li><p>全文索引</p><p>MyISAM 存储引擎支持全文索引，InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><p>用<strong>于查找文本中的关键词，而不是直接比较是否相等</strong>。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p></li><li><p>自适应哈希索引</p><p>哈希索引的设计思想是<strong>数据库自适应的，不能人为干预的</strong>，InnoDB存储引擎会<strong>根据表的使用情况在B+树上自动创建一个哈希索引。</strong></p><p>哈希索引能以O(1)时间查询，但是失去了有序性：</p><ul><li><strong>无法用于排序和分组</strong></li><li><strong>只能用于精确等值查找，无法范围查找</strong></li></ul></li></ul><h3 id="1、B-树"><a href="#1、B-树" class="headerlink" title="1、B+树"></a>1、B+树</h3><blockquote><p>B+树中的B不是代表二叉（Binary），而是代表平衡（Balance），因为B+树从最早的平衡二叉树演化而来，但并不是二叉树</p></blockquote><h4 id="（1）B-的由来"><a href="#（1）B-的由来" class="headerlink" title="（1）B+的由来"></a>（1）B+的由来</h4><p>B+树是通过<strong>二叉搜索树</strong>，再由<strong>平衡二叉树</strong>，<strong>B树</strong>演化而来。</p><ul><li><p>在二叉搜索树中，左子树的键值总是小于根节点的键值，右子树的键值总是大于根节点的键值。可以通过中序遍历得到键值的排序输出，但对于同一键值序列，二叉搜索树可以有不同的构造，查找效率也不同。<strong>若想最大性能构造二叉搜索树，需要这颗二叉搜索树是平衡的。</strong></p></li><li><p>平衡二叉树（AVL树）：首先满足二叉搜索树定义，满足<strong>任何节点的两个子树的高度最大差为1</strong>。但平衡二叉树的<strong>维护具有一定的开销</strong>（插入或删除结点），不过一般多用于内存结构对象，维护开销相对较小。</p></li><li><p>B树与AVL树不同的是其属于<strong>多叉树</strong>，且所有<strong>叶子节点均在同一层</strong>，每个节点都存有索引（Key）和数据（Value）</p></li></ul><h4 id="（2）B树与B-树的区别"><a href="#（2）B树与B-树的区别" class="headerlink" title="（2）B树与B+树的区别"></a>（2）B树与B+树的区别</h4><p>B+树是B树的一种变体，不同之处在于：</p><ul><li><p>B 树的所有节点既存放键(key) 也存放数据(data)，而 <strong>B+树只有叶子节点存放 key 和 data，非叶子节点只存放 key</strong>。这使得B+树每个<strong>非叶子节点能保存的关键字增加</strong>，树的<strong>层级也就更少</strong>，查询更快。</p><blockquote><p>有k个子树的中间节点包含有k个元素，而B树中是k-1个元素</p><p><img src="images/image-20210605093741479.png" alt="image-20210605093741479" style="zoom:33%;" /><img src="images/image-20210605093807819.png" alt="image-20210605093807819" style="zoom: 33%;" /></p></blockquote></li><li><p>B 树的叶子节点都是独立的，而B+树的叶子节点有一条<strong>引用链指向与它相邻的叶子节点</strong>。</p></li><li><p>B 树的检索的过程相当于对范围内的<strong>每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了</strong>。而 B+树的<strong>检索效率更稳定</strong>，任何查找都是从根节点到叶子节点的过程（每次查询次数都相同），叶子节点形成了一条有序链表，<strong>全局遍历只需要遍历所有叶子节点</strong>即可。</p></li></ul><h4 id="（3）B-树的不同实现方式"><a href="#（3）B-树的不同实现方式" class="headerlink" title="（3）B+树的不同实现方式"></a>（3）B+树的不同实现方式</h4><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</p><p><strong>MyISAM 引擎中，索引文件和数据文件是分离的</strong>，<strong>B+Tree 叶节点的 data 域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p><strong>InnoDB 引擎中，其数据文件本身就是索引文件</strong>。其<strong>表数据文件本身就是按 B+Tree 组织的一个索引结构</strong>，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主键索引。这被称为“聚簇索引”，而其余的索引都作为辅助索引，<strong>辅助索引的 data 域存储相应记录主键的值而不是地址</strong>。</p><h4 id="（4）MyISAM中的索引方案"><a href="#（4）MyISAM中的索引方案" class="headerlink" title="（4）MyISAM中的索引方案"></a>（4）MyISAM中的索引方案</h4><p>虽然也是采用B+树结构，但是却将索引和数据分开存储：</p><ul><li>将表中记录按照<strong>插入顺序存储</strong>到一个<strong>数据文件</strong>中，这个文件并不划分数据页，可以<strong>通过行号快速访问</strong>到一条记录。</li><li>将索引信息存储到一个<strong>索引文件</strong>中，MyISAM会单独为主键创建一个索引，但是该索引的叶子节点并非完整行记录，而是“主键值+行号”，即<strong>先通过索引找到行号，再通过行号去访问行记录</strong>。</li></ul><h3 id="2、B-树索引"><a href="#2、B-树索引" class="headerlink" title="2、B+树索引"></a>2、B+树索引</h3><p>B+树索引的本质就是B+树在数据库中的实现，但是B+树在数据库中有一个特点是高扇出性，<strong>所以高度一般在2到4层，即查找一次需要2到4次IO</strong>。</p><h4 id="（1）聚簇索引"><a href="#（1）聚簇索引" class="headerlink" title="（1）聚簇索引"></a>（1）聚簇索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD PRIMARY KEY(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure><p>聚簇索引其实是一种<strong>数据存储方式</strong>，聚簇索引<strong>将索引和数据放在了一起</strong>，无需回表。</p><p>InnoDB中的<strong>主键索引就是聚簇索引</strong>，就是<strong>按照每张表的主键构造一棵B+树</strong>，<strong>叶子节点是数据页，存放是整张表的完整行记录数据</strong>；</p><p><strong>非叶子结点是索引页</strong>，存放的是<strong>主键值和指向数据页的偏移量</strong>。</p><blockquote><p>聚簇索引的存储不是物理上连续的，是逻辑上连续的。一是<strong>所有的页按照主键大小，通过双向链表链接</strong>；二是<strong>页中的所有记录也是通过双向链表按主键排序的</strong>。</p><p>因此聚簇索引十分适用于<strong>主键的排序查找和范围查找</strong>。</p></blockquote><h4 id="（2）辅助（二级）索引"><a href="#（2）辅助（二级）索引" class="headerlink" title="（2）辅助（二级）索引"></a>（2）辅助（二级）索引</h4><p>非聚簇索引：MYISAM就是非聚簇索引，<strong>索引和数据分离</strong>，一般需要回表操作（除非覆盖索引）。</p><p>非主键索引都是非聚簇索引，<strong>叶子节点存放的是“索引列+主键值”</strong>。然后再根据<strong>主键值通过聚簇索引</strong>来找到一个完整的行记录所在的数据页（该操作称作<strong>回表</strong>）。</p><p>常见二级索引：</p><ul><li><p><strong>普通索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>唯一索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD UNIQUE(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>联合索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name(&#x27;column1&#x27;, &#x27;column2&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>前缀索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD INDEX index_name(column(10));</span><br></pre></td></tr></table></figure></li><li><p><strong>全文索引</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#x27;table_name&#x27; ADD FULLTEXT(&#x27;column&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）索引的优点"><a href="#（3）索引的优点" class="headerlink" title="（3）索引的优点"></a>（3）索引的优点</h4><ul><li><p>大大加快了数据查询检索的速度。</p></li><li><p>帮助服务器<strong>避免进行排序和分组</strong>，<strong>索引是有序的</strong>，可以用于 ORDER BY 和 GROUP BY 操作。</p><blockquote><p>比如使用ORDER BY将查询结果按照某个字段排序时，若未建立索引，那么需要在额外对查询结果进行排序；</p><p>而如果建立了索引，由于索引本身就是有序的，所以直接按照索引顺序取出即可；</p></blockquote></li><li><p>将随机 I&#x2F;O 变为<strong>顺序 I&#x2F;O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</p></li></ul><h3 id="3、B-树索引的使用"><a href="#3、B-树索引的使用" class="headerlink" title="3、B+树索引的使用"></a>3、B+树索引的使用</h3><h4 id="（1）索引的缺点"><a href="#（1）索引的缺点" class="headerlink" title="（1）索引的缺点"></a>（1）索引的缺点</h4><ul><li><p><strong>空间上的代价</strong></p><p><strong>每建立一个索引都要为它建立一棵B+树</strong>，B+树的每个节点都是一个16KB大小的数据页，<strong>占用物理存储空间</strong>。</p></li><li><p><strong>时间上的代价</strong></p><p><strong>创建索引和维护索引都需要耗费时间</strong>。每次对表中的数据进行增删改操作，都要去维护表对应的每个B+树索引</p></li></ul><h4 id="（2）回表与覆盖索引"><a href="#（2）回表与覆盖索引" class="headerlink" title="（2）回表与覆盖索引"></a>（2）回表与覆盖索引</h4><p>使用二级索引查询时，以范围查询为例，一般根据二级索引查询的记录在磁盘中的存储都是连续的、集中的分布在一个页或几个页中，可以很快读出来，一般称为<strong>顺序IO</strong>；但是这些记录对应的主键值都是分散的，可能分布在很多个不同的数据页中，需要对磁盘进行离散读，称为<strong>随机IO</strong>。</p><p>所以根据二级索引查询一般有如下特点：</p><ul><li>会用到两个B+树索引，一个二级索引，一个聚簇索引</li><li>访问二级索引使用顺序IO，访问聚簇索引使用随机IO</li></ul><p>需要回表的记录越多，使用二级索引的性能就越低，甚至不如用全局扫描。<strong>查询优化器会根据统计数据来估算两种方式的性能开销决定采用索引还是全局扫描。</strong></p><p>为了<strong>避免回表</strong>操作带来的性能开销，最好在查询字段中就只包含索引列，这样就不用回表去聚簇索引中查询了，所以把<strong>只需要用到索引列的查询方式称为覆盖索引</strong>。</p><p>使用覆盖索引的一个好处是，二级索引不含所有记录信息，其大小远小于聚簇索引，可以减少大量的IO操作。</p><h4 id="（3）索引适用条件"><a href="#（3）索引适用条件" class="headerlink" title="（3）索引适用条件"></a>（3）索引适用条件</h4><ul><li><p><strong>全值匹配</strong></p><p>如果查询语句的<strong>搜索条件中的列和索引列一致</strong>的话，这种情况就称为全值匹配</p></li><li><p><strong>匹配最左边的列</strong></p><p>其实查询语句的<strong>搜索条件</strong>中也可以不用包含全部联合索引中的列，<strong>只包含左边的就行</strong>。</p><p>因为<code>B+</code>树的数据页和记录先是按照联合索引最左边的列值排序的，在左边列值相同时，才会用右边的列值排序。</p><p>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</p></li><li><p><strong>匹配列前缀</strong></p><p>B+树中对字符串列的排序规则一般是<strong>逐个比较字符的大小</strong>，类似于联合索引的排序方式，排序好的字符串列一般有下特点：</p><ul><li><p>先按照字符串的第一个字符进行排序。</p></li><li><p>如果第一个字符相同再按照第二个字符进行排序。</p></li><li><p>如果第二个字符相同再按照第三个字符进行排序，依此类推。</p></li></ul><p>也就是说这些字符串的前n个字符，也就是<strong>前缀都是排好序</strong>的，所以对于字符串类型的索引列来说，我们<strong>只匹配它的前缀也是可以快速定位记录</strong>的，比方说我们想查询名字以<code>&#39;As&#39;</code>开头的记录，那就可以这么写查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#x27;As%&#x27;;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，如果<strong>只给出后缀或者中间</strong>的某个字符串则无法定位，只能全局扫描，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#x27;%As%&#x27;;</span><br></pre></td></tr></table></figure><p>如果有时不得不按照后缀查询，那可以将表中数据逆序存储，这就可以将后缀转为前缀了。</p></li><li><p><strong>匹配范围值</strong></p><p>因为B+树中的记录都是按照索引列的值升序排列好的，索引对于范围查找速度特别快。</p></li><li><p><strong>用于排序、分组</strong></p><p>比如ORDER  BY子句用到索引列的话，那么直接按照索引顺序取就好了，不用再将查询结果进行额外的排序操作；</p></li></ul><h4 id="（4）创建索引注意事项"><a href="#（4）创建索引注意事项" class="headerlink" title="（4）创建索引注意事项"></a>（4）创建索引注意事项</h4><ul><li>对于<strong>非常小的表</strong>、大部分情况下<strong>全表扫描</strong>比建立索引更高效；对于<strong>中到大型的表</strong>，<strong>索引</strong>就非常有效；但是对于<strong>特大型的表</strong>，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用<strong>分区技术</strong>。</li></ul><ul><li><p>只为<strong>经常用于查询、排序、分组的列</strong>创建索引，索引的字段尽量不含NULL</p></li><li><p><strong>考虑列的选择性</strong></p><p>即某列中不重复数据的个数与总数的比值，选择性越大，每个记录的区分度越高，查询效率也越高，最好为具有高选择性的列建立索引。</p></li><li><p><strong>索引列的数据类型（数据能表示的范围）尽量小</strong></p><p>数据类型越小，在查询是进行比较操作则越快；占用存储空间更小，数据页可以存放更多的记录，减少磁盘IO，而且可放在内存缓冲区的数据页也更多，加快读写效率</p></li><li><p><strong>频繁更新的列应慎重建立索引</strong></p><p>因为更新操作，需要对索引进行维护，成本很高。</p></li><li><p><strong>使用覆盖索引</strong></p><p>避免回表的性能开销</p></li><li><p><strong>使用联合索引</strong></p><p>在使用多个列作为查询条件时，比单列索引效果好，节约存储空间</p></li><li><p><strong>使用前缀索引</strong></p><p>即只对字符串（例如BLOB、TAXT和VARCHAR）的前几个字符进行索引，既<strong>节省存储空间</strong>（二级索引叶子节点不用再存储完整的字符串值了），又<strong>减少了字符串比较时间</strong>（不用将每个字符都一一比较了）</p></li><li><p><strong>使用自增主键</strong></p><p>让存储引擎自行生成递增主键，每插入一条记录，都是追加操作，不涉及挪动其他记录，也不会触发页面分裂，而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。而且自增主键相对节约存储空间。</p></li><li><p><strong>索引列单独出现</strong></p><p>如果是索引列以某个表达式或者函数调用方式出现，会造成无法命中索引</p></li><li><p><strong>删除冗余、重复、长期未用的索引</strong></p></li></ul><h4 id="（5）扩展知识–Cardinality值"><a href="#（5）扩展知识–Cardinality值" class="headerlink" title="（5）扩展知识–Cardinality值"></a>（5）扩展知识–Cardinality值</h4><p>这是索引中一个非常关键的值，表示索引中唯一值的数目的估计值，查询优化器会根据这个值来判断是否使用这个索引，但该值并非实时更新，只是一个大概的值</p><p>并不是所有在查询条件中出现的列都需要建立索引，一般经验是，在<strong>访问表中很少一部分时使用索引才有意义</strong>。对于性别字段、地区字段、类别字段，它们的可取范围很小，称为低选择性。</p><p>例如按性别查询，每次查询结果都包含了50%的数据，此时添加索引就是没必要的。相反，如果某个字段取值范围很广，几乎无重复，即属于<strong>高选择性，则使用索引非常合适。</strong></p><p>而查看索引是否具有高选择性就可以通过SHOW INDEX结果中的列Cardinality值来观察。</p><p>数据库对于该值的统计都是通过采样的方法来完成的</p><h2 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h2><h3 id="1、认识事务"><a href="#1、认识事务" class="headerlink" title="1、认识事务"></a>1、认识事务</h3><h4 id="（1）什么是事务？"><a href="#（1）什么是事务？" class="headerlink" title="（1）什么是事务？"></a>（1）什么是事务？</h4><p><strong>事务是一个不可分割的数据库操作序列</strong>，<strong>是逻辑上的一组操作</strong>，<strong>要么都执行，要么都不执行</strong>。</p><h4 id="（2）事务的ACID特性"><a href="#（2）事务的ACID特性" class="headerlink" title="（2）事务的ACID特性"></a>（2）事务的ACID特性</h4><p>InnoDB存储引擎支持的事务是完全满足ACID特性的，其他引擎并不一定（例如NDB Cluster不满足D，Oracle默认事务隔离级别READ COMMITTED，不满足I）</p><ul><li><p><strong>A（Atomicity），原子性</strong></p><p><strong>事务是不可分割的最小执行单位</strong>，事务中的所有操作要么全都完成，要么全都不做。</p></li><li><p><strong>C（Consistency），一致性</strong></p><p>一致性保证将数据库从一种一致的状态转变为另一种一致的状态。<strong>执行事务前后，数据库的完整性约束未被破坏</strong>。</p></li><li><p><strong>I（Isolation），隔离性</strong></p><p>也称并发控制。简而言之，<strong>多个用户并发访问数据库时，一个用户的事务不被其他用户事务干扰，彼此独立</strong>）</p></li><li><p><strong>D（durablity），持久性</strong></p><p><strong>事务一旦提交，其结果就是永久性的</strong>。即使发生宕机，数据库也能将其恢复。保证事务系统的高可靠性。</p></li></ul><h4 id="（3）事务的类型"><a href="#（3）事务的类型" class="headerlink" title="（3）事务的类型"></a>（3）事务的类型</h4><ul><li><p><strong>扁平事务</strong></p><p>最简单，最频繁使用的事务，所有操作处于同一层次，其间操作是原子的，要么都执行，要么都回滚。</p><p>主要限制是不能提交或回滚事务的某一部分，或分几个步骤提交。</p></li><li><p><strong>带保存点的扁平事务</strong></p><p>允许在事务执行过程中回滚到同一事务中较早的一个状态。</p><p>保存点用来通知系统应记住事务当前状态，保存点有易失性，而非持久的，系统宕机后会丢失。</p><blockquote><p>定义保存点的语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure><p>回滚到某个保存点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO 保存点名称</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>链事务</strong></p><p>保存点模式的一种变种。提交事务时将必要的上下文隐式传给下一要开始的个事务，即提交事务操作与下一个事务操作合并为一个原子操作，下个事务可以看到上一个事务的结果，好像在一个事务中进行一样</p></li><li><p><strong>嵌套事务</strong></p><p>一个层级结构框架，由一个顶层事务控制着各个层次的事务，如同一棵树一般；InnoDB引擎并不支持。</p><blockquote><p>嵌套事务是由若干事务组成的一棵树，处在叶子节点的是扁平事务，根节点的事务称为顶层事务，在其他称作子事务。子事务既可以提交也可以回滚，但是任何子事务都必须要顶层事务提交后才真正的提交。</p><p>树中任意一个事务的回滚都会引起它的所有子事务的回滚，故子事务只有ACI，没有D特性。</p><p>可以发现，实际工作是由叶子节点完成的，高层事务只负责逻辑控制。</p><p>虽然可以用保存点技术模拟嵌套事务，但是在锁的持有方面还是有所不同的，用户无法选择哪些锁需要被子事务继承，哪些需要被父事务保留，即无论有多少保存点，所有被锁住的对象都可以被得到访问，所以要实现事务间的并行性，需要真正支持的嵌套事务</p></blockquote></li><li><p><strong>分布式事务</strong></p><p>通常是在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</p><blockquote><p>假设一个用户在ATM机进行银行的转账操作，例如持卡人从招商银行的储蓄卡转账10000元到工商银行的储蓄卡。在这种情况下，可以将ATM机视为节点A，招商银行的后台数据库视为节点B，工商银行的后台数据库视为节点C，这个转账的操作可以分解为以下的步骤：<br>1，节点A发出转账命令；<br>2，节点B执行储蓄卡中的余额值减去10000；<br>3，节点C执行储蓄卡中的余额值加上10000；<br>4，节点A通知用户操作完成或者节点A通过用户操作失败。</p><p>这里需要使用分布式事务，因为节点A不能通过调用一台数据库就完成操作。其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的事务操作又都是扁平的。对于分布式事务，其同样需要满足ACID特性，要么都发送，要么都失效。对于上述的例子，如果2,3步中任何一个操作失败，都会导致整个分布式事务回滚。若非这样，结果会很严重。</p></blockquote></li></ul><p>对于InnoDB存储引擎来说，上面五种只有嵌套事务并不原生支持，因此，<strong>对有并行事务需求的用户来说，MySQL数据库或InnoDB存储引擎就显得无能为力了</strong>。然而用户仍可以通过带有保存点的事务模拟串行的嵌套事务。</p><h4 id="（4）MySQL中事务的用法"><a href="#（4）MySQL中事务的用法" class="headerlink" title="（4）MySQL中事务的用法"></a>（4）MySQL中事务的用法</h4><ul><li><p>开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN|START TRANSACTION</span><br></pre></td></tr></table></figure></li><li><p>提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li><li><p>手动回滚</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure></li><li><p>创建保存点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT identifier</span><br></pre></td></tr></table></figure></li><li><p>回滚到保存点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO identifier</span><br></pre></td></tr></table></figure></li><li><p>设置事务的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET TRANASCTION</span><br></pre></td></tr></table></figure></li><li><p>自动提交</p><p>默认情况下，若不使用BEGIN|START TRANACTION显式的开启事务，那么<strong>每一条语句都算是一个独立的事务，执行完语句立马自动执行COMMIT，这称为事务的自动提交</strong></p></li><li><p>隐式提交</p><p>因为某些特殊语句而导致事务提交的情况称为隐式提交</p><ul><li><p>定义或修改数据库对象的数据定义语言（Data definition language，DDL），所谓数据库对象就是数据库、表、视图等，当我们使用CREATE、ALTER、DROP等语句时，就会隐式提交前边语句所属的事务。</p></li><li><p>隐式使用或修改mysql数据库中的表</p></li><li><p>事务控制或关于锁定的事务</p></li><li><p>……</p></li></ul></li></ul><h4 id="（5）对事务操作的统计"><a href="#（5）对事务操作的统计" class="headerlink" title="（5）对事务操作的统计"></a>（5）对事务操作的统计</h4><p>InnoDB引擎需要在考虑每秒请求数（Question Per Second，QPS）的同时，应该关注每秒事务处理的能力（Transaction Per Second，TPS）。</p><h3 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h3><p>事务的隔离性由锁来实现。持久性由重做日志（redo log）实现。undo log用来帮助事务回滚和MVCC的功能。redo日志基本上是顺序写的，undo log是需要进行随机读写的。</p><h4 id="（1）redo-log"><a href="#（1）redo-log" class="headerlink" title="（1）redo log"></a>（1）redo log</h4><p>redo log再第一章已经介绍过了，这里主要以补充为主。</p><p><strong>什么是redo log</strong></p><p>我们进行的增删查改操作均是在Buffer Pool中进行的，可是如果事务提交后，内存断电导致数据丢失，如何保证事务的持久性呢？一个简单做法是，在事务提交时就将该事务所修改的所有页面都刷新到磁盘，但是这种方法，一方面直接刷新一个完整的数据页太浪费了，毕竟有时仅更改了页面中很少的地方；另一方面该事务所修改的页面可能并不相邻，刷盘需要随机IO。</p><p>为了解决这个问题我们只需要把页面修改的内容记录一下就好，在事务提交时，将其刷到磁盘，但系统崩溃需要恢复时，用其恢复即可。redo日志是顺序写入磁盘的，每执行一条语句，可能产生若干日志，根据产生顺序写入磁盘，即顺序IO</p><p><strong>Mini-Transaction概念</strong></p><p>把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，例如向某个索引对应的<code>B+</code>树中插入一条记录的过程即是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志。</p><img src="images/image-20210619133229473.png" alt="image-20210619133229473" style="zoom:67%;" /><p><strong>fsync操作</strong></p><p>redo log分为两部分：一是内存中的重做日志缓冲（ redo log buffer），是易失的；而是重做日志文件（redo log file），是持久的。</p><p><strong>为了确保每次日志都真正写入到重做日志文件中了</strong>，在每次将重做日志缓冲写入重做日志文件后<strong>，InnoDB引擎都要调用一次fsync操作</strong>。</p><p>fsync的效率取决于磁盘性能，因此磁盘性能也决定了事务提交的性能，也就是数据库的性能。</p><blockquote><p>应用程序向磁盘写入文件时其实是先写到操作系统的文件系统缓存，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的fsync函数。</p><p>如果不进行该操作，当操作系统宕机时，重启数据库后会损失未从文件系统缓存刷新到重做日志文件中的那部分事务。而如果仅数据库宕机的话，并不会有损失。</p></blockquote><p><strong>redo log buffer刷盘时机</strong></p><ul><li>master thread每隔一秒会刷盘一次</li><li>当redo log buffer空间不足一半时</li><li>事务提交时</li><li>log checkpoint时</li></ul><p><strong>LSN（Log Sequence Number）</strong></p><p>其代表的是日志序列号，表示事务写入重做日志的字节的总量。</p><blockquote><p>例如，当前重做日志的LSN为1100，若事务T1写入100字节的重做日志，那么LSN变为1100，T2写入200字节重做日志，LSN变为1300。LSN越小，说明重做日志产生的越早。</p></blockquote><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。全局变量<code>buf_next_to_write</code>，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p><img src="images/image-20210619141022772.png" alt="image-20210619141022772" style="zoom:67%;" /><p>我们前边说<code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，全局变量<code>flushed_to_disk_lsn</code>表示刷新到磁盘中的<code>redo</code>日志量，当该值与lsn相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中</p><p>LSN不仅存在于重做日志文件中，还存在于每个页中，表示该页最后刷新时LSN的大小，用来判断页是否需要进行恢复操作。</p><p><strong>恢复</strong></p><p>checkpoint表示已经刷新到磁盘页上的LSN，因此恢复时只需要恢复checkpoint开始的日志部分，即恢复大于checkpoint LSN的日志。</p><h4 id="（2）undo-log"><a href="#（2）undo-log" class="headerlink" title="（2）undo log"></a>（2）undo log</h4><ul><li><p>为了<strong>保证事务的原子性，需要支持回滚操作</strong>，所以每当我们要进行增删改操作时，需要留一手——将回滚时需要的东西记下来，这就需要undo log。undo log存放数据库内部的一个特殊段——undo段，其位于共享表空间。</p></li><li><p><strong>undo log是逻辑日志，只是将数据库逻辑地恢复到原来地样子，使所有的修改都被逻辑地取消</strong>，但是数据结构和页本身回滚后可能大不相同，因为在多用户并发系统中，可能有多个事务同时对同一页中地记录做修改，<strong>所以一个事务的回滚并不能将页回滚到事务开始前的样子，因为这样会影响其他事务正在进行的工作。</strong></p></li><li><p>当将插入事务回滚时，表空间的大小并不会因此而收缩。<strong>回滚时，实际上做的是与之前相反的操作，对于每个INSERT，相应的都有一个DELETE来抵消掉。</strong></p></li><li><p>除了回滚操作，另一个作用就是<strong>MVCC。当用户读取一行记录时，若该记录已被其他事务占用，当前事务可通过undo读取之前的行版本信息，以实现非锁定读取。</strong></p></li><li><p>最后，undo log的产生也会产生redo log，因为undo log也需要持久化保护。</p></li><li><p><strong>事务提交时</strong>，InnoDB引擎会做两件事：</p><ul><li>将<strong>undo log放入链表中，是否最终删除由purge线程来判断操作</strong></li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul><p><strong>事务提交后，并不能马上删除undo log和其所在的页，因为可能还有其他事务需要通过undo log来得到行记录之前的版本</strong></p></li><li><p>undo log格式</p><ul><li><p>insert undo log</p><p><strong>因为insert操作的记录只对本事务可见，这是事务隔离性的要求，所以该undo log可以在事务提交后直接删除，无需purge操作</strong></p></li><li><p>update undo log</p><p><strong>针对delete操作和update操作产生。该undo log可能需要支持MVCC机制，所以不能直接删除，提交时放入链表，候purge发落</strong></p></li></ul></li></ul><h4 id="（3）purge"><a href="#（3）purge" class="headerlink" title="（3）purge"></a>（3）purge</h4><p>执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位。</p><p>而purge用于最终完成delete和update操作。因为InnoDB支持MVCC，事务提交时不能立即进行处理，因为其他事务可能也正在应用同一行记录。所以需要保存记录之前的版本。当该记录不被任何其他事务引用时，方可被后台purge进程真正删除。</p><h3 id="3、事务的隔离级别"><a href="#3、事务的隔离级别" class="headerlink" title="3、事务的隔离级别"></a>3、事务的隔离级别</h3><blockquote><p><code>MySQL</code>是一个<code>客户端／服务器</code>架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（<code>Session</code>）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。</p><p>事务有个特性称为<code>隔离性</code>，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这种串行化方式性能较差，我们既想保持事务的<code>隔离性</code>，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，所以隔离性和性能要有所取舍。</p></blockquote><h4 id="（1）事务并发执行时会遇到的问题"><a href="#（1）事务并发执行时会遇到的问题" class="headerlink" title="（1）事务并发执行时会遇到的问题"></a>（1）事务并发执行时会遇到的问题</h4><ul><li><p><strong>脏写（dirty write）</strong></p><p>如果一个事务修改了另一个未提交事务修改过的数据，即发生了脏写</p></li><li><p><strong>脏读（dirty read）</strong></p><p>如果一个事务读取了另一个未提交事务修改过的数据，即发生了脏读</p></li><li><p><strong>不可重复读（non-repeatable read）</strong></p><p>如果一个事务只能读到已提交的事务修改过的数据，而且其他事务每对该数据进行修改并提交后，该事务都能查询到最新值，即发生了不可重复读</p></li><li><p><strong>幻读（plantom read）</strong></p><p>如果一个事务先根据某些条件查询出一些记录后，之后另一个事务又插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读。</p><blockquote><p>幻读强调的是一个事务按照某个相同条件多次读取记录时，后读时读到了之前没读到的记录。对于先前已读到，后读又未读到的情况相当于对每一条记录都发生了不可重复读现象。</p></blockquote></li></ul><h4 id="（2）SQL标准中的隔离级别"><a href="#（2）SQL标准中的隔离级别" class="headerlink" title="（2）SQL标准中的隔离级别"></a>（2）SQL标准中的隔离级别</h4><ul><li><p><strong>READ UNCOMMITTED：未提交读</strong></p><p>一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p><strong>READ COMMITTED：已提交读</strong></p><p>一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p><strong>REPEATABLE READ：可重复读</strong></p><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，除非是自己修改的数据。</p></li><li><p><strong>SERIALIZABLE：可串行化</strong></p><p>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，所有事务必须逐个<strong>串行执行</strong>。</p></li></ul><p>由于脏写问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p><strong>举例：</strong></p><p>下面是按照时间顺序执行两个事务的行为：</p><img src="images/image-20210620093451941.png" alt="image-20210620093451941" style="zoom:50%;" /><ul><li>若隔离级别是“未提交读”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</li><li>若隔离级别是“已读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li></ul><p>在实现上，数据库里面会<strong>创建一个视图</strong>，访问的时候以视图的逻辑结果为准。在“<strong>可重复读</strong>”隔离级别下，这个视图是在<strong>事务启动时</strong>创建的，整个事务存在期间都用这个视图。在“<strong>已提交读</strong>”隔离级别下，这个视图是在<strong>每个SQL语句开始执行</strong>的时候创建的。</p><p>这里需要注意的是，“<strong>未提交读</strong>”隔离级别下<strong>直接返回记录上的最新值，没有视图</strong>概念；而“<strong>串行化</strong>”隔离级别下直接用<strong>加锁</strong>的方式来避免并行访问。</p><blockquote><p>每个隔离级别都有它自己的使用场景，根据业务情况来定。那什么时候需要“<strong>可重复读”的场景</strong>呢？</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p></blockquote><h4 id="（3）MySQL中支持的四种隔离级别"><a href="#（3）MySQL中支持的四种隔离级别" class="headerlink" title="（3）MySQL中支持的四种隔离级别"></a>（3）MySQL中支持的四种隔离级别</h4><p>不同的数据库厂商对<code>SQL标准</code>中规定的四种隔离级别支持不一样，比方说<code>Oracle</code>就只支持<code>READ COMMITTED</code>和<code>SERIALIZABLE</code>隔离级别。</p><p>MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，<strong>MySQL在REPEATABLE READ隔离级别下，使用Next-Key Lock锁的算法，是可以禁止幻读问题的发生的，即达到SQL标准中的SERIALIZABLE级别</strong></p><p><code>MySQL</code>的默认隔离级别为<code>REPEATABLE READ</code>，我们可以手动修改一下事务的隔离级别。</p><p>我们可以通过下边的语句修改事务的隔离级别：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure><p>其中的<code>level</code>可选值有4个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">level: &#123;</span><br><span class="line">     REPEATABLE READ</span><br><span class="line">   | READ COMMITTED</span><br><span class="line">   | READ UNCOMMITTED</span><br><span class="line">   | SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、MVCC"><a href="#4、MVCC" class="headerlink" title="4、MVCC"></a>4、MVCC</h3><h4 id="（1）版本链"><a href="#（1）版本链" class="headerlink" title="（1）版本链"></a>（1）版本链</h4><p>在可重复读隔离级别下，<strong>事务在启动的时候就“拍了个快照”</strong>。注意，这个快照是基于整库的。实际上，我们并不需要拷贝出整个数据库的数据。我们先来看看<strong>这个快照是怎么实现的？</strong></p><p>InnoDB里面<strong>每个事务有一个唯一的事务ID</strong>，叫作trx_id（transaction id）。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>而<strong>每行数据也都是有多个版本的</strong>。<strong>每次事务更新数据的时候，都会生成一个新的数据版本，并且把trx_id赋值给这个数据版本的事务ID</strong>，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>即<strong>数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id</strong>。下图就是一个记录被多个事务连续更新后的状态。</p><img src="images/image-20210623092105620.png" alt="image-20210623092105620" style="zoom:67%;" /><p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p><p>之前说过，语句更新会生成undo log吗？那么，<strong>undo log在哪呢？</strong></p><p>实际上，图中的三个虚线箭头，就是undo log；而V1、V2、<strong>V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的</strong>。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p><blockquote><p>实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它对MVCC没什么用，它没有历史版本。它占用的Undo Log Segment也会被系统回收。</p></blockquote><h4 id="（2）ReadView"><a href="#（2）ReadView" class="headerlink" title="（2）ReadView"></a>（2）ReadView</h4><blockquote><p>前面已说过，对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好；对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，使用加锁方式来访问记录即可；</p></blockquote><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，<strong>都必须保证读到已经提交了的事务修改过的记录</strong>，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的。</strong></p><blockquote><p>在MySQL里，有两个“视图”的概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li><li>另一个是InnoDB在实现MVCC时用到的<strong>一致性读视图</strong>，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”</p></blockquote><p>为此，提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含4个比较重要的内容：</p><ul><li><p><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中<strong>活跃（启动还未提交）的读写事务的<code>事务id</code>列表</strong>。</p></li><li><p><code>min_trx_id</code>（低水位）：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是**<code>m_ids</code>中的最小值**。</p></li><li><p><code>max_trx_id</code>（高水位）：表示生成<code>ReadView</code>时系统中<strong>应该分配给下一个事务的<code>id</code>值</strong>，即已经创建过的事务ID的最大值加1</p></li><li><p><code>creator_trx_id</code>：表示<strong>生成该<code>ReadView</code>的事务</strong>的<code>事务id</code>。</p><img src="images/image-20210623090557325.png" alt="image-20210623090557325" style="zoom: 67%;" /></li></ul><p></p><p>有了这个<code>ReadView</code>，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li><p>如果被访问版本的<code>trx_id</code><strong>等于<code>creator_trx_id</code><strong>值，表明当前事务</strong>在访问它自己修改过的记录</strong>，该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>落在<strong>绿色部分</strong>，表明<strong>生成该版本的事务</strong>在当前事务生成<code>ReadView</code><strong>前已提交</strong>，该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>落在<strong>红色部分</strong>，表明<strong>生成该版本的事务</strong>在当前事务生成<code>ReadView</code><strong>后才开启</strong>，该版本不可被当前事务访问。</p></li><li><p>如果被访问版本的<code>trx_id</code>落在<strong>黄色部分</strong>，若其<strong>在<code>m_ids</code>列表中</strong>，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的<strong>尚未提交</strong>，该版本不可以被访问；<strong>若不在，说明创建<code>ReadView</code>时生成该版本的事务</strong>已经被提交，该版本可以被访问。</p></li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。</p><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们<strong>生成ReadView的时机不同</strong>：</p><ul><li>READ COMMITTED：该隔离级别的事务，在每次语句执行前都会生成一个独立的ReadView。</li><li>REPEATABLE READ：该隔离级别的事务，只需在事务真正开始时生成一个ReadView，之后事务里的其他查询不会再重复生成。</li></ul><h4 id="（3）实例"><a href="#（3）实例" class="headerlink" title="（3）实例"></a>（3）实例</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure><img src="images/image-20210623094909325.png" alt="image-20210623094909325" style="zoom:67%;" /><p>如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1</p></blockquote><p><strong>Case1:</strong></p><p>这里，我们不妨做如下假设：</p><ol><li>事务A开始前，系统里面只有一个活跃事务ID是99；</li><li>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的row trx_id是90。</li></ol><p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。</p><p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p><img src="images/image-20210623094956694.png" alt="image-20210623094956694" style="zoom: 50%;" /><p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p><p>第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p><p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p><p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p><p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p>现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：</p><ul><li>(1,3)还没提交，属于情况1，不可见；</li><li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li><li>(1,1)是在视图数组创建之前提交的，可见。</li></ul><p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来轻松很多。</p><p><strong>Case2:</strong></p><p>事务B的update语句，如果按照一致性读，好像结果不对？事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p><p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p><p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，<strong>select语句如果加锁，也是当前读。</strong></p><p>所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或 for update，<strong>也都可以读到版本号是101的数据，返回的k的值是3</strong>。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select k from t where id=1 lock in share mode;</span><br><span class="line">mysql&gt; select k from t where id=1 for update;</span><br></pre></td></tr></table></figure><p><strong>Case3:</strong></p><p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p><img src="images/image-20210623100749573.png" alt="image-20210623100749573" style="zoom:67%;" /><p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p><p>这时候，根据“<strong>两阶段锁协议</strong>”。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p><p>到这里，我们把一致性读、当前读和行锁就串起来了。</p><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><h4 id="（4）小结"><a href="#（4）小结" class="headerlink" title="（4）小结"></a>（4）小结</h4><p><strong>MVCC</strong>（Multi-Version Concurrency Control ，<strong>多版本并发控制</strong>）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务<strong>在执行普通的查询操作时访问记录的版本链的过程</strong>，可以<strong>实现事务的并发执行，从而提升系统性能</strong>。</p><p>MVCC，<strong>就是通过生成一个<code>ReadView</code>，然后通过<code>ReadView</code>找到符合条件的行记录版本</strong>（历史版本是由<code>undo日志</code>构建的），其实就像是在<strong>生成<code>ReadView</code>的那个时刻</strong>拍了一个<strong>快照</strong>，<strong>查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，在生成<code>ReadView</code>之前未提交的事务或者之后才开启的事务所做的更改是看不到的</strong>。</p><p>解决了脏读、不可重复读、幻读的问题。</p><p>以“REPEATABLE READ”为例概括下事务隔离的实现：</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><img src="images/image-20210620104225122.png" alt="image-20210620104225122" style="zoom: 67%;" /><p>当前值是4，但是在查询这条记录的时候，<strong>不同时刻启动的事务会有不同的read-view</strong>。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p><p><strong>回滚日志总不能一直保留，具体什么时候可以删除呢？</strong></p><p>就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p><strong>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务？</strong></p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h3 id="5、不好的事务习惯"><a href="#5、不好的事务习惯" class="headerlink" title="5、不好的事务习惯"></a>5、不好的事务习惯</h3><h4 id="（1）在循环中提交"><a href="#（1）在循环中提交" class="headerlink" title="（1）在循环中提交"></a>（1）在循环中提交</h4><p>当发生错误时，数据库会停留在一个未知的位置。例如，用户需要插入10000条用户记录，在第5000条时，发生了错误，这时前面的记录都已经提交，并存在数据库中了，此时该如何处理？</p><p>另一个问题是性能问题，每次提交都要写一次重做日志，相比于将所有操作放在一个事务中进行，无疑增加了大量的性能损耗。</p><h4 id="（2）使用自动提交"><a href="#（2）使用自动提交" class="headerlink" title="（2）使用自动提交"></a>（2）使用自动提交</h4><p>编写应用程序开发时，最好把事物的控制权交给开发人员，即在程序端进行事务的开始和结束。</p><h4 id="（3）使用自动回滚"><a href="#（3）使用自动回滚" class="headerlink" title="（3）使用自动回滚"></a>（3）使用自动回滚</h4><p>对于开发人员来说，重要的不是知道发生了错误，而是发生了什么样的错误，因此自动回滚存在这样一个问题。</p><h2 id="七、锁"><a href="#七、锁" class="headerlink" title="七、锁"></a>七、锁</h2><h3 id="1、并发事务带来的问题"><a href="#1、并发事务带来的问题" class="headerlink" title="1、并发事务带来的问题"></a>1、并发事务带来的问题</h3><p>并发事务访问相同记录情况有三：</p><h4 id="（1）读-读"><a href="#（1）读-读" class="headerlink" title="（1）读 - 读"></a>（1）<strong>读 - 读</strong></h4><p>没问题，允许发生</p><h4 id="（2）写-写"><a href="#（2）写-写" class="headerlink" title="（2）写 - 写"></a>（2）写 - 写</h4><p>可能发生脏写，不允许。多个未提交事务相继修改同一记录时，是要排队执行，通过锁实现。所谓锁其实是一种内存中的结构，当事务要对该记录做改动时，首先检查有无与该记录关联的锁结构，没有则添加一个。</p><img src="images/image-20210621080748105.png" alt="image-20210621080748105" style="zoom: 50%;" /><p>上述简化锁结构：</p><ul><li><p>trx信息：表示该锁是哪个事务生成的</p></li><li><p>is_waiting：表示当前事务是否在等待</p></li></ul><p>当事务T1加锁成功后（is_waiting为false），事务可以正常执行；当T2也想改动该记录时，发现已有锁结构与之关联，于是也生成一个锁结构（is_waiting为true，表示当前事务需要等待），加锁失败。T1提交后，会把其锁结构释放掉，把T2对应线程唤醒，继续执行。</p><img src="images/image-20210621081250690.png" alt="image-20210621081250690" style="zoom:50%;" /><h4 id="（3）读-写"><a href="#（3）读-写" class="headerlink" title="（3）读 - 写"></a>（3）<strong>读 - 写</strong></h4><p>可能发生脏读、不可重复读、幻读。</p><h4 id="（4）如何解决读-写带来的问题"><a href="#（4）如何解决读-写带来的问题" class="headerlink" title="（4）如何解决读-写带来的问题"></a>（4）如何解决读-写带来的问题</h4><ul><li><p><strong>方案一：读操作利用MVCC，写操作加锁</strong></p><p>MVCC前面已介绍过，<strong>就是通过生成一个<code>ReadView</code>，然后通过<code>ReadView</code>找到符合条件的记录版本</strong>（历史版本是由<code>undo日志</code>构建的），其实就像是在<strong>生成<code>ReadView</code>的那个时刻</strong>做了一次时间静止（就像用相机拍了一个<strong>快照</strong>），<strong>查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，在生成<code>ReadView</code>之前未提交的事务或者之后才开启的事务所做的更改是看不到的</strong>。而<strong>写操作针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用<code>MVCC</code>时，<code>读-写</code>操作并不冲突。</strong></p></li><li><p><strong>方案二：读写操作均加锁</strong></p><p>如果我们的一些<strong>业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本</strong>。比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在<strong>读取记录的时候也就需要对其进行<code>加锁</code>操作</strong>，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p><blockquote><ul><li><p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果<strong>另一个事务在写记录的时候就给这条记录加锁（写加锁），那么当前事务就无法继续读取该记录</strong>了，所以也就不会有脏读问题的产生了。</p></li><li><p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在<strong>当前事务读取记录时就给该记录加锁（读加锁），那么另一个事务就无法修改该记录</strong>，自然也不会发生不可重复读了。</p></li><li><p>幻读的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把<strong>新插入的那些记录称之为幻影记录</strong>。加锁的方式解决幻读问题就麻烦了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候并不知道给哪条记录加锁，这个下面会讲。</p></li></ul></blockquote><p>显然，采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。但具体还需看业务场景</p></li></ul><h3 id="2、锁的理论知识"><a href="#2、锁的理论知识" class="headerlink" title="2、锁的理论知识"></a>2、锁的理论知识</h3><h4 id="（1）一致性读"><a href="#（1）一致性读" class="headerlink" title="（1）一致性读"></a>（1）一致性读</h4><p><strong>事务利用MVCC进行的读取操作称为一致性读，也称快照读</strong>，所有<strong>普通的SELECT语</strong>句（plain SELECT）在 READ COMMITED 和 REPEATABLE READ隔离级别下都算是一致性读。<strong>一致性读不会对表中任何记录进行加锁，其他事务可以自由对表中记录做改动。</strong></p><h4 id="（2）锁定读"><a href="#（2）锁定读" class="headerlink" title="（2）锁定读"></a>（2）锁定读</h4><blockquote><p>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。</p></blockquote><p><strong>也称当前读，读取的是最新版本，使用加锁方式，既要满足读-读操作不受影响，也要使写-写、读-写情况中的操作相互阻塞</strong>，所以设计了两种锁：</p><ul><li>共享锁（Shared Locks，S锁）。事务读取一条记录时，需要先获取该记录的S锁。</li><li>独占锁（Exclusive Locks，X锁）。事务改动一条记录前，需先获取该记录的X锁。</li></ul><p>S锁只和S锁兼容，X锁与任意锁都不兼容。</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>S</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">兼容</td></tr></tbody></table><p><strong>锁定读的语句：</strong></p><p>有时想在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此设计了两种特殊的SELECT语句：</p><ul><li>对读取的记录加S锁</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><ul><li>对读取的记录加X锁</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure><h4 id="（3）写操作"><a href="#（3）写操作" class="headerlink" title="（3）写操作"></a>（3）写操作</h4><p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p><ul><li><p><code>DELETE</code>：</p><p>对一条记录做<code>DELETE</code>操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取一下这条记录的<code>X锁</code>，然后再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p><code>UPDATE</code>：</p><p>在对一条记录做<code>UPDATE</code>操作时分为三种情况：</p><ul><li><p>如果未修改该记录的主键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p>如果未修改该记录的主键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p></li><li><p>如果修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</p></li></ul></li><li><p><code>INSERT</code>：</p><p>一般情况下，新插入一条记录的操作并不加锁，<code>InnoDB</code>存储引擎通过一种称之为<code>隐式锁</code>来保护这条新插入的记录在本事务提交前不被别的事务访问。</p></li></ul><h4 id="（4）多粒度锁"><a href="#（4）多粒度锁" class="headerlink" title="（4）多粒度锁"></a>（4）多粒度锁</h4><p>我们前边提到的<code>锁</code>都是针对记录的，称之为<code>行级锁</code>或者<code>行锁</code>，细粒度锁；其实一个事务也可以在<code>表</code>级别进行加锁，称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，粗粒度锁。给表加的锁也可以分为<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>）。</p><p><strong>InnoDB支持多粒度锁定，即允许事务在行级和表级上的锁同时存在</strong>，为了支持该操作，InnoDB还提供了一种额外的加锁方式，称为意向锁，其是表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁类型：</p><ul><li><strong>意向共享锁</strong>（Intention Shared Lock）：事务想要获得一张表中某几行的共享锁。（当事务准备在某条记录上加S锁时，需要先在表级别上加个IS锁）</li><li><strong>意向独占锁</strong>（Intention Exclusive Lock）：事务想要获得一张表中某几行的独占锁。（当事务准备在某条记录上加X锁时，需要先在表级别上加个IX锁）</li></ul><p><strong>总结：</strong></p><p>IS、IX锁是表级锁，它们的提出仅仅<strong>为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录</strong>，也就是说其实IS锁之间均是互相兼容的。IS锁与X锁不兼容，IX锁与S锁、X锁均不兼容。</p><p>​       </p><p>​     </p><h3 id="3、MySQL中的行锁和表锁"><a href="#3、MySQL中的行锁和表锁" class="headerlink" title="3、MySQL中的行锁和表锁"></a>3、MySQL中的行锁和表锁</h3><h4 id="（1）其他存储引擎中的锁"><a href="#（1）其他存储引擎中的锁" class="headerlink" title="（1）其他存储引擎中的锁"></a>（1）其他存储引擎中的锁</h4><p>针对MyISAM、MEMORY、MERGE这些存储引擎来说，<strong>只支持表级锁</strong>，而且这些引擎<strong>也不支持事务</strong>，所以使用这些存储引擎的锁一般都是<strong>针对当前会话</strong>来说。</p><p>由于使用这些存储引擎的表在<strong>同一时刻只允许一个会话对表进行写操作，所以这些存储引擎最好用在只读或大部分都是读操作，或单用户（即单会话）的情景下。</strong></p><p>此外，在MyISAM中有个Concurrent Inserts的特性，<strong>支持在对MyISAM表读取时同时插入记录，可以提升一些插入速度。</strong></p><h4 id="（2）InnoDB存储引擎中的表级锁"><a href="#（2）InnoDB存储引擎中的表级锁" class="headerlink" title="（2）InnoDB存储引擎中的表级锁"></a>（2）InnoDB存储引擎中的表级锁</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。</p><ul><li><p><strong>表级的S锁和X锁</strong></p><p>鸡肋，基本不用</p></li><li><p><strong>表级的IS锁和IX锁</strong></p><p>当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>，X锁类似。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p></li><li><p><strong>表级的AUTO-INC锁</strong></p><p>略</p></li></ul><h4 id="（3）InnoDB存储引擎中的行级锁"><a href="#（3）InnoDB存储引擎中的行级锁" class="headerlink" title="（3）InnoDB存储引擎中的行级锁"></a>（3）InnoDB存储引擎中的行级锁</h4><blockquote><p><strong>InnoDB的行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。</strong></p></blockquote><ul><li><p><strong>Record Locks</strong></p><p>记录锁，仅仅是把一条记录锁上。官方名称是：LOCK_REC_NOT_GAP 。</p></li><li><p><strong>Gap Locks</strong></p><p>间隙锁，锁定一个范围，但不包括记录本身</p><p>MySQL在REPEATABLE READ隔离级别下是可以<strong>解决幻读</strong>问题的。</p><blockquote><p><strong>在RR的隔离级别下，Innodb使用MVCC和next-key locks解决幻读，MVCC解决的是一致性读读（快照读）的幻读，next-key locks解决的是当前读（锁定读）情况下的幻读。</strong></p></blockquote><p><strong>除了用MVCC方案解决，也可用加锁方案解决</strong>，但<strong>问题在于事务在第一次读取时，幻影记录尚不存在，无法对其上锁</strong>。因此提出一种Gap Locks锁，官方名称LOCK_GAP。</p><img src="images/image-20210621104917562.png" alt="image-20210621104917562" style="zoom:50%;" /><p>如图，给number为8的记录加了gap锁，意味着不允许别的事务在8前面的间隙插入新纪录，即number为（3，8）这个区间的新纪录不允许立即插入。</p><p>如果对一条记录加了gap锁，并不妨碍其他事务对该记录加record锁或gap锁。</p></li><li><p><strong>Next - Key Locks</strong></p><p>有时<strong>既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新纪录</strong>，所以设计了一种Next- Key Locks，官称LOCK_ORDINARY。</p><img src="images/image-20210621105636494.png" alt="image-20210621105636494" style="zoom:50%;" /><p>本质就是一个record锁和一个gap锁的合体，它<strong>既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙</strong>。</p></li><li><p><strong>Inert Intention Locks</strong></p><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>，后边就不强调了），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。InnoDB引擎规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待，于是命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，可以称为<code>插入意向锁</code>。</p></li><li><p><strong>隐式锁</strong></p><p>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态</p></li></ul><h4 id="（4）InnoDB锁的内存结构"><a href="#（4）InnoDB锁的内存结构" class="headerlink" title="（4）InnoDB锁的内存结构"></a>（4）InnoDB锁的内存结构</h4><p>为了节约成本，一个事务在对不同记录加锁时，若符合以下条件，那么这些记录的锁就可以被放到同一个锁结构中。</p><ul><li><p>在同一个事务中进行加锁操作</p></li><li><p>被加锁的记录在同一个页面中</p></li><li><p>加锁的类型是一样的</p></li><li><p>等待状态是一样的</p><img src="images/image-20210623080034901.png" alt="image-20210623080034901" style="zoom:67%;" /></li></ul><p></p><h4 id="（5）两阶段锁协议"><a href="#（5）两阶段锁协议" class="headerlink" title="（5）两阶段锁协议"></a>（5）两阶段锁协议</h4><p>在InnoDB事务中，<strong>行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等事务提交才释放，这即两阶段锁协议</strong>。</p><p>针对该协议，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><blockquote><p>例如：假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。这个业务需要涉及到以下操作：</p><ol><li>从顾客A账户余额中扣除电影票价；</li><li>给影院B的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，如何安排这三个语句在事务中的顺序呢？</p></blockquote><p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地<strong>减少了事务之间的锁等待，提升了并发度。</strong></p><h4 id="（6）死锁和死锁检测"><a href="#（6）死锁和死锁检测" class="headerlink" title="（6）死锁和死锁检测"></a>（6）死锁和死锁检测</h4><p>当并发系统中<strong>不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时</strong>，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><img src="images/image-20210623082020263.png" alt="image-20210623082020263" style="zoom: 50%;" /><p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>策略一：直接进入<strong>等待，直到超时</strong>。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>策略二：<strong>发起死锁检测</strong>，发现死锁后，主动<strong>回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>一般采用第二种策略。但主动死锁检测也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><blockquote><p>如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p></blockquote><p>由这种热点行更新导致的性能问题的症结在于，死锁检测要耗费大量的CPU资源。</p><ul><li><p><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p></li><li><p><strong>另一个思路是控制并发度。</strong>如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。客户端做并发控制不太现实，因为客户端太多。即使每个客户端并发数控制得很低，所有客户端汇集起来也很高。因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现</p></li><li><p>除此之外，还可以从设计上优化这个问题呢，可以考虑通过<strong>将一行改成逻辑上的多行来减少锁冲突</strong>。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p></li></ul><h2 id="八、补充"><a href="#八、补充" class="headerlink" title="八、补充"></a>八、补充</h2><h3 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h3><p>一条查询语句在经过MySQL的<strong>优化器</strong>后会生成一个<strong>执行计划</strong>。这个计划展示了具体的查询方式，比如多表连接的顺序是什么、使用哪个索引来进行查询等；可以使用<strong>Explain语句</strong>来查看某个语句的具体执行计划。</p><p>Explain语句输出的列有：</p><table><thead><tr><th align="center">列名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>id</code></td><td align="left">在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td></tr><tr><td align="center"><code>select_type</code></td><td align="left"><strong>每个SELECT关键字对应的那个查询的类型，有简单查询、联合查询、子查询</strong></td></tr><tr><td align="center"><code>table</code></td><td align="left">表名</td></tr><tr><td align="center"><code>partitions</code></td><td align="left">匹配的分区信息</td></tr><tr><td align="center"><code>type</code></td><td align="left"><strong>针对单表的访问方法</strong></td></tr><tr><td align="center"><code>possible_keys</code></td><td align="left"><strong>可能用到的索引</strong></td></tr><tr><td align="center"><code>key</code></td><td align="left"><strong>实际上使用的索引</strong></td></tr><tr><td align="center"><code>key_len</code></td><td align="left">实际使用到的索引长度</td></tr><tr><td align="center"><code>ref</code></td><td align="left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td align="center"><code>rows</code></td><td align="left"><strong>估算的返回结果集记录数目</strong></td></tr><tr><td align="center"><code>filtered</code></td><td align="left">某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td align="center"><code>Extra</code></td><td align="left">一些额外的信息</td></tr></tbody></table><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的<strong>table列代表着该表的表名</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>select_type：</strong></p><p><img src="/images/image-20210829174405432.png" alt="image-20210829174405432"></p><p><strong>type：</strong></p><ul><li>const：通过主键索引或唯一键索引来定位一条记录的访问方法</li><li>ref：使用某个普通的二级索引列与常数值等值比较的访问方法</li><li>range：利用索引值进行范围匹配的访问方法</li><li>index：</li><li>all：全表扫描，对于InnoDB表来说就是直接扫描聚簇索引</li></ul><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL中通过慢查询日志用来记录响应时间超过阈值的SQL语句。</p><p>主要有三个重要的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%query%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>slow_query_log：OFF，是否开启慢查询日志，默认是关闭的，因为开启会带来些许性能损耗；</li><li>long_query_time：10，定义阈值，默认是10s，响应时间超过10秒的语句就被定义为慢语句，记录到慢查询日志中；</li><li>slow_query_log_file：&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow**.**log，定义慢查询日志所在的位置；</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global slow_query_log = ON;</span><br><span class="line">set global slow_query_time = 1;</span><br></pre></td></tr></table></figure><p>这种方法只对当前数据库生效，MySQL重启后则会失效；如果要永久生效，必须修改配置文假案my.cnf</p><p>可以使用<strong>日志分析工具mysqldumpslow来查看慢查询日志</strong>；</p><p>可以通过 <strong>show processlist来查看正在进行的慢查询SQL</strong>，show processlist 显示哪些线程正在运行</p><p><img src="/images/image-20210829172810676.png" alt="image-20210829172810676"></p><p>定位到慢查询SQL后，首先分析语句，看是否读取了额外的不必要的列，然后使用<strong>Explain命令分析SQL的执行计划</strong>并进行相应的优化：</p><ul><li>如果是因为没走索引，可以考虑<strong>建立合适的索引</strong>；</li><li>优化器可以选择了错误的索引导致效率低下，可以修改SQL语句逻辑<strong>引导优化器选择正确的索引</strong>，或者<strong>强制使用</strong>（force index）合适的索引</li><li>如果因为数据库表太大，即使走了索引也依然很慢，可以考虑分表；</li></ul><h3 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h3><h4 id="SQL约束有哪些"><a href="#SQL约束有哪些" class="headerlink" title="SQL约束有哪些"></a>SQL约束有哪些</h4><ul><li>非空约束：NOT NULL，约束字段内容不能为空；</li><li>唯一约束：UNIQUE，约束字段内容不能重复，一个表可以有多个唯一约束；</li><li>主键约束：PRIMARY KEY，约束字段为主键，主键值唯一，一个表只能有一个；</li><li>外键约束：</li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h4 id="delete、drop和truncate的区别"><a href="#delete、drop和truncate的区别" class="headerlink" title="delete、drop和truncate的区别"></a><strong>delete、drop和truncate的区别</strong></h4><ul><li>delete<strong>删除表的全部或者部分数据行</strong>，表结构还在，删除速度比较慢，需要逐行删除，可以回滚；</li><li>truncate<strong>删除表中的全部数据</strong>，表结构还在，删除速度比较快，不可回滚；</li><li>drop<strong>从数据库中删除整张表</strong>，所有的数据行、索引等都会被删除，删除速度最快，不可回滚；</li></ul><p>truncate和drop都属于DDL（数据库定义语言），而delete属于属于DML（数据库操作语言）</p><ul><li><strong>DML，数据库操作语言</strong>，包括常用的增删改查等常用操作，只涉及对表中数据的操作；</li><li><strong>DDL，数据库定义语言</strong>，会涉及到对表的定义结构的修改，开发人员较少使用，更多由DBA（数据库管理员）使用；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2022/05/17/springboot/springboot/"/>
      <url>/2022/05/17/springboot/springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot-日志"><a href="#SpringBoot-日志" class="headerlink" title="SpringBoot 日志"></a>SpringBoot 日志</h3><h4 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h4><p>JUL、JCL、jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志的抽象层</th><th>日志的实现</th></tr></thead><tbody><tr><td><del>JCL(jakarta commons logging)</del>     SLF4J(Simple Logging Facade for Java)    <del>jboss-logging</del></td><td>Log4j  JUL(java.util.logging)  Log4j2   Logback</td></tr></tbody></table><p>日志门面：SLF4J;</p><p>日志实现：Logback</p><p>SpringBoot:底层是Spring框架，Spring框架默认的是JCL</p><p>SpringBoot选用的是SLF4J和Logback</p><h4 id="2-SLF4J使用"><a href="#2-SLF4J使用" class="headerlink" title="2.SLF4J使用"></a>2.SLF4J使用</h4><h5 id="1-如何在系统中使用SLF4J"><a href="#1-如何在系统中使用SLF4J" class="headerlink" title="1.如何在系统中使用SLF4J"></a>1.如何在系统中使用SLF4J</h5><p>以后开发的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里的方法。</p><p>给系统里面导入SLF4J的jar和logback的jar。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![slf5j](SpringBoot 日志.assets\slf5j.png)</p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志框架自己本身的配置文件。</strong></p><h5 id="2-遗留问题"><a href="#2-遗留问题" class="headerlink" title="2. 遗留问题"></a>2. 遗留问题</h5><p>a系统使用（slf4j+logback）:Spring(commons-logging),Hibernate(jboss-logging),Mybatis,xxx</p><p>统一日志记录，即使是别的框架和我仪器统一使用slf4j进行输出。</p><p>![legacy](SpringBoot 日志.assets\legacy.png)</p><blockquote><p>如何让系统中所有的日志都统一到slf4j:</p><ol><li>将系统中其他日志框架先排除出去；</li><li>用中间包替换原有的日志框架；</li><li>导入slf4j其他的实现。</li></ol></blockquote><h4 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot使用它来启动日志：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>![image-20211013220417367](SpringBoot 日志.assets\image-20211013220417367-1634133859595.png)</p><p>总结：</p><ul><li><p>SpringBoot底层也是使用slf4j+logback的方式记录日志</p></li><li><p>SpringBoot也把其他的日志都替换成了slf4j;</p></li><li><p>中间的替换包</p></li><li><p>如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除调。</p><ul><li>![image-20211013221847468](SpringBoot 日志.assets\image-20211013221847468-1634134728410.png)</li></ul><p><strong>现在的 版本已经没有移除这一属性了</strong></p></li></ul><p><strong>SpringBoot能自动适配所有的日志，而且顶层使用slf4j+logback的方式记录日志，引入其他日志框架的时候，只需要把这个框架依赖的日志框架排除掉。</strong></p><h4 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h4><h5 id="1-默认配置"><a href="#1-默认配置" class="headerlink" title="1.默认配置"></a>1.默认配置</h5><p>SpringBoot默认帮我们配置好了日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootLoggingApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//记录器</span></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//日志的级别：</span></span><br><span class="line">        <span class="comment">//由低到高：trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">        <span class="comment">//可以调整输出的日志级别：日志就只会在这个级别及以后的高级别生效</span></span><br><span class="line">        logger.trace(<span class="string">&quot;这是trace日志...&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;这是debug日志...&quot;</span>);</span><br><span class="line">        <span class="comment">//spring boot默认是info级别的,没有指定级别的就用SpringBoot默认的级别：root级别</span></span><br><span class="line">        logger.info(<span class="string">&quot;这是info日志...&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;这是warn日志...&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;这是error日志...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">日志输出格式：</span></span><br><span class="line"><span class="attr">%d表示日期时间，</span></span><br><span class="line"><span class="attr">%thread表示线程名，</span></span><br><span class="line"><span class="attr">%-5level：级别从左到右显示5个字符宽度，</span></span><br><span class="line"><span class="attr">%logger&#123;50&#125;</span>:<span class="string">logger名字最长显示50个字符，否则按照句点分割</span></span><br><span class="line"><span class="attr">%msg</span>:<span class="string">日志消息</span></span><br><span class="line"><span class="attr">%n</span>:<span class="string">换行符</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level.com.neu</span> = <span class="string">trace</span></span><br><span class="line"><span class="comment">#logging.file.path = D:/logs</span></span><br><span class="line"><span class="attr">logging.file.name</span>= <span class="string">iqc.log</span></span><br><span class="line"><span class="comment"># 在控制台输出的日志的格式</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>= <span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>= <span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level ===%logger&#123;50&#125; === %msg%n</span></span><br></pre></td></tr></table></figure><h5 id="2-指定配置"><a href="#2-指定配置" class="headerlink" title="2.指定配置"></a>2.指定配置</h5><p>给类路径下放上每个日志框架自己的配置文件即可，；SpringBoot就使用自己默认的配置了。</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml:直接就被日志框架识别了</p><p>logback-spring.xml:日志框架就不直接加载日志的配置项，由SpringBoot加载，可以使用SpringBoot的高级<strong>Profile</strong>功能。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line">    可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h4><p>可以按照slf4j日志适配图，进行相关的切换。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为log4j2</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在类路径下添加：log4j2-spring.xml文件</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud</title>
      <link href="/2022/05/17/springcloud-1/"/>
      <url>/2022/05/17/springcloud-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springcloud 简单使用</title>
      <link href="/2022/05/16/springcloud/"/>
      <url>/2022/05/16/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="1-工程结构"><a href="#1-工程结构" class="headerlink" title="1.工程结构"></a>1.工程结构</h1><p><img src="/img/springcloud/%E6%9E%B6%E6%9E%84.png" alt="image-20220514173827715"></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx简单使用</title>
      <link href="/2022/05/11/nginx/nginx%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/11/nginx/nginx%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Nginx版本区别"><a href="#1-Nginx版本区别" class="headerlink" title="1.Nginx版本区别"></a>1.Nginx版本区别</h3><ul><li>Nginx开源版  <a href="http://nginx.org/">http://nginx.org/</a></li><li>Nginx plus 商业版   <a href="https://www.nginx.com/">https://www.nginx.com</a></li><li>openresty  <a href="http://openresty.org/cn/">http://openresty.org/cn/</a></li><li>Tengine <a href="http://tengine.taobao.org/">http://tengine.taobao.org</a></li></ul><h3 id="2-源码编译安装"><a href="#2-源码编译安装" class="headerlink" title="2.源码编译安装"></a>2.源码编译安装</h3><ol><li>解压文件：tar zxvf nginx-1.21.6.tar.gz</li><li>切换目录：cd nginx-1.21.6</li><li>安装：.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx   <em># –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx 指安装路径是&#x2F;usr&#x2F;local&#x2F;nginx</em></li><li>编译：make</li><li>编译安装：make install</li></ol><h3 id="3-启动与停止"><a href="#3-启动与停止" class="headerlink" title="3. 启动与停止"></a>3. 启动与停止</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./nginx    <span class="comment"># 启动</span></span><br><span class="line">./nginx -s stop <span class="comment">#快速停止</span></span><br><span class="line">./nginx -s quit <span class="comment">#优雅关闭，在退出前完成已经接受的连接请求</span></span><br><span class="line">./nginx -s reload <span class="comment">#重新加载配置</span></span><br></pre></td></tr></table></figure><h3 id="4-安装遇到的问题及解决"><a href="#4-安装遇到的问题及解决" class="headerlink" title="4.安装遇到的问题及解决"></a>4.安装遇到的问题及解决</h3><ul><li>问题1</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">checking <span class="keyword">for</span> OS</span><br><span class="line">+ Linux 3.10.0-693.el7.x86_64 x86_64</span><br><span class="line">checking <span class="keyword">for</span> C compiler ... not found</span><br><span class="line">./configure: error: C compiler cc is not found</span><br></pre></td></tr></table></figure><ul><li>解决1</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc</span><br></pre></td></tr></table></figure><ul><li><p>问题2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either <span class="built_in">disable</span> the module by using --without-http_rewrite_module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the <span class="built_in">source</span> with nginx by using --with-pcre=&lt;path&gt; option.</span><br></pre></td></tr></table></figure></li><li><p>解决2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure></li><li><p>问题3</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either <span class="built_in">disable</span> the module by using --without-http_gzip_module</span><br><span class="line">option, or install the zlib library into the system, or build the zlib library</span><br><span class="line">statically from the <span class="built_in">source</span> with nginx by using --with-zlib=&lt;path&gt; option.</span><br></pre></td></tr></table></figure></li><li><p>解决3</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-安装成系统服务"><a href="#5-安装成系统服务" class="headerlink" title="5.安装成系统服务"></a>5.安装成系统服务</h3><ul><li><p>创建服务脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure></li><li><p>服务脚本内容</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><img src="/./20220511/ngxin%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9" alt="image-20220511100443102"></p></li><li><p>重新加载系统服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><blockquote><p>注意：启动服务之前，把之前通过nginx命令运行起来的服务先关掉，即 nginx -s top</p><p>如果忘记关了，通过  **ps -ef | grep nginx ** 命令查看运行端口，通过 <strong>kill -9 port</strong> 命令杀死进程，之后再运行下面服务启动命令即可</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure></li><li><p>查看服务是否启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p>出现：<strong>active（running）</strong>则服务启动</p></li><li><p>设置为开机自启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
